// This is not autogenerated.
package core

import (
	"database/sql/driver"
	"encoding/json"
	"fmt"
)



func StructToMap(obj interface{}) (map[string]interface{}, error) {
	var result map[string]interface{}
	bytes, err := json.Marshal(obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(bytes, &result)
	if err != nil {
		return nil, err
	}
	return result, nil
}

func MapToStruct(m map[string]interface{}, obj interface{}) error {
	bytes, err := json.Marshal(m)
	if err != nil {
		return err
	}
	err = json.Unmarshal(bytes, obj)
	if err != nil {
		return err
	}
	return nil
}

// Map is a map[string]interface.
type Map map[string]any

// Scan implements the sql.Scanner interface.
// It allows to read the map from the database value.
func (m *Map) Scan(src interface{}) error {
	var b []byte
	switch t := src.(type) {
	case nil:
		return nil
	case []byte:
		b = t
	case string:
		b = []byte(t)
	default:
		return fmt.Errorf("scan source was not []byte nor string but %T", src)
	}
	err := json.Unmarshal(b, m)
	if err != nil {
		return err
	}
	return nil
}

// Value implements the driver.Valuer interface.
// It allows to convert the map to a driver.value.
func (m Map) Value() (driver.Value, error) {
	b, err := json.Marshal(m)
	if err != nil {
		return nil, err
	}
	return string(b), nil
}

// UnmarshalJSON will unmarshall JSON value into
// the map representation of this value.
func (m *Map) UnmarshalJSON(b []byte) error {
	// To avoid recursive calls to UnmarshalJSON, we unmarshal into the underlying type.
	var proxy map[string]any
	if err := json.Unmarshal(b, &proxy); err != nil {
		return err
	}
	*m = proxy
	return nil
}