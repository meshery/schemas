// Package relationship provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package relationship

import (
	"encoding/json"
	"fmt"

	"github.com/gofrs/uuid"
	"github.com/meshery/schemas/models/v1alpha1/capability"
	"github.com/meshery/schemas/models/v1beta1/category"
	"github.com/meshery/schemas/models/v1beta1/connection"
	"github.com/meshery/schemas/models/v1beta1/subcategory"
	"github.com/oapi-codegen/runtime"
)

// Defines values for RelationshipDefinitionCapabilitiesEntityState.
const (
	Declaration RelationshipDefinitionCapabilitiesEntityState = "declaration"
	Instance    RelationshipDefinitionCapabilitiesEntityState = "instance"
)

// Defines values for RelationshipDefinitionCapabilitiesStatus.
const (
	RelationshipDefinitionCapabilitiesStatusDisabled RelationshipDefinitionCapabilitiesStatus = "disabled"
	RelationshipDefinitionCapabilitiesStatusEnabled  RelationshipDefinitionCapabilitiesStatus = "enabled"
)

// Defines values for RelationshipDefinitionKind.
const (
	Edge         RelationshipDefinitionKind = "edge"
	Hierarchical RelationshipDefinitionKind = "hierarchical"
	Sibling      RelationshipDefinitionKind = "sibling"
)

// Defines values for RelationshipDefinitionMetadataStyles0CurveStyle.
const (
	Bezier          RelationshipDefinitionMetadataStyles0CurveStyle = "bezier"
	Haystack        RelationshipDefinitionMetadataStyles0CurveStyle = "haystack"
	Segments        RelationshipDefinitionMetadataStyles0CurveStyle = "segments"
	Straight        RelationshipDefinitionMetadataStyles0CurveStyle = "straight"
	Taxi            RelationshipDefinitionMetadataStyles0CurveStyle = "taxi"
	UnbundledBezier RelationshipDefinitionMetadataStyles0CurveStyle = "unbundled-bezier"
)

// Defines values for RelationshipDefinitionMetadataStyles0LineCap.
const (
	RelationshipDefinitionMetadataStyles0LineCapButt   RelationshipDefinitionMetadataStyles0LineCap = "butt"
	RelationshipDefinitionMetadataStyles0LineCapRound  RelationshipDefinitionMetadataStyles0LineCap = "round"
	RelationshipDefinitionMetadataStyles0LineCapSquare RelationshipDefinitionMetadataStyles0LineCap = "square"
)

// Defines values for RelationshipDefinitionMetadataStyles0LineStyle.
const (
	Dashed RelationshipDefinitionMetadataStyles0LineStyle = "dashed"
	Dotted RelationshipDefinitionMetadataStyles0LineStyle = "dotted"
	Solid  RelationshipDefinitionMetadataStyles0LineStyle = "solid"
)

// Defines values for RelationshipDefinitionMetadataStyles0MidTargetArrowFill.
const (
	RelationshipDefinitionMetadataStyles0MidTargetArrowFillFilled RelationshipDefinitionMetadataStyles0MidTargetArrowFill = "filled"
	RelationshipDefinitionMetadataStyles0MidTargetArrowFillHollow RelationshipDefinitionMetadataStyles0MidTargetArrowFill = "hollow"
)

// Defines values for RelationshipDefinitionMetadataStyles0MidTargetArrowShape.
const (
	RelationshipDefinitionMetadataStyles0MidTargetArrowShapeChevron           RelationshipDefinitionMetadataStyles0MidTargetArrowShape = "chevron"
	RelationshipDefinitionMetadataStyles0MidTargetArrowShapeCircle            RelationshipDefinitionMetadataStyles0MidTargetArrowShape = "circle"
	RelationshipDefinitionMetadataStyles0MidTargetArrowShapeCircleTriangle    RelationshipDefinitionMetadataStyles0MidTargetArrowShape = "circle-triangle"
	RelationshipDefinitionMetadataStyles0MidTargetArrowShapeDiamond           RelationshipDefinitionMetadataStyles0MidTargetArrowShape = "diamond"
	RelationshipDefinitionMetadataStyles0MidTargetArrowShapeNone              RelationshipDefinitionMetadataStyles0MidTargetArrowShape = "none"
	RelationshipDefinitionMetadataStyles0MidTargetArrowShapeSquare            RelationshipDefinitionMetadataStyles0MidTargetArrowShape = "square"
	RelationshipDefinitionMetadataStyles0MidTargetArrowShapeTee               RelationshipDefinitionMetadataStyles0MidTargetArrowShape = "tee"
	RelationshipDefinitionMetadataStyles0MidTargetArrowShapeTriangle          RelationshipDefinitionMetadataStyles0MidTargetArrowShape = "triangle"
	RelationshipDefinitionMetadataStyles0MidTargetArrowShapeTriangleBackcurve RelationshipDefinitionMetadataStyles0MidTargetArrowShape = "triangle-backcurve"
	RelationshipDefinitionMetadataStyles0MidTargetArrowShapeTriangleCross     RelationshipDefinitionMetadataStyles0MidTargetArrowShape = "triangle-cross"
	RelationshipDefinitionMetadataStyles0MidTargetArrowShapeTriangleTee       RelationshipDefinitionMetadataStyles0MidTargetArrowShape = "triangle-tee"
	RelationshipDefinitionMetadataStyles0MidTargetArrowShapeVee               RelationshipDefinitionMetadataStyles0MidTargetArrowShape = "vee"
)

// Defines values for RelationshipDefinitionMetadataStyles0TargetArrowFill.
const (
	RelationshipDefinitionMetadataStyles0TargetArrowFillFilled RelationshipDefinitionMetadataStyles0TargetArrowFill = "filled"
	RelationshipDefinitionMetadataStyles0TargetArrowFillHollow RelationshipDefinitionMetadataStyles0TargetArrowFill = "hollow"
)

// Defines values for RelationshipDefinitionMetadataStyles0TargetArrowShape.
const (
	RelationshipDefinitionMetadataStyles0TargetArrowShapeChevron           RelationshipDefinitionMetadataStyles0TargetArrowShape = "chevron"
	RelationshipDefinitionMetadataStyles0TargetArrowShapeCircle            RelationshipDefinitionMetadataStyles0TargetArrowShape = "circle"
	RelationshipDefinitionMetadataStyles0TargetArrowShapeCircleTriangle    RelationshipDefinitionMetadataStyles0TargetArrowShape = "circle-triangle"
	RelationshipDefinitionMetadataStyles0TargetArrowShapeDiamond           RelationshipDefinitionMetadataStyles0TargetArrowShape = "diamond"
	RelationshipDefinitionMetadataStyles0TargetArrowShapeNone              RelationshipDefinitionMetadataStyles0TargetArrowShape = "none"
	RelationshipDefinitionMetadataStyles0TargetArrowShapeSquare            RelationshipDefinitionMetadataStyles0TargetArrowShape = "square"
	RelationshipDefinitionMetadataStyles0TargetArrowShapeTee               RelationshipDefinitionMetadataStyles0TargetArrowShape = "tee"
	RelationshipDefinitionMetadataStyles0TargetArrowShapeTriangle          RelationshipDefinitionMetadataStyles0TargetArrowShape = "triangle"
	RelationshipDefinitionMetadataStyles0TargetArrowShapeTriangleBackcurve RelationshipDefinitionMetadataStyles0TargetArrowShape = "triangle-backcurve"
	RelationshipDefinitionMetadataStyles0TargetArrowShapeTriangleCross     RelationshipDefinitionMetadataStyles0TargetArrowShape = "triangle-cross"
	RelationshipDefinitionMetadataStyles0TargetArrowShapeTriangleTee       RelationshipDefinitionMetadataStyles0TargetArrowShape = "triangle-tee"
	RelationshipDefinitionMetadataStyles0TargetArrowShapeVee               RelationshipDefinitionMetadataStyles0TargetArrowShape = "vee"
)

// Defines values for RelationshipDefinitionMetadataStyles0TextTransform.
const (
	RelationshipDefinitionMetadataStyles0TextTransformLowercase RelationshipDefinitionMetadataStyles0TextTransform = "lowercase"
	RelationshipDefinitionMetadataStyles0TextTransformNone      RelationshipDefinitionMetadataStyles0TextTransform = "none"
	RelationshipDefinitionMetadataStyles0TextTransformUppercase RelationshipDefinitionMetadataStyles0TextTransform = "uppercase"
)

// Defines values for RelationshipDefinitionMetadataStyles1TextTransform.
const (
	Lowercase RelationshipDefinitionMetadataStyles1TextTransform = "lowercase"
	None      RelationshipDefinitionMetadataStyles1TextTransform = "none"
	Uppercase RelationshipDefinitionMetadataStyles1TextTransform = "uppercase"
)

// Defines values for RelationshipDefinitionModelStatus.
const (
	RelationshipDefinitionModelStatusDuplicate RelationshipDefinitionModelStatus = "duplicate"
	RelationshipDefinitionModelStatusEnabled   RelationshipDefinitionModelStatus = "enabled"
	RelationshipDefinitionModelStatusIgnored   RelationshipDefinitionModelStatus = "ignored"
)

// Defines values for RelationshipDefinitionModelMetadataShape.
const (
	RelationshipDefinitionModelMetadataShapeBarrel               RelationshipDefinitionModelMetadataShape = "barrel"
	RelationshipDefinitionModelMetadataShapeBottomRoundRectangle RelationshipDefinitionModelMetadataShape = "bottom-round-rectangle"
	RelationshipDefinitionModelMetadataShapeCircle               RelationshipDefinitionModelMetadataShape = "circle"
	RelationshipDefinitionModelMetadataShapeConcaveHexagon       RelationshipDefinitionModelMetadataShape = "concave-hexagon"
	RelationshipDefinitionModelMetadataShapeCutRectangle         RelationshipDefinitionModelMetadataShape = "cut-rectangle"
	RelationshipDefinitionModelMetadataShapeDiamond              RelationshipDefinitionModelMetadataShape = "diamond"
	RelationshipDefinitionModelMetadataShapeEllipse              RelationshipDefinitionModelMetadataShape = "ellipse"
	RelationshipDefinitionModelMetadataShapeHeptagon             RelationshipDefinitionModelMetadataShape = "heptagon"
	RelationshipDefinitionModelMetadataShapeHexagon              RelationshipDefinitionModelMetadataShape = "hexagon"
	RelationshipDefinitionModelMetadataShapeOctagon              RelationshipDefinitionModelMetadataShape = "octagon"
	RelationshipDefinitionModelMetadataShapePentagon             RelationshipDefinitionModelMetadataShape = "pentagon"
	RelationshipDefinitionModelMetadataShapePolygon              RelationshipDefinitionModelMetadataShape = "polygon"
	RelationshipDefinitionModelMetadataShapeRectangle            RelationshipDefinitionModelMetadataShape = "rectangle"
	RelationshipDefinitionModelMetadataShapeRhomboid             RelationshipDefinitionModelMetadataShape = "rhomboid"
	RelationshipDefinitionModelMetadataShapeRoundDiamond         RelationshipDefinitionModelMetadataShape = "round-diamond"
	RelationshipDefinitionModelMetadataShapeRoundHeptagon        RelationshipDefinitionModelMetadataShape = "round-heptagon"
	RelationshipDefinitionModelMetadataShapeRoundHexagon         RelationshipDefinitionModelMetadataShape = "round-hexagon"
	RelationshipDefinitionModelMetadataShapeRoundOctagon         RelationshipDefinitionModelMetadataShape = "round-octagon"
	RelationshipDefinitionModelMetadataShapeRoundPentagon        RelationshipDefinitionModelMetadataShape = "round-pentagon"
	RelationshipDefinitionModelMetadataShapeRoundRectangle       RelationshipDefinitionModelMetadataShape = "round-rectangle"
	RelationshipDefinitionModelMetadataShapeRoundTag             RelationshipDefinitionModelMetadataShape = "round-tag"
	RelationshipDefinitionModelMetadataShapeRoundTriangle        RelationshipDefinitionModelMetadataShape = "round-triangle"
	RelationshipDefinitionModelMetadataShapeStar                 RelationshipDefinitionModelMetadataShape = "star"
	RelationshipDefinitionModelMetadataShapeTag                  RelationshipDefinitionModelMetadataShape = "tag"
	RelationshipDefinitionModelMetadataShapeTriangle             RelationshipDefinitionModelMetadataShape = "triangle"
	RelationshipDefinitionModelMetadataShapeVee                  RelationshipDefinitionModelMetadataShape = "vee"
)

// Defines values for RelationshipDefinitionSelectorsAllowFromModelStatus.
const (
	RelationshipDefinitionSelectorsAllowFromModelStatusDuplicate RelationshipDefinitionSelectorsAllowFromModelStatus = "duplicate"
	RelationshipDefinitionSelectorsAllowFromModelStatusEnabled   RelationshipDefinitionSelectorsAllowFromModelStatus = "enabled"
	RelationshipDefinitionSelectorsAllowFromModelStatusIgnored   RelationshipDefinitionSelectorsAllowFromModelStatus = "ignored"
)

// Defines values for RelationshipDefinitionSelectorsAllowFromModelMetadataShape.
const (
	RelationshipDefinitionSelectorsAllowFromModelMetadataShapeBarrel               RelationshipDefinitionSelectorsAllowFromModelMetadataShape = "barrel"
	RelationshipDefinitionSelectorsAllowFromModelMetadataShapeBottomRoundRectangle RelationshipDefinitionSelectorsAllowFromModelMetadataShape = "bottom-round-rectangle"
	RelationshipDefinitionSelectorsAllowFromModelMetadataShapeCircle               RelationshipDefinitionSelectorsAllowFromModelMetadataShape = "circle"
	RelationshipDefinitionSelectorsAllowFromModelMetadataShapeConcaveHexagon       RelationshipDefinitionSelectorsAllowFromModelMetadataShape = "concave-hexagon"
	RelationshipDefinitionSelectorsAllowFromModelMetadataShapeCutRectangle         RelationshipDefinitionSelectorsAllowFromModelMetadataShape = "cut-rectangle"
	RelationshipDefinitionSelectorsAllowFromModelMetadataShapeDiamond              RelationshipDefinitionSelectorsAllowFromModelMetadataShape = "diamond"
	RelationshipDefinitionSelectorsAllowFromModelMetadataShapeEllipse              RelationshipDefinitionSelectorsAllowFromModelMetadataShape = "ellipse"
	RelationshipDefinitionSelectorsAllowFromModelMetadataShapeHeptagon             RelationshipDefinitionSelectorsAllowFromModelMetadataShape = "heptagon"
	RelationshipDefinitionSelectorsAllowFromModelMetadataShapeHexagon              RelationshipDefinitionSelectorsAllowFromModelMetadataShape = "hexagon"
	RelationshipDefinitionSelectorsAllowFromModelMetadataShapeOctagon              RelationshipDefinitionSelectorsAllowFromModelMetadataShape = "octagon"
	RelationshipDefinitionSelectorsAllowFromModelMetadataShapePentagon             RelationshipDefinitionSelectorsAllowFromModelMetadataShape = "pentagon"
	RelationshipDefinitionSelectorsAllowFromModelMetadataShapePolygon              RelationshipDefinitionSelectorsAllowFromModelMetadataShape = "polygon"
	RelationshipDefinitionSelectorsAllowFromModelMetadataShapeRectangle            RelationshipDefinitionSelectorsAllowFromModelMetadataShape = "rectangle"
	RelationshipDefinitionSelectorsAllowFromModelMetadataShapeRhomboid             RelationshipDefinitionSelectorsAllowFromModelMetadataShape = "rhomboid"
	RelationshipDefinitionSelectorsAllowFromModelMetadataShapeRoundDiamond         RelationshipDefinitionSelectorsAllowFromModelMetadataShape = "round-diamond"
	RelationshipDefinitionSelectorsAllowFromModelMetadataShapeRoundHeptagon        RelationshipDefinitionSelectorsAllowFromModelMetadataShape = "round-heptagon"
	RelationshipDefinitionSelectorsAllowFromModelMetadataShapeRoundHexagon         RelationshipDefinitionSelectorsAllowFromModelMetadataShape = "round-hexagon"
	RelationshipDefinitionSelectorsAllowFromModelMetadataShapeRoundOctagon         RelationshipDefinitionSelectorsAllowFromModelMetadataShape = "round-octagon"
	RelationshipDefinitionSelectorsAllowFromModelMetadataShapeRoundPentagon        RelationshipDefinitionSelectorsAllowFromModelMetadataShape = "round-pentagon"
	RelationshipDefinitionSelectorsAllowFromModelMetadataShapeRoundRectangle       RelationshipDefinitionSelectorsAllowFromModelMetadataShape = "round-rectangle"
	RelationshipDefinitionSelectorsAllowFromModelMetadataShapeRoundTag             RelationshipDefinitionSelectorsAllowFromModelMetadataShape = "round-tag"
	RelationshipDefinitionSelectorsAllowFromModelMetadataShapeRoundTriangle        RelationshipDefinitionSelectorsAllowFromModelMetadataShape = "round-triangle"
	RelationshipDefinitionSelectorsAllowFromModelMetadataShapeStar                 RelationshipDefinitionSelectorsAllowFromModelMetadataShape = "star"
	RelationshipDefinitionSelectorsAllowFromModelMetadataShapeTag                  RelationshipDefinitionSelectorsAllowFromModelMetadataShape = "tag"
	RelationshipDefinitionSelectorsAllowFromModelMetadataShapeTriangle             RelationshipDefinitionSelectorsAllowFromModelMetadataShape = "triangle"
	RelationshipDefinitionSelectorsAllowFromModelMetadataShapeVee                  RelationshipDefinitionSelectorsAllowFromModelMetadataShape = "vee"
)

// Defines values for RelationshipDefinitionSelectorsAllowFromPatchPatchStrategy.
const (
	RelationshipDefinitionSelectorsAllowFromPatchPatchStrategyAdd       RelationshipDefinitionSelectorsAllowFromPatchPatchStrategy = "add"
	RelationshipDefinitionSelectorsAllowFromPatchPatchStrategyCopy      RelationshipDefinitionSelectorsAllowFromPatchPatchStrategy = "copy"
	RelationshipDefinitionSelectorsAllowFromPatchPatchStrategyMerge     RelationshipDefinitionSelectorsAllowFromPatchPatchStrategy = "merge"
	RelationshipDefinitionSelectorsAllowFromPatchPatchStrategyMove      RelationshipDefinitionSelectorsAllowFromPatchPatchStrategy = "move"
	RelationshipDefinitionSelectorsAllowFromPatchPatchStrategyRemove    RelationshipDefinitionSelectorsAllowFromPatchPatchStrategy = "remove"
	RelationshipDefinitionSelectorsAllowFromPatchPatchStrategyStrategic RelationshipDefinitionSelectorsAllowFromPatchPatchStrategy = "strategic"
	RelationshipDefinitionSelectorsAllowFromPatchPatchStrategyTest      RelationshipDefinitionSelectorsAllowFromPatchPatchStrategy = "test"
)

// Defines values for RelationshipDefinitionSelectorsAllowToModelStatus.
const (
	RelationshipDefinitionSelectorsAllowToModelStatusDuplicate RelationshipDefinitionSelectorsAllowToModelStatus = "duplicate"
	RelationshipDefinitionSelectorsAllowToModelStatusEnabled   RelationshipDefinitionSelectorsAllowToModelStatus = "enabled"
	RelationshipDefinitionSelectorsAllowToModelStatusIgnored   RelationshipDefinitionSelectorsAllowToModelStatus = "ignored"
)

// Defines values for RelationshipDefinitionSelectorsAllowToModelMetadataShape.
const (
	RelationshipDefinitionSelectorsAllowToModelMetadataShapeBarrel               RelationshipDefinitionSelectorsAllowToModelMetadataShape = "barrel"
	RelationshipDefinitionSelectorsAllowToModelMetadataShapeBottomRoundRectangle RelationshipDefinitionSelectorsAllowToModelMetadataShape = "bottom-round-rectangle"
	RelationshipDefinitionSelectorsAllowToModelMetadataShapeCircle               RelationshipDefinitionSelectorsAllowToModelMetadataShape = "circle"
	RelationshipDefinitionSelectorsAllowToModelMetadataShapeConcaveHexagon       RelationshipDefinitionSelectorsAllowToModelMetadataShape = "concave-hexagon"
	RelationshipDefinitionSelectorsAllowToModelMetadataShapeCutRectangle         RelationshipDefinitionSelectorsAllowToModelMetadataShape = "cut-rectangle"
	RelationshipDefinitionSelectorsAllowToModelMetadataShapeDiamond              RelationshipDefinitionSelectorsAllowToModelMetadataShape = "diamond"
	RelationshipDefinitionSelectorsAllowToModelMetadataShapeEllipse              RelationshipDefinitionSelectorsAllowToModelMetadataShape = "ellipse"
	RelationshipDefinitionSelectorsAllowToModelMetadataShapeHeptagon             RelationshipDefinitionSelectorsAllowToModelMetadataShape = "heptagon"
	RelationshipDefinitionSelectorsAllowToModelMetadataShapeHexagon              RelationshipDefinitionSelectorsAllowToModelMetadataShape = "hexagon"
	RelationshipDefinitionSelectorsAllowToModelMetadataShapeOctagon              RelationshipDefinitionSelectorsAllowToModelMetadataShape = "octagon"
	RelationshipDefinitionSelectorsAllowToModelMetadataShapePentagon             RelationshipDefinitionSelectorsAllowToModelMetadataShape = "pentagon"
	RelationshipDefinitionSelectorsAllowToModelMetadataShapePolygon              RelationshipDefinitionSelectorsAllowToModelMetadataShape = "polygon"
	RelationshipDefinitionSelectorsAllowToModelMetadataShapeRectangle            RelationshipDefinitionSelectorsAllowToModelMetadataShape = "rectangle"
	RelationshipDefinitionSelectorsAllowToModelMetadataShapeRhomboid             RelationshipDefinitionSelectorsAllowToModelMetadataShape = "rhomboid"
	RelationshipDefinitionSelectorsAllowToModelMetadataShapeRoundDiamond         RelationshipDefinitionSelectorsAllowToModelMetadataShape = "round-diamond"
	RelationshipDefinitionSelectorsAllowToModelMetadataShapeRoundHeptagon        RelationshipDefinitionSelectorsAllowToModelMetadataShape = "round-heptagon"
	RelationshipDefinitionSelectorsAllowToModelMetadataShapeRoundHexagon         RelationshipDefinitionSelectorsAllowToModelMetadataShape = "round-hexagon"
	RelationshipDefinitionSelectorsAllowToModelMetadataShapeRoundOctagon         RelationshipDefinitionSelectorsAllowToModelMetadataShape = "round-octagon"
	RelationshipDefinitionSelectorsAllowToModelMetadataShapeRoundPentagon        RelationshipDefinitionSelectorsAllowToModelMetadataShape = "round-pentagon"
	RelationshipDefinitionSelectorsAllowToModelMetadataShapeRoundRectangle       RelationshipDefinitionSelectorsAllowToModelMetadataShape = "round-rectangle"
	RelationshipDefinitionSelectorsAllowToModelMetadataShapeRoundTag             RelationshipDefinitionSelectorsAllowToModelMetadataShape = "round-tag"
	RelationshipDefinitionSelectorsAllowToModelMetadataShapeRoundTriangle        RelationshipDefinitionSelectorsAllowToModelMetadataShape = "round-triangle"
	RelationshipDefinitionSelectorsAllowToModelMetadataShapeStar                 RelationshipDefinitionSelectorsAllowToModelMetadataShape = "star"
	RelationshipDefinitionSelectorsAllowToModelMetadataShapeTag                  RelationshipDefinitionSelectorsAllowToModelMetadataShape = "tag"
	RelationshipDefinitionSelectorsAllowToModelMetadataShapeTriangle             RelationshipDefinitionSelectorsAllowToModelMetadataShape = "triangle"
	RelationshipDefinitionSelectorsAllowToModelMetadataShapeVee                  RelationshipDefinitionSelectorsAllowToModelMetadataShape = "vee"
)

// Defines values for RelationshipDefinitionSelectorsAllowToPatchPatchStrategy.
const (
	RelationshipDefinitionSelectorsAllowToPatchPatchStrategyAdd       RelationshipDefinitionSelectorsAllowToPatchPatchStrategy = "add"
	RelationshipDefinitionSelectorsAllowToPatchPatchStrategyCopy      RelationshipDefinitionSelectorsAllowToPatchPatchStrategy = "copy"
	RelationshipDefinitionSelectorsAllowToPatchPatchStrategyMerge     RelationshipDefinitionSelectorsAllowToPatchPatchStrategy = "merge"
	RelationshipDefinitionSelectorsAllowToPatchPatchStrategyMove      RelationshipDefinitionSelectorsAllowToPatchPatchStrategy = "move"
	RelationshipDefinitionSelectorsAllowToPatchPatchStrategyRemove    RelationshipDefinitionSelectorsAllowToPatchPatchStrategy = "remove"
	RelationshipDefinitionSelectorsAllowToPatchPatchStrategyStrategic RelationshipDefinitionSelectorsAllowToPatchPatchStrategy = "strategic"
	RelationshipDefinitionSelectorsAllowToPatchPatchStrategyTest      RelationshipDefinitionSelectorsAllowToPatchPatchStrategy = "test"
)

// Defines values for RelationshipDefinitionSelectorsDenyFromModelStatus.
const (
	RelationshipDefinitionSelectorsDenyFromModelStatusDuplicate RelationshipDefinitionSelectorsDenyFromModelStatus = "duplicate"
	RelationshipDefinitionSelectorsDenyFromModelStatusEnabled   RelationshipDefinitionSelectorsDenyFromModelStatus = "enabled"
	RelationshipDefinitionSelectorsDenyFromModelStatusIgnored   RelationshipDefinitionSelectorsDenyFromModelStatus = "ignored"
)

// Defines values for RelationshipDefinitionSelectorsDenyFromModelMetadataShape.
const (
	RelationshipDefinitionSelectorsDenyFromModelMetadataShapeBarrel               RelationshipDefinitionSelectorsDenyFromModelMetadataShape = "barrel"
	RelationshipDefinitionSelectorsDenyFromModelMetadataShapeBottomRoundRectangle RelationshipDefinitionSelectorsDenyFromModelMetadataShape = "bottom-round-rectangle"
	RelationshipDefinitionSelectorsDenyFromModelMetadataShapeCircle               RelationshipDefinitionSelectorsDenyFromModelMetadataShape = "circle"
	RelationshipDefinitionSelectorsDenyFromModelMetadataShapeConcaveHexagon       RelationshipDefinitionSelectorsDenyFromModelMetadataShape = "concave-hexagon"
	RelationshipDefinitionSelectorsDenyFromModelMetadataShapeCutRectangle         RelationshipDefinitionSelectorsDenyFromModelMetadataShape = "cut-rectangle"
	RelationshipDefinitionSelectorsDenyFromModelMetadataShapeDiamond              RelationshipDefinitionSelectorsDenyFromModelMetadataShape = "diamond"
	RelationshipDefinitionSelectorsDenyFromModelMetadataShapeEllipse              RelationshipDefinitionSelectorsDenyFromModelMetadataShape = "ellipse"
	RelationshipDefinitionSelectorsDenyFromModelMetadataShapeHeptagon             RelationshipDefinitionSelectorsDenyFromModelMetadataShape = "heptagon"
	RelationshipDefinitionSelectorsDenyFromModelMetadataShapeHexagon              RelationshipDefinitionSelectorsDenyFromModelMetadataShape = "hexagon"
	RelationshipDefinitionSelectorsDenyFromModelMetadataShapeOctagon              RelationshipDefinitionSelectorsDenyFromModelMetadataShape = "octagon"
	RelationshipDefinitionSelectorsDenyFromModelMetadataShapePentagon             RelationshipDefinitionSelectorsDenyFromModelMetadataShape = "pentagon"
	RelationshipDefinitionSelectorsDenyFromModelMetadataShapePolygon              RelationshipDefinitionSelectorsDenyFromModelMetadataShape = "polygon"
	RelationshipDefinitionSelectorsDenyFromModelMetadataShapeRectangle            RelationshipDefinitionSelectorsDenyFromModelMetadataShape = "rectangle"
	RelationshipDefinitionSelectorsDenyFromModelMetadataShapeRhomboid             RelationshipDefinitionSelectorsDenyFromModelMetadataShape = "rhomboid"
	RelationshipDefinitionSelectorsDenyFromModelMetadataShapeRoundDiamond         RelationshipDefinitionSelectorsDenyFromModelMetadataShape = "round-diamond"
	RelationshipDefinitionSelectorsDenyFromModelMetadataShapeRoundHeptagon        RelationshipDefinitionSelectorsDenyFromModelMetadataShape = "round-heptagon"
	RelationshipDefinitionSelectorsDenyFromModelMetadataShapeRoundHexagon         RelationshipDefinitionSelectorsDenyFromModelMetadataShape = "round-hexagon"
	RelationshipDefinitionSelectorsDenyFromModelMetadataShapeRoundOctagon         RelationshipDefinitionSelectorsDenyFromModelMetadataShape = "round-octagon"
	RelationshipDefinitionSelectorsDenyFromModelMetadataShapeRoundPentagon        RelationshipDefinitionSelectorsDenyFromModelMetadataShape = "round-pentagon"
	RelationshipDefinitionSelectorsDenyFromModelMetadataShapeRoundRectangle       RelationshipDefinitionSelectorsDenyFromModelMetadataShape = "round-rectangle"
	RelationshipDefinitionSelectorsDenyFromModelMetadataShapeRoundTag             RelationshipDefinitionSelectorsDenyFromModelMetadataShape = "round-tag"
	RelationshipDefinitionSelectorsDenyFromModelMetadataShapeRoundTriangle        RelationshipDefinitionSelectorsDenyFromModelMetadataShape = "round-triangle"
	RelationshipDefinitionSelectorsDenyFromModelMetadataShapeStar                 RelationshipDefinitionSelectorsDenyFromModelMetadataShape = "star"
	RelationshipDefinitionSelectorsDenyFromModelMetadataShapeTag                  RelationshipDefinitionSelectorsDenyFromModelMetadataShape = "tag"
	RelationshipDefinitionSelectorsDenyFromModelMetadataShapeTriangle             RelationshipDefinitionSelectorsDenyFromModelMetadataShape = "triangle"
	RelationshipDefinitionSelectorsDenyFromModelMetadataShapeVee                  RelationshipDefinitionSelectorsDenyFromModelMetadataShape = "vee"
)

// Defines values for RelationshipDefinitionSelectorsDenyFromPatchPatchStrategy.
const (
	RelationshipDefinitionSelectorsDenyFromPatchPatchStrategyAdd       RelationshipDefinitionSelectorsDenyFromPatchPatchStrategy = "add"
	RelationshipDefinitionSelectorsDenyFromPatchPatchStrategyCopy      RelationshipDefinitionSelectorsDenyFromPatchPatchStrategy = "copy"
	RelationshipDefinitionSelectorsDenyFromPatchPatchStrategyMerge     RelationshipDefinitionSelectorsDenyFromPatchPatchStrategy = "merge"
	RelationshipDefinitionSelectorsDenyFromPatchPatchStrategyMove      RelationshipDefinitionSelectorsDenyFromPatchPatchStrategy = "move"
	RelationshipDefinitionSelectorsDenyFromPatchPatchStrategyRemove    RelationshipDefinitionSelectorsDenyFromPatchPatchStrategy = "remove"
	RelationshipDefinitionSelectorsDenyFromPatchPatchStrategyStrategic RelationshipDefinitionSelectorsDenyFromPatchPatchStrategy = "strategic"
	RelationshipDefinitionSelectorsDenyFromPatchPatchStrategyTest      RelationshipDefinitionSelectorsDenyFromPatchPatchStrategy = "test"
)

// Defines values for RelationshipDefinitionSelectorsDenyToModelStatus.
const (
	RelationshipDefinitionSelectorsDenyToModelStatusDuplicate RelationshipDefinitionSelectorsDenyToModelStatus = "duplicate"
	RelationshipDefinitionSelectorsDenyToModelStatusEnabled   RelationshipDefinitionSelectorsDenyToModelStatus = "enabled"
	RelationshipDefinitionSelectorsDenyToModelStatusIgnored   RelationshipDefinitionSelectorsDenyToModelStatus = "ignored"
)

// Defines values for RelationshipDefinitionSelectorsDenyToModelMetadataShape.
const (
	Barrel               RelationshipDefinitionSelectorsDenyToModelMetadataShape = "barrel"
	BottomRoundRectangle RelationshipDefinitionSelectorsDenyToModelMetadataShape = "bottom-round-rectangle"
	Circle               RelationshipDefinitionSelectorsDenyToModelMetadataShape = "circle"
	ConcaveHexagon       RelationshipDefinitionSelectorsDenyToModelMetadataShape = "concave-hexagon"
	CutRectangle         RelationshipDefinitionSelectorsDenyToModelMetadataShape = "cut-rectangle"
	Diamond              RelationshipDefinitionSelectorsDenyToModelMetadataShape = "diamond"
	Ellipse              RelationshipDefinitionSelectorsDenyToModelMetadataShape = "ellipse"
	Heptagon             RelationshipDefinitionSelectorsDenyToModelMetadataShape = "heptagon"
	Hexagon              RelationshipDefinitionSelectorsDenyToModelMetadataShape = "hexagon"
	Octagon              RelationshipDefinitionSelectorsDenyToModelMetadataShape = "octagon"
	Pentagon             RelationshipDefinitionSelectorsDenyToModelMetadataShape = "pentagon"
	Polygon              RelationshipDefinitionSelectorsDenyToModelMetadataShape = "polygon"
	Rectangle            RelationshipDefinitionSelectorsDenyToModelMetadataShape = "rectangle"
	Rhomboid             RelationshipDefinitionSelectorsDenyToModelMetadataShape = "rhomboid"
	RoundDiamond         RelationshipDefinitionSelectorsDenyToModelMetadataShape = "round-diamond"
	RoundHeptagon        RelationshipDefinitionSelectorsDenyToModelMetadataShape = "round-heptagon"
	RoundHexagon         RelationshipDefinitionSelectorsDenyToModelMetadataShape = "round-hexagon"
	RoundOctagon         RelationshipDefinitionSelectorsDenyToModelMetadataShape = "round-octagon"
	RoundPentagon        RelationshipDefinitionSelectorsDenyToModelMetadataShape = "round-pentagon"
	RoundRectangle       RelationshipDefinitionSelectorsDenyToModelMetadataShape = "round-rectangle"
	RoundTag             RelationshipDefinitionSelectorsDenyToModelMetadataShape = "round-tag"
	RoundTriangle        RelationshipDefinitionSelectorsDenyToModelMetadataShape = "round-triangle"
	Star                 RelationshipDefinitionSelectorsDenyToModelMetadataShape = "star"
	Tag                  RelationshipDefinitionSelectorsDenyToModelMetadataShape = "tag"
	Triangle             RelationshipDefinitionSelectorsDenyToModelMetadataShape = "triangle"
	Vee                  RelationshipDefinitionSelectorsDenyToModelMetadataShape = "vee"
)

// Defines values for RelationshipDefinitionSelectorsDenyToPatchPatchStrategy.
const (
	RelationshipDefinitionSelectorsDenyToPatchPatchStrategyAdd       RelationshipDefinitionSelectorsDenyToPatchPatchStrategy = "add"
	RelationshipDefinitionSelectorsDenyToPatchPatchStrategyCopy      RelationshipDefinitionSelectorsDenyToPatchPatchStrategy = "copy"
	RelationshipDefinitionSelectorsDenyToPatchPatchStrategyMerge     RelationshipDefinitionSelectorsDenyToPatchPatchStrategy = "merge"
	RelationshipDefinitionSelectorsDenyToPatchPatchStrategyMove      RelationshipDefinitionSelectorsDenyToPatchPatchStrategy = "move"
	RelationshipDefinitionSelectorsDenyToPatchPatchStrategyRemove    RelationshipDefinitionSelectorsDenyToPatchPatchStrategy = "remove"
	RelationshipDefinitionSelectorsDenyToPatchPatchStrategyStrategic RelationshipDefinitionSelectorsDenyToPatchPatchStrategy = "strategic"
	RelationshipDefinitionSelectorsDenyToPatchPatchStrategyTest      RelationshipDefinitionSelectorsDenyToPatchPatchStrategy = "test"
)

// Defines values for RelationshipDefinitionStatus.
const (
	Approved RelationshipDefinitionStatus = "approved"
	Deleted  RelationshipDefinitionStatus = "deleted"
	Enabled  RelationshipDefinitionStatus = "enabled"
	Ignored  RelationshipDefinitionStatus = "ignored"
	Pending  RelationshipDefinitionStatus = "pending"
)

// RelationshipDefinition Relationships define the nature of interaction between interconnected components in Meshery. The combination of relationship properties kind, type, and subtype characterize various genealogical relations among and between components. Relationships have selectors, selector sets, metadata, and optional parameters. Learn more at https://docs.meshery.io/concepts/logical/relationships.
type RelationshipDefinition struct {
	// Capabilities Capabilities associated with the relationship.
	Capabilities *[]struct {
		// Description A written representation of the purpose and characteristics of the capability.
		Description string `json:"description" yaml:"description"`

		// DisplayName Name of the capability in human-readible format.
		DisplayName string `json:"displayName" yaml:"displayName"`

		// EntityState State of the entity in which the capability is applicable.
		EntityState []RelationshipDefinitionCapabilitiesEntityState `json:"entityState" yaml:"entityState"`

		// Key Key that backs the capability.
		Key string `json:"key" yaml:"key"`

		// Kind Top-level categorization of the capability
		Kind string `json:"kind" yaml:"kind"`

		// Metadata Metadata contains additional information associated with the capability. Extension point.
		Metadata *map[string]interface{} `json:"metadata,omitempty" yaml:"metadata,omitempty"`

		// SchemaVersion Specifies the version of the schema to which the capability definition conforms.
		SchemaVersion string `json:"schemaVersion" yaml:"schemaVersion"`

		// Status Status of the capability
		Status RelationshipDefinitionCapabilitiesStatus `json:"status" yaml:"status"`

		// SubType Most granular unit of capability classification. The combination of Kind, Type and SubType together uniquely identify a Capability.
		SubType string `json:"subType" yaml:"subType"`

		// Type Classification of capabilities. Used to group capabilities similar in nature.
		Type string `json:"type" yaml:"type"`

		// Version Version of the capability definition.
		Version string `json:"version" yaml:"version"`
	} `gorm:"type:bytes;serializer:json" json:"capabilities,omitempty" yaml:"capabilities,omitempty"`

	// EvaluationQuery Optional. Assigns the policy to be used for the evaluation of the relationship. Deprecation Notice: In the future, this property is either to be removed or to it is to be an array of optional policy $refs.
	EvaluationQuery *string `json:"evaluationQuery" yaml:"evaluationQuery"`

	// Id Uniquely identifies the entity (i.e. component) as defined in a declaration (i.e. design).
	Id *uuid.UUID `json:"id" yaml:"id"`

	// Kind Kind of the Relationship. Learn more about relationships - https://docs.meshery.io/concepts/logical/relationships.
	Kind RelationshipDefinitionKind `json:"kind" yaml:"kind"`

	// Metadata Metadata contains additional information associated with the Relationship.
	Metadata *RelationshipDefinition_Metadata `gorm:"foreignKey:ModelId;references:Id" json:"metadata,omitempty" yaml:"metadata,omitempty"`

	// Model Meshery Models serve as a portable unit of packaging to define managed entities, their relationships, and capabilities.
	Model struct {
		// Id Uniquely identifies the entity (i.e. component) as defined in a declaration (i.e. design).
		Id uuid.UUID `json:"id" yaml:"id"`

		// SchemaVersion Specifies the version of the schema used for the definition.
		SchemaVersion string `json:"schemaVersion" yaml:"schemaVersion"`

		// Version Version of the model definition.
		Version string `json:"version" yaml:"version"`

		// Name The unique name for the model within the scope of a registrant.
		Name string `json:"name" yaml:"name"`

		// DisplayName Human-readable name for the model.
		DisplayName string `json:"displayName" yaml:"displayName"`

		// Description Description of the model.
		Description string `json:"description,omitempty" yaml:"description,omitempty"`

		// Status Status of model, including:
		// - duplicate: this component is a duplicate of another. The component that is to be the canonical reference and that is duplicated by other components should not be assigned the 'duplicate' status.
		// - maintenance: model is unavailable for a period of time.
		// - enabled: model is available for use for all users of this Meshery Server.
		// - ignored: model is unavailable for use for all users of this Meshery Server.
		Status RelationshipDefinitionModelStatus `json:"status" yaml:"status"`

		// CategoryId ID of the category.
		CategoryId uuid.UUID `gorm:"categoryID" json:"-" yaml:"-"`

		// Registrant Meshery Connections are managed and unmanaged resources that either through discovery or manual entry are tracked by Meshery. Learn more at https://docs.meshery.io/concepts/logical/connections
		Registrant connection.Connection `gorm:"foreignKey:RegistrantId;references:Id" json:"registrant" yaml:"registrant"`

		// RegistrantId ID of the registrant.
		RegistrantId uuid.UUID `gorm:"column:connection_id" json:"connection_id" yaml:"connection_id"`

		// Category Category of the model.
		Category category.CategoryDefinition `gorm:"foreignKey:CategoryId;references:Id" json:"category" yaml:"category"`

		// SubCategory Sub category of the model determines the secondary grouping.
		SubCategory subcategory.SubCategoryDefinition `json:"subCategory" yaml:"subCategory"`

		// Metadata Metadata containing additional information associated with the model.
		Metadata *RelationshipDefinition_Model_Metadata `gorm:"type:bytes;serializer:json" json:"metadata" yaml:"metadata"`

		// Model Registrant-defined data associated with the model. Properties pertain to the software being managed (e.g. Kubernetes v1.31).
		Model struct {
			// Version Version of the model as defined by the registrant.
			Version string `json:"version" yaml:"version"`
		} `gorm:"type:bytes;serializer:json" json:"model" yaml:"model"`

		// ComponentsCount Number of components associated with the model.
		ComponentsCount int `gorm:"-" json:"components_count" yaml:"components_count"`

		// RelationshipsCount Number of relationships associated with the model.
		RelationshipsCount int         `gorm:"-" json:"relationships_count" yaml:"relationships_count"`
		Components         interface{} `gorm:"-" json:"components" yaml:"components"`
		Relationships      interface{} `gorm:"-" json:"relationships" yaml:"relationships"`
	} `json:"model" yaml:"model"`

	// SchemaVersion Specifies the version of the schema used for the relationship definition.
	SchemaVersion string `json:"schemaVersion" yaml:"schemaVersion"`

	// Selectors Selectors are organized as an array, with each item containing a distinct set of selectors that share a common functionality. This structure allows for flexibility in defining relationships, even when different components are involved.
	Selectors *[]struct {
		// Allow Selectors used to define relationships which are allowed.
		Allow struct {
			// From Describes the component(s) which are involved in the relationship along with a set of actions to perform upon selection match.
			From []struct {
				// Id A Universally Unique Identifier used to uniquely identify entites in Meshery. The UUID core defintion is used across different schemas.
				Id    *uuid.UUID                                         `json:"id,omitempty" yaml:"id,omitempty"`
				Kind  *string                                            `json:"kind,omitempty" yaml:"kind,omitempty"`
				Match *RelationshipDefinition_Selectors_Allow_From_Match `json:"match,omitempty" yaml:"match,omitempty"`

				// Model Meshery Models serve as a portable unit of packaging to define managed entities, their relationships, and capabilities.
				Model *struct {
					// Id Uniquely identifies the entity (i.e. component) as defined in a declaration (i.e. design).
					Id uuid.UUID `json:"id" yaml:"id"`

					// SchemaVersion Specifies the version of the schema used for the definition.
					SchemaVersion string `json:"schemaVersion" yaml:"schemaVersion"`

					// Version Version of the model definition.
					Version string `json:"version" yaml:"version"`

					// Name The unique name for the model within the scope of a registrant.
					Name string `json:"name" yaml:"name"`

					// DisplayName Human-readable name for the model.
					DisplayName string `json:"displayName" yaml:"displayName"`

					// Description Description of the model.
					Description string `json:"description,omitempty" yaml:"description,omitempty"`

					// Status Status of model, including:
					// - duplicate: this component is a duplicate of another. The component that is to be the canonical reference and that is duplicated by other components should not be assigned the 'duplicate' status.
					// - maintenance: model is unavailable for a period of time.
					// - enabled: model is available for use for all users of this Meshery Server.
					// - ignored: model is unavailable for use for all users of this Meshery Server.
					Status RelationshipDefinitionSelectorsAllowFromModelStatus `json:"status" yaml:"status"`

					// CategoryId ID of the category.
					CategoryId uuid.UUID `gorm:"categoryID" json:"-" yaml:"-"`

					// Registrant Meshery Connections are managed and unmanaged resources that either through discovery or manual entry are tracked by Meshery. Learn more at https://docs.meshery.io/concepts/logical/connections
					Registrant connection.Connection `gorm:"foreignKey:RegistrantId;references:Id" json:"registrant" yaml:"registrant"`

					// RegistrantId ID of the registrant.
					RegistrantId uuid.UUID `gorm:"column:connection_id" json:"connection_id" yaml:"connection_id"`

					// Category Category of the model.
					Category category.CategoryDefinition `gorm:"foreignKey:CategoryId;references:Id" json:"category" yaml:"category"`

					// SubCategory Sub category of the model determines the secondary grouping.
					SubCategory subcategory.SubCategoryDefinition `json:"subCategory" yaml:"subCategory"`

					// Metadata Metadata containing additional information associated with the model.
					Metadata *RelationshipDefinition_Selectors_Allow_From_Model_Metadata `gorm:"type:bytes;serializer:json" json:"metadata" yaml:"metadata"`

					// Model Registrant-defined data associated with the model. Properties pertain to the software being managed (e.g. Kubernetes v1.31).
					Model struct {
						// Version Version of the model as defined by the registrant.
						Version string `json:"version" yaml:"version"`
					} `gorm:"type:bytes;serializer:json" json:"model" yaml:"model"`

					// ComponentsCount Number of components associated with the model.
					ComponentsCount int `gorm:"-" json:"components_count" yaml:"components_count"`

					// RelationshipsCount Number of relationships associated with the model.
					RelationshipsCount int         `gorm:"-" json:"relationships_count" yaml:"relationships_count"`
					Components         interface{} `gorm:"-" json:"components" yaml:"components"`
					Relationships      interface{} `gorm:"-" json:"relationships" yaml:"relationships"`
				} `json:"model,omitempty" yaml:"model,omitempty"`
				Patch *RelationshipDefinition_Selectors_Allow_From_Patch `json:"patch,omitempty" yaml:"patch,omitempty"`
			} `json:"from" yaml:"from"`

			// To Describes the component(s) which are involved in the relationship along with a set of actions to perform upon selection match.
			To []struct {
				// Id A Universally Unique Identifier used to uniquely identify entites in Meshery. The UUID core defintion is used across different schemas.
				Id    *uuid.UUID                                       `json:"id,omitempty" yaml:"id,omitempty"`
				Kind  *string                                          `json:"kind,omitempty" yaml:"kind,omitempty"`
				Match *RelationshipDefinition_Selectors_Allow_To_Match `json:"match,omitempty" yaml:"match,omitempty"`

				// Model Meshery Models serve as a portable unit of packaging to define managed entities, their relationships, and capabilities.
				Model *struct {
					// Id Uniquely identifies the entity (i.e. component) as defined in a declaration (i.e. design).
					Id uuid.UUID `json:"id" yaml:"id"`

					// SchemaVersion Specifies the version of the schema used for the definition.
					SchemaVersion string `json:"schemaVersion" yaml:"schemaVersion"`

					// Version Version of the model definition.
					Version string `json:"version" yaml:"version"`

					// Name The unique name for the model within the scope of a registrant.
					Name string `json:"name" yaml:"name"`

					// DisplayName Human-readable name for the model.
					DisplayName string `json:"displayName" yaml:"displayName"`

					// Description Description of the model.
					Description string `json:"description,omitempty" yaml:"description,omitempty"`

					// Status Status of model, including:
					// - duplicate: this component is a duplicate of another. The component that is to be the canonical reference and that is duplicated by other components should not be assigned the 'duplicate' status.
					// - maintenance: model is unavailable for a period of time.
					// - enabled: model is available for use for all users of this Meshery Server.
					// - ignored: model is unavailable for use for all users of this Meshery Server.
					Status RelationshipDefinitionSelectorsAllowToModelStatus `json:"status" yaml:"status"`

					// CategoryId ID of the category.
					CategoryId uuid.UUID `gorm:"categoryID" json:"-" yaml:"-"`

					// Registrant Meshery Connections are managed and unmanaged resources that either through discovery or manual entry are tracked by Meshery. Learn more at https://docs.meshery.io/concepts/logical/connections
					Registrant connection.Connection `gorm:"foreignKey:RegistrantId;references:Id" json:"registrant" yaml:"registrant"`

					// RegistrantId ID of the registrant.
					RegistrantId uuid.UUID `gorm:"column:connection_id" json:"connection_id" yaml:"connection_id"`

					// Category Category of the model.
					Category category.CategoryDefinition `gorm:"foreignKey:CategoryId;references:Id" json:"category" yaml:"category"`

					// SubCategory Sub category of the model determines the secondary grouping.
					SubCategory subcategory.SubCategoryDefinition `json:"subCategory" yaml:"subCategory"`

					// Metadata Metadata containing additional information associated with the model.
					Metadata *RelationshipDefinition_Selectors_Allow_To_Model_Metadata `gorm:"type:bytes;serializer:json" json:"metadata" yaml:"metadata"`

					// Model Registrant-defined data associated with the model. Properties pertain to the software being managed (e.g. Kubernetes v1.31).
					Model struct {
						// Version Version of the model as defined by the registrant.
						Version string `json:"version" yaml:"version"`
					} `gorm:"type:bytes;serializer:json" json:"model" yaml:"model"`

					// ComponentsCount Number of components associated with the model.
					ComponentsCount int `gorm:"-" json:"components_count" yaml:"components_count"`

					// RelationshipsCount Number of relationships associated with the model.
					RelationshipsCount int         `gorm:"-" json:"relationships_count" yaml:"relationships_count"`
					Components         interface{} `gorm:"-" json:"components" yaml:"components"`
					Relationships      interface{} `gorm:"-" json:"relationships" yaml:"relationships"`
				} `json:"model,omitempty" yaml:"model,omitempty"`
				Patch *RelationshipDefinition_Selectors_Allow_To_Patch `json:"patch,omitempty" yaml:"patch,omitempty"`
			} `json:"to" yaml:"to"`
		} `json:"allow" yaml:"allow"`

		// Deny Optional selectors used to define relationships which should not be created / is restricted.
		Deny *struct {
			// From Describes the component(s) which are involved in the relationship along with a set of actions to perform upon selection match.
			From []struct {
				// Id A Universally Unique Identifier used to uniquely identify entites in Meshery. The UUID core defintion is used across different schemas.
				Id    *uuid.UUID                                        `json:"id,omitempty" yaml:"id,omitempty"`
				Kind  *string                                           `json:"kind,omitempty" yaml:"kind,omitempty"`
				Match *RelationshipDefinition_Selectors_Deny_From_Match `json:"match,omitempty" yaml:"match,omitempty"`

				// Model Meshery Models serve as a portable unit of packaging to define managed entities, their relationships, and capabilities.
				Model *struct {
					// Id Uniquely identifies the entity (i.e. component) as defined in a declaration (i.e. design).
					Id uuid.UUID `json:"id" yaml:"id"`

					// SchemaVersion Specifies the version of the schema used for the definition.
					SchemaVersion string `json:"schemaVersion" yaml:"schemaVersion"`

					// Version Version of the model definition.
					Version string `json:"version" yaml:"version"`

					// Name The unique name for the model within the scope of a registrant.
					Name string `json:"name" yaml:"name"`

					// DisplayName Human-readable name for the model.
					DisplayName string `json:"displayName" yaml:"displayName"`

					// Description Description of the model.
					Description string `json:"description,omitempty" yaml:"description,omitempty"`

					// Status Status of model, including:
					// - duplicate: this component is a duplicate of another. The component that is to be the canonical reference and that is duplicated by other components should not be assigned the 'duplicate' status.
					// - maintenance: model is unavailable for a period of time.
					// - enabled: model is available for use for all users of this Meshery Server.
					// - ignored: model is unavailable for use for all users of this Meshery Server.
					Status RelationshipDefinitionSelectorsDenyFromModelStatus `json:"status" yaml:"status"`

					// CategoryId ID of the category.
					CategoryId uuid.UUID `gorm:"categoryID" json:"-" yaml:"-"`

					// Registrant Meshery Connections are managed and unmanaged resources that either through discovery or manual entry are tracked by Meshery. Learn more at https://docs.meshery.io/concepts/logical/connections
					Registrant connection.Connection `gorm:"foreignKey:RegistrantId;references:Id" json:"registrant" yaml:"registrant"`

					// RegistrantId ID of the registrant.
					RegistrantId uuid.UUID `gorm:"column:connection_id" json:"connection_id" yaml:"connection_id"`

					// Category Category of the model.
					Category category.CategoryDefinition `gorm:"foreignKey:CategoryId;references:Id" json:"category" yaml:"category"`

					// SubCategory Sub category of the model determines the secondary grouping.
					SubCategory subcategory.SubCategoryDefinition `json:"subCategory" yaml:"subCategory"`

					// Metadata Metadata containing additional information associated with the model.
					Metadata *RelationshipDefinition_Selectors_Deny_From_Model_Metadata `gorm:"type:bytes;serializer:json" json:"metadata" yaml:"metadata"`

					// Model Registrant-defined data associated with the model. Properties pertain to the software being managed (e.g. Kubernetes v1.31).
					Model struct {
						// Version Version of the model as defined by the registrant.
						Version string `json:"version" yaml:"version"`
					} `gorm:"type:bytes;serializer:json" json:"model" yaml:"model"`

					// ComponentsCount Number of components associated with the model.
					ComponentsCount int `gorm:"-" json:"components_count" yaml:"components_count"`

					// RelationshipsCount Number of relationships associated with the model.
					RelationshipsCount int         `gorm:"-" json:"relationships_count" yaml:"relationships_count"`
					Components         interface{} `gorm:"-" json:"components" yaml:"components"`
					Relationships      interface{} `gorm:"-" json:"relationships" yaml:"relationships"`
				} `json:"model,omitempty" yaml:"model,omitempty"`
				Patch *RelationshipDefinition_Selectors_Deny_From_Patch `json:"patch,omitempty" yaml:"patch,omitempty"`
			} `json:"from" yaml:"from"`

			// To Describes the component(s) which are involved in the relationship along with a set of actions to perform upon selection match.
			To []struct {
				// Id A Universally Unique Identifier used to uniquely identify entites in Meshery. The UUID core defintion is used across different schemas.
				Id    *uuid.UUID                                      `json:"id,omitempty" yaml:"id,omitempty"`
				Kind  *string                                         `json:"kind,omitempty" yaml:"kind,omitempty"`
				Match *RelationshipDefinition_Selectors_Deny_To_Match `json:"match,omitempty" yaml:"match,omitempty"`

				// Model Meshery Models serve as a portable unit of packaging to define managed entities, their relationships, and capabilities.
				Model *struct {
					// Id Uniquely identifies the entity (i.e. component) as defined in a declaration (i.e. design).
					Id uuid.UUID `json:"id" yaml:"id"`

					// SchemaVersion Specifies the version of the schema used for the definition.
					SchemaVersion string `json:"schemaVersion" yaml:"schemaVersion"`

					// Version Version of the model definition.
					Version string `json:"version" yaml:"version"`

					// Name The unique name for the model within the scope of a registrant.
					Name string `json:"name" yaml:"name"`

					// DisplayName Human-readable name for the model.
					DisplayName string `json:"displayName" yaml:"displayName"`

					// Description Description of the model.
					Description string `json:"description,omitempty" yaml:"description,omitempty"`

					// Status Status of model, including:
					// - duplicate: this component is a duplicate of another. The component that is to be the canonical reference and that is duplicated by other components should not be assigned the 'duplicate' status.
					// - maintenance: model is unavailable for a period of time.
					// - enabled: model is available for use for all users of this Meshery Server.
					// - ignored: model is unavailable for use for all users of this Meshery Server.
					Status RelationshipDefinitionSelectorsDenyToModelStatus `json:"status" yaml:"status"`

					// CategoryId ID of the category.
					CategoryId uuid.UUID `gorm:"categoryID" json:"-" yaml:"-"`

					// Registrant Meshery Connections are managed and unmanaged resources that either through discovery or manual entry are tracked by Meshery. Learn more at https://docs.meshery.io/concepts/logical/connections
					Registrant connection.Connection `gorm:"foreignKey:RegistrantId;references:Id" json:"registrant" yaml:"registrant"`

					// RegistrantId ID of the registrant.
					RegistrantId uuid.UUID `gorm:"column:connection_id" json:"connection_id" yaml:"connection_id"`

					// Category Category of the model.
					Category category.CategoryDefinition `gorm:"foreignKey:CategoryId;references:Id" json:"category" yaml:"category"`

					// SubCategory Sub category of the model determines the secondary grouping.
					SubCategory subcategory.SubCategoryDefinition `json:"subCategory" yaml:"subCategory"`

					// Metadata Metadata containing additional information associated with the model.
					Metadata *RelationshipDefinition_Selectors_Deny_To_Model_Metadata `gorm:"type:bytes;serializer:json" json:"metadata" yaml:"metadata"`

					// Model Registrant-defined data associated with the model. Properties pertain to the software being managed (e.g. Kubernetes v1.31).
					Model struct {
						// Version Version of the model as defined by the registrant.
						Version string `json:"version" yaml:"version"`
					} `gorm:"type:bytes;serializer:json" json:"model" yaml:"model"`

					// ComponentsCount Number of components associated with the model.
					ComponentsCount int `gorm:"-" json:"components_count" yaml:"components_count"`

					// RelationshipsCount Number of relationships associated with the model.
					RelationshipsCount int         `gorm:"-" json:"relationships_count" yaml:"relationships_count"`
					Components         interface{} `gorm:"-" json:"components" yaml:"components"`
					Relationships      interface{} `gorm:"-" json:"relationships" yaml:"relationships"`
				} `json:"model,omitempty" yaml:"model,omitempty"`
				Patch *RelationshipDefinition_Selectors_Deny_To_Patch `json:"patch,omitempty" yaml:"patch,omitempty"`
			} `json:"to" yaml:"to"`
		} `json:"deny,omitempty" yaml:"deny,omitempty"`
	} `gorm:"type:bytes;serializer:json" json:"selectors,omitempty" yaml:"selectors,omitempty"`

	// Status Status of the relationship.
	Status *RelationshipDefinitionStatus `json:"status" yaml:"status"`

	// SubType Most granular unit of relationship classification. The combination of Kind, Type and SubType together uniquely identify a Relationship.
	SubType string `json:"subType" yaml:"subType"`

	// RelationshipType Classification of relationships. Used to group relationships similar in nature.
	RelationshipType string `json:"type" yaml:"type"`

	// Version Specifies the version of the relationship definition.
	Version string `json:"version" yaml:"version"`
}

// RelationshipDefinitionCapabilitiesEntityState A string starting with an alphanumeric character. Spaces and hyphens allowed.
type RelationshipDefinitionCapabilitiesEntityState string

// RelationshipDefinitionCapabilitiesStatus Status of the capability
type RelationshipDefinitionCapabilitiesStatus string

// RelationshipDefinitionKind Kind of the Relationship. Learn more about relationships - https://docs.meshery.io/concepts/logical/relationships.
type RelationshipDefinitionKind string

// RelationshipDefinitionMetadataStyles0 defines model for .
type RelationshipDefinitionMetadataStyles0 struct {
	// Animation The animation to apply to the element. example ripple,bounce,etc
	Animation *map[string]interface{} `json:"animation,omitempty" yaml:"animation,omitempty"`

	// ArrowScale Scaling for the arrow size.
	ArrowScale *float32 `json:"arrow-scale,omitempty" yaml:"arrow-scale,omitempty"`

	// Color The color of the element's label. Colours may be specified by name (e.g. red), hex (e.g. #ff0000 or #f00), RGB (e.g. rgb(255, 0, 0)), or HSL (e.g. hsl(0, 100%, 50%)).
	Color *string `json:"color,omitempty" yaml:"color,omitempty"`

	// CurveStyle The curving method used to separate two or more edges between two nodes; may be haystack (very fast, bundled straight edges for which loops and compounds are unsupported), straight (straight edges with all arrows supported), bezier (bundled curved edges), unbundled-bezier (curved edges for use with manual control points), segments (a series of straight lines), taxi (right-angled lines, hierarchically bundled). Note that haystack edges work best with ellipse, rectangle, or similar nodes. Smaller node shapes, like triangle, will not be as aesthetically pleasing. Also note that edge endpoint arrows are unsupported for haystack edges.
	CurveStyle *RelationshipDefinitionMetadataStyles0CurveStyle `json:"curve-style,omitempty" yaml:"curve-style,omitempty"`

	// EdgeAnimation The animation to use for the edge. Can be like 'marching-ants' , 'blink' , 'moving-gradient',etc .
	EdgeAnimation *string `json:"edge-animation,omitempty" yaml:"edge-animation,omitempty"`

	// FontFamily A comma-separated list of font names to use on the label text.
	FontFamily *string `json:"font-family,omitempty" yaml:"font-family,omitempty"`

	// FontSize The size of the label text.
	FontSize *string `json:"font-size,omitempty" yaml:"font-size,omitempty"`

	// FontStyle A CSS font style to be applied to the label text.
	FontStyle *string `json:"font-style,omitempty" yaml:"font-style,omitempty"`

	// FontWeight A CSS font weight to be applied to the label text.
	FontWeight *string `json:"font-weight,omitempty" yaml:"font-weight,omitempty"`

	// Label The text to display for an elements label. Can give a path, e.g. data(id) will label with the elements id
	Label *string `json:"label,omitempty" yaml:"label,omitempty"`

	// LineCap The cap style of the edges line; may be butt (default), round, or square. The cap may or may not be visible, depending on the shape of the node and the relative size of the node and edge. Caps other than butt extend beyond the specified endpoint of the edge.
	LineCap *RelationshipDefinitionMetadataStyles0LineCap `json:"line-cap,omitempty" yaml:"line-cap,omitempty"`

	// LineColor The colour of the edges line. Colours may be specified by name (e.g. red), hex (e.g. #ff0000 or #f00), RGB (e.g. rgb(255, 0, 0)), or HSL (e.g. hsl(0, 100%, 50%)).
	LineColor *string `json:"line-color,omitempty" yaml:"line-color,omitempty"`

	// LineOpacity The opacity of the edges line and arrow. Useful if you wish to have a separate opacity for the edge label versus the edge line. Note that the opacity value of the edge element affects the effective opacity of its line and label subcomponents.
	LineOpacity *float32 `json:"line-opacity,omitempty" yaml:"line-opacity,omitempty"`

	// LineStyle The style of the edges line.
	LineStyle *RelationshipDefinitionMetadataStyles0LineStyle `json:"line-style,omitempty" yaml:"line-style,omitempty"`

	// MidTargetArrowColor The colour of the edges source arrow. Colours may be specified by name (e.g. red), hex (e.g. #ff0000 or #f00), RGB (e.g. rgb(255, 0, 0)), or HSL (e.g. hsl(0, 100%, 50%)).
	MidTargetArrowColor *string `json:"mid-target-arrow-color,omitempty" yaml:"mid-target-arrow-color,omitempty"`

	// MidTargetArrowFill The fill state of the edges source arrow
	MidTargetArrowFill *RelationshipDefinitionMetadataStyles0MidTargetArrowFill `json:"mid-target-arrow-fill,omitempty" yaml:"mid-target-arrow-fill,omitempty"`

	// MidTargetArrowShape The shape of the edges source arrow
	MidTargetArrowShape *RelationshipDefinitionMetadataStyles0MidTargetArrowShape `json:"mid-target-arrow-shape,omitempty" yaml:"mid-target-arrow-shape,omitempty"`

	// Opacity The opacity of the element, ranging from 0 to 1. Note that the opacity of a compound node parent affects the effective opacity of its children.See https://js.cytoscape.org/#style/visibility
	Opacity *float32 `json:"opacity,omitempty" yaml:"opacity,omitempty"`

	// PrimaryColor Primary color of the component used for UI representation.
	PrimaryColor string `json:"primaryColor" yaml:"primaryColor"`

	// SecondaryColor Secondary color of the entity used for UI representation.
	SecondaryColor *string `json:"secondaryColor,omitempty" yaml:"secondaryColor,omitempty"`

	// SourceLabel The text to display for an edges source label. Can give a path, e.g. data(id) will label with the elements id
	SourceLabel *string `json:"source-label,omitempty" yaml:"source-label,omitempty"`

	// SvgColor Colored SVG of the entity used for UI representation on light background.
	SvgColor string `json:"svgColor" yaml:"svgColor"`

	// SvgComplete Complete SVG of the entity used for UI representation, often inclusive of background.
	SvgComplete *string `json:"svgComplete,omitempty" yaml:"svgComplete,omitempty"`

	// SvgWhite White SVG of the entity used for UI representation on dark background.
	SvgWhite string `json:"svgWhite" yaml:"svgWhite"`

	// TargetArrowColor The colour of the edges source arrow. Colours may be specified by name (e.g. red), hex (e.g. #ff0000 or #f00), RGB (e.g. rgb(255, 0, 0)), or HSL (e.g. hsl(0, 100%, 50%)).
	TargetArrowColor *string `json:"target-arrow-color,omitempty" yaml:"target-arrow-color,omitempty"`

	// TargetArrowFill The fill state of the edges source arrow
	TargetArrowFill *RelationshipDefinitionMetadataStyles0TargetArrowFill `json:"target-arrow-fill,omitempty" yaml:"target-arrow-fill,omitempty"`

	// TargetArrowShape The shape of the edges source arrow
	TargetArrowShape *RelationshipDefinitionMetadataStyles0TargetArrowShape `json:"target-arrow-shape,omitempty" yaml:"target-arrow-shape,omitempty"`

	// TargetLabel The text to display for an edges target label. Can give a path, e.g. data(id) will label with the elements id
	TargetLabel *string `json:"target-label,omitempty" yaml:"target-label,omitempty"`

	// TextOpacity The opacity of the label text, including its outline.
	TextOpacity *float32 `json:"text-opacity,omitempty" yaml:"text-opacity,omitempty"`

	// TextTransform A transformation to apply to the label text
	TextTransform *RelationshipDefinitionMetadataStyles0TextTransform `json:"text-transform,omitempty" yaml:"text-transform,omitempty"`

	// ZIndex An integer value that affects the relative draw order of elements. In general, an element with a higher z-index will be drawn on top of an element with a lower z-index. Note that edges are under nodes despite z-index.
	ZIndex               *int                   `json:"z-index,omitempty" yaml:"z-index,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-" yaml:"-"`
}

// RelationshipDefinitionMetadataStyles0CurveStyle The curving method used to separate two or more edges between two nodes; may be haystack (very fast, bundled straight edges for which loops and compounds are unsupported), straight (straight edges with all arrows supported), bezier (bundled curved edges), unbundled-bezier (curved edges for use with manual control points), segments (a series of straight lines), taxi (right-angled lines, hierarchically bundled). Note that haystack edges work best with ellipse, rectangle, or similar nodes. Smaller node shapes, like triangle, will not be as aesthetically pleasing. Also note that edge endpoint arrows are unsupported for haystack edges.
type RelationshipDefinitionMetadataStyles0CurveStyle string

// RelationshipDefinitionMetadataStyles0LineCap The cap style of the edges line; may be butt (default), round, or square. The cap may or may not be visible, depending on the shape of the node and the relative size of the node and edge. Caps other than butt extend beyond the specified endpoint of the edge.
type RelationshipDefinitionMetadataStyles0LineCap string

// RelationshipDefinitionMetadataStyles0LineStyle The style of the edges line.
type RelationshipDefinitionMetadataStyles0LineStyle string

// RelationshipDefinitionMetadataStyles0MidTargetArrowFill The fill state of the edges source arrow
type RelationshipDefinitionMetadataStyles0MidTargetArrowFill string

// RelationshipDefinitionMetadataStyles0MidTargetArrowShape The shape of the edges source arrow
type RelationshipDefinitionMetadataStyles0MidTargetArrowShape string

// RelationshipDefinitionMetadataStyles0TargetArrowFill The fill state of the edges source arrow
type RelationshipDefinitionMetadataStyles0TargetArrowFill string

// RelationshipDefinitionMetadataStyles0TargetArrowShape The shape of the edges source arrow
type RelationshipDefinitionMetadataStyles0TargetArrowShape string

// RelationshipDefinitionMetadataStyles0TextTransform A transformation to apply to the label text
type RelationshipDefinitionMetadataStyles0TextTransform string

// RelationshipDefinitionMetadataStyles1 Common styles for all entities
type RelationshipDefinitionMetadataStyles1 struct {
	// Animation The animation to apply to the element. example ripple,bounce,etc
	Animation *map[string]interface{} `json:"animation,omitempty" yaml:"animation,omitempty"`

	// Color The color of the element's label. Colours may be specified by name (e.g. red), hex (e.g. #ff0000 or #f00), RGB (e.g. rgb(255, 0, 0)), or HSL (e.g. hsl(0, 100%, 50%)).
	Color *string `json:"color,omitempty" yaml:"color,omitempty"`

	// FontFamily A comma-separated list of font names to use on the label text.
	FontFamily *string `json:"font-family,omitempty" yaml:"font-family,omitempty"`

	// FontSize The size of the label text.
	FontSize *string `json:"font-size,omitempty" yaml:"font-size,omitempty"`

	// FontStyle A CSS font style to be applied to the label text.
	FontStyle *string `json:"font-style,omitempty" yaml:"font-style,omitempty"`

	// FontWeight A CSS font weight to be applied to the label text.
	FontWeight *string `json:"font-weight,omitempty" yaml:"font-weight,omitempty"`

	// Label The text to display for an elements label. Can give a path, e.g. data(id) will label with the elements id
	Label *string `json:"label,omitempty" yaml:"label,omitempty"`

	// Opacity The opacity of the element, ranging from 0 to 1. Note that the opacity of a compound node parent affects the effective opacity of its children.See https://js.cytoscape.org/#style/visibility
	Opacity *float32 `json:"opacity,omitempty" yaml:"opacity,omitempty"`

	// PrimaryColor Primary color of the component used for UI representation.
	PrimaryColor string `json:"primaryColor" yaml:"primaryColor"`

	// SecondaryColor Secondary color of the entity used for UI representation.
	SecondaryColor *string `json:"secondaryColor,omitempty" yaml:"secondaryColor,omitempty"`

	// SvgColor Colored SVG of the entity used for UI representation on light background.
	SvgColor string `json:"svgColor" yaml:"svgColor"`

	// SvgComplete Complete SVG of the entity used for UI representation, often inclusive of background.
	SvgComplete *string `json:"svgComplete,omitempty" yaml:"svgComplete,omitempty"`

	// SvgWhite White SVG of the entity used for UI representation on dark background.
	SvgWhite string `json:"svgWhite" yaml:"svgWhite"`

	// TextOpacity The opacity of the label text, including its outline.
	TextOpacity *float32 `json:"text-opacity,omitempty" yaml:"text-opacity,omitempty"`

	// TextTransform A transformation to apply to the label text
	TextTransform *RelationshipDefinitionMetadataStyles1TextTransform `json:"text-transform,omitempty" yaml:"text-transform,omitempty"`

	// ZIndex An integer value that affects the relative draw order of elements. In general, an element with a higher z-index will be drawn on top of an element with a lower z-index. Note that edges are under nodes despite z-index.
	ZIndex               *int                   `json:"z-index,omitempty" yaml:"z-index,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-" yaml:"-"`
}

// RelationshipDefinitionMetadataStyles1TextTransform A transformation to apply to the label text
type RelationshipDefinitionMetadataStyles1TextTransform string

// RelationshipDefinition_Metadata_Styles defines model for RelationshipDefinition.Metadata.Styles.
type RelationshipDefinition_Metadata_Styles struct {
	union json.RawMessage
}

// RelationshipDefinition_Metadata Metadata contains additional information associated with the Relationship.
type RelationshipDefinition_Metadata struct {
	// Description Characterization of the meaning of the relationship and its relevance to both Meshery and entities under management.
	Description *string `json:"description" yaml:"description"`

	// IsAnnotation Indicates whether the relationship should be treated as a logical representation only
	IsAnnotation         *bool                                   `json:"isAnnotation" yaml:"isAnnotation"`
	Styles               *RelationshipDefinition_Metadata_Styles `json:"styles" yaml:"styles"`
	AdditionalProperties map[string]interface{}                  `json:"-" yaml:"-"`
}

// RelationshipDefinitionModelStatus Status of model, including:
// - duplicate: this component is a duplicate of another. The component that is to be the canonical reference and that is duplicated by other components should not be assigned the 'duplicate' status.
// - maintenance: model is unavailable for a period of time.
// - enabled: model is available for use for all users of this Meshery Server.
// - ignored: model is unavailable for use for all users of this Meshery Server.
type RelationshipDefinitionModelStatus string

// RelationshipDefinitionModelMetadataShape The shape of the nodes body. Note that each shape fits within the specified width and height, and so you may have to adjust width and height if you desire an equilateral shape (i.e. width !== height for several equilateral shapes)
type RelationshipDefinitionModelMetadataShape string

// RelationshipDefinition_Model_Metadata Metadata containing additional information associated with the model.
type RelationshipDefinition_Model_Metadata struct {
	// Capabilities Capabilities associated with the model
	Capabilities *[]capability.Capability `json:"capabilities,omitempty" yaml:"capabilities,omitempty"`

	// IsAnnotation Indicates whether the model and its entities should be treated as deployable entities or as logical representations.
	IsAnnotation *bool `json:"isAnnotation" yaml:"isAnnotation"`

	// PrimaryColor Primary color associated with the model.
	PrimaryColor *string `json:"primaryColor" yaml:"primaryColor"`

	// SecondaryColor Secondary color associated with the model.
	SecondaryColor *string `json:"secondaryColor" yaml:"secondaryColor"`

	// SvgWhite SVG representation of the model in white color.
	SvgWhite string `json:"svgWhite" yaml:"svgWhite"`

	// SvgColor SVG representation of the model in colored format.
	SvgColor string `json:"svgColor" yaml:"svgColor"`

	// SvgComplete SVG representation of the complete model.
	SvgComplete *string `json:"svgComplete" yaml:"svgComplete"`

	// Shape The shape of the nodes body. Note that each shape fits within the specified width and height, and so you may have to adjust width and height if you desire an equilateral shape (i.e. width !== height for several equilateral shapes)
	Shape                *RelationshipDefinitionModelMetadataShape `json:"shape,omitempty" yaml:"shape,omitempty"`
	AdditionalProperties map[string]interface{}                    `json:"-" yaml:"-"`
}

// RelationshipDefinitionSelectorsAllowFromMatch0 defines model for .
type RelationshipDefinitionSelectorsAllowFromMatch0 struct {
	Refs *[][]string `json:"refs,omitempty" yaml:"refs,omitempty"`
}

// RelationshipDefinitionSelectorsAllowFromMatch1 defines model for .
type RelationshipDefinitionSelectorsAllowFromMatch1 struct {
	From *[]RelationshipDefinition_Selectors_Allow_From_Match_1_From_Item `json:"from,omitempty" yaml:"from,omitempty"`
	To   *[]RelationshipDefinition_Selectors_Allow_From_Match_1_To_Item   `json:"to,omitempty" yaml:"to,omitempty"`
}

// RelationshipDefinitionSelectorsAllowFromMatch1From0 defines model for .
type RelationshipDefinitionSelectorsAllowFromMatch1From0 struct {
	// MutatorRef JSON ref to value from where patch should be applied.
	MutatorRef *[][]string `json:"mutatorRef,omitempty" yaml:"mutatorRef,omitempty"`
}

// RelationshipDefinitionSelectorsAllowFromMatch1From1 defines model for .
type RelationshipDefinitionSelectorsAllowFromMatch1From1 struct {
	MutatedRef *[][]string `json:"mutatedRef,omitempty" yaml:"mutatedRef,omitempty"`
}

// RelationshipDefinition_Selectors_Allow_From_Match_1_From_Item defines model for RelationshipDefinition.Selectors.Allow.From.Match.1.From.Item.
type RelationshipDefinition_Selectors_Allow_From_Match_1_From_Item struct {
	// Id A Universally Unique Identifier used to uniquely identify entites in Meshery. The UUID core defintion is used across different schemas.
	Id    *uuid.UUID `json:"id,omitempty" yaml:"id,omitempty"`
	Kind  *string    `json:"kind,omitempty" yaml:"kind,omitempty"`
	union json.RawMessage
}

// RelationshipDefinitionSelectorsAllowFromMatch1To0 defines model for .
type RelationshipDefinitionSelectorsAllowFromMatch1To0 struct {
	// MutatorRef JSON ref to value from where patch should be applied.
	MutatorRef *[][]string `json:"mutatorRef,omitempty" yaml:"mutatorRef,omitempty"`
}

// RelationshipDefinitionSelectorsAllowFromMatch1To1 defines model for .
type RelationshipDefinitionSelectorsAllowFromMatch1To1 struct {
	MutatedRef *[][]string `json:"mutatedRef,omitempty" yaml:"mutatedRef,omitempty"`
}

// RelationshipDefinition_Selectors_Allow_From_Match_1_To_Item defines model for RelationshipDefinition.Selectors.Allow.From.Match.1.To.Item.
type RelationshipDefinition_Selectors_Allow_From_Match_1_To_Item struct {
	// Id A Universally Unique Identifier used to uniquely identify entites in Meshery. The UUID core defintion is used across different schemas.
	Id    *uuid.UUID `json:"id,omitempty" yaml:"id,omitempty"`
	Kind  *string    `json:"kind,omitempty" yaml:"kind,omitempty"`
	union json.RawMessage
}

// RelationshipDefinition_Selectors_Allow_From_Match defines model for RelationshipDefinition.Selectors.Allow.From.Match.
type RelationshipDefinition_Selectors_Allow_From_Match struct {
	union json.RawMessage
}

// RelationshipDefinitionSelectorsAllowFromModelStatus Status of model, including:
// - duplicate: this component is a duplicate of another. The component that is to be the canonical reference and that is duplicated by other components should not be assigned the 'duplicate' status.
// - maintenance: model is unavailable for a period of time.
// - enabled: model is available for use for all users of this Meshery Server.
// - ignored: model is unavailable for use for all users of this Meshery Server.
type RelationshipDefinitionSelectorsAllowFromModelStatus string

// RelationshipDefinitionSelectorsAllowFromModelMetadataShape The shape of the nodes body. Note that each shape fits within the specified width and height, and so you may have to adjust width and height if you desire an equilateral shape (i.e. width !== height for several equilateral shapes)
type RelationshipDefinitionSelectorsAllowFromModelMetadataShape string

// RelationshipDefinition_Selectors_Allow_From_Model_Metadata Metadata containing additional information associated with the model.
type RelationshipDefinition_Selectors_Allow_From_Model_Metadata struct {
	// Capabilities Capabilities associated with the model
	Capabilities *[]capability.Capability `json:"capabilities,omitempty" yaml:"capabilities,omitempty"`

	// IsAnnotation Indicates whether the model and its entities should be treated as deployable entities or as logical representations.
	IsAnnotation *bool `json:"isAnnotation" yaml:"isAnnotation"`

	// PrimaryColor Primary color associated with the model.
	PrimaryColor *string `json:"primaryColor" yaml:"primaryColor"`

	// SecondaryColor Secondary color associated with the model.
	SecondaryColor *string `json:"secondaryColor" yaml:"secondaryColor"`

	// SvgWhite SVG representation of the model in white color.
	SvgWhite string `json:"svgWhite" yaml:"svgWhite"`

	// SvgColor SVG representation of the model in colored format.
	SvgColor string `json:"svgColor" yaml:"svgColor"`

	// SvgComplete SVG representation of the complete model.
	SvgComplete *string `json:"svgComplete" yaml:"svgComplete"`

	// Shape The shape of the nodes body. Note that each shape fits within the specified width and height, and so you may have to adjust width and height if you desire an equilateral shape (i.e. width !== height for several equilateral shapes)
	Shape                *RelationshipDefinitionSelectorsAllowFromModelMetadataShape `json:"shape,omitempty" yaml:"shape,omitempty"`
	AdditionalProperties map[string]interface{}                                      `json:"-" yaml:"-"`
}

// RelationshipDefinitionSelectorsAllowFromPatchPatchStrategy patchStrategy allows you to make specific changes to a resource using a standard JSON Patch format (RFC 6902).
//
// add: Inserts a value into an array or adds a member to an object.
// replace: Replaces a value.
// merge: Combines the values of the target location with the values from the patch. If the target location doesn't exist, it is created.
// strategic:specific to Kubernetes and understands the structure of Kubernetes objects. It can handle complex changes like updating lists and maps, as well as preserving default values. However, it's not supported for custom resources. For custom resources, only JSON Patch and Merge Patch are typically supported.
// remove: Removes a value.
// copy: Copies a value from one location to another.
// move: Moves a value from one location to another.
// test: Tests that a value at the target location is equal to a specified value.
type RelationshipDefinitionSelectorsAllowFromPatchPatchStrategy string

// RelationshipDefinitionSelectorsAllowFromPatch0 defines model for .
type RelationshipDefinitionSelectorsAllowFromPatch0 struct {
	// MutatorRef JSON ref to value from where patch should be applied.
	MutatorRef *[][]string `json:"mutatorRef,omitempty" yaml:"mutatorRef,omitempty"`
}

// RelationshipDefinitionSelectorsAllowFromPatch1 defines model for .
type RelationshipDefinitionSelectorsAllowFromPatch1 struct {
	MutatedRef *[][]string `json:"mutatedRef,omitempty" yaml:"mutatedRef,omitempty"`
}

// RelationshipDefinition_Selectors_Allow_From_Patch defines model for RelationshipDefinition.Selectors.Allow.From.Patch.
type RelationshipDefinition_Selectors_Allow_From_Patch struct {
	// PatchStrategy patchStrategy allows you to make specific changes to a resource using a standard JSON Patch format (RFC 6902).
	//
	// add: Inserts a value into an array or adds a member to an object.
	// replace: Replaces a value.
	// merge: Combines the values of the target location with the values from the patch. If the target location doesn't exist, it is created.
	// strategic:specific to Kubernetes and understands the structure of Kubernetes objects. It can handle complex changes like updating lists and maps, as well as preserving default values. However, it's not supported for custom resources. For custom resources, only JSON Patch and Merge Patch are typically supported.
	// remove: Removes a value.
	// copy: Copies a value from one location to another.
	// move: Moves a value from one location to another.
	// test: Tests that a value at the target location is equal to a specified value.
	PatchStrategy *RelationshipDefinitionSelectorsAllowFromPatchPatchStrategy `json:"patchStrategy,omitempty" yaml:"patchStrategy,omitempty"`
	union         json.RawMessage
}

// RelationshipDefinitionSelectorsAllowToMatch0 defines model for .
type RelationshipDefinitionSelectorsAllowToMatch0 struct {
	Refs *[][]string `json:"refs,omitempty" yaml:"refs,omitempty"`
}

// RelationshipDefinitionSelectorsAllowToMatch1 defines model for .
type RelationshipDefinitionSelectorsAllowToMatch1 struct {
	From *[]RelationshipDefinition_Selectors_Allow_To_Match_1_From_Item `json:"from,omitempty" yaml:"from,omitempty"`
	To   *[]RelationshipDefinition_Selectors_Allow_To_Match_1_To_Item   `json:"to,omitempty" yaml:"to,omitempty"`
}

// RelationshipDefinitionSelectorsAllowToMatch1From0 defines model for .
type RelationshipDefinitionSelectorsAllowToMatch1From0 struct {
	// MutatorRef JSON ref to value from where patch should be applied.
	MutatorRef *[][]string `json:"mutatorRef,omitempty" yaml:"mutatorRef,omitempty"`
}

// RelationshipDefinitionSelectorsAllowToMatch1From1 defines model for .
type RelationshipDefinitionSelectorsAllowToMatch1From1 struct {
	MutatedRef *[][]string `json:"mutatedRef,omitempty" yaml:"mutatedRef,omitempty"`
}

// RelationshipDefinition_Selectors_Allow_To_Match_1_From_Item defines model for RelationshipDefinition.Selectors.Allow.To.Match.1.From.Item.
type RelationshipDefinition_Selectors_Allow_To_Match_1_From_Item struct {
	// Id A Universally Unique Identifier used to uniquely identify entites in Meshery. The UUID core defintion is used across different schemas.
	Id    *uuid.UUID `json:"id,omitempty" yaml:"id,omitempty"`
	Kind  *string    `json:"kind,omitempty" yaml:"kind,omitempty"`
	union json.RawMessage
}

// RelationshipDefinitionSelectorsAllowToMatch1To0 defines model for .
type RelationshipDefinitionSelectorsAllowToMatch1To0 struct {
	// MutatorRef JSON ref to value from where patch should be applied.
	MutatorRef *[][]string `json:"mutatorRef,omitempty" yaml:"mutatorRef,omitempty"`
}

// RelationshipDefinitionSelectorsAllowToMatch1To1 defines model for .
type RelationshipDefinitionSelectorsAllowToMatch1To1 struct {
	MutatedRef *[][]string `json:"mutatedRef,omitempty" yaml:"mutatedRef,omitempty"`
}

// RelationshipDefinition_Selectors_Allow_To_Match_1_To_Item defines model for RelationshipDefinition.Selectors.Allow.To.Match.1.To.Item.
type RelationshipDefinition_Selectors_Allow_To_Match_1_To_Item struct {
	// Id A Universally Unique Identifier used to uniquely identify entites in Meshery. The UUID core defintion is used across different schemas.
	Id    *uuid.UUID `json:"id,omitempty" yaml:"id,omitempty"`
	Kind  *string    `json:"kind,omitempty" yaml:"kind,omitempty"`
	union json.RawMessage
}

// RelationshipDefinition_Selectors_Allow_To_Match defines model for RelationshipDefinition.Selectors.Allow.To.Match.
type RelationshipDefinition_Selectors_Allow_To_Match struct {
	union json.RawMessage
}

// RelationshipDefinitionSelectorsAllowToModelStatus Status of model, including:
// - duplicate: this component is a duplicate of another. The component that is to be the canonical reference and that is duplicated by other components should not be assigned the 'duplicate' status.
// - maintenance: model is unavailable for a period of time.
// - enabled: model is available for use for all users of this Meshery Server.
// - ignored: model is unavailable for use for all users of this Meshery Server.
type RelationshipDefinitionSelectorsAllowToModelStatus string

// RelationshipDefinitionSelectorsAllowToModelMetadataShape The shape of the nodes body. Note that each shape fits within the specified width and height, and so you may have to adjust width and height if you desire an equilateral shape (i.e. width !== height for several equilateral shapes)
type RelationshipDefinitionSelectorsAllowToModelMetadataShape string

// RelationshipDefinition_Selectors_Allow_To_Model_Metadata Metadata containing additional information associated with the model.
type RelationshipDefinition_Selectors_Allow_To_Model_Metadata struct {
	// Capabilities Capabilities associated with the model
	Capabilities *[]capability.Capability `json:"capabilities,omitempty" yaml:"capabilities,omitempty"`

	// IsAnnotation Indicates whether the model and its entities should be treated as deployable entities or as logical representations.
	IsAnnotation *bool `json:"isAnnotation" yaml:"isAnnotation"`

	// PrimaryColor Primary color associated with the model.
	PrimaryColor *string `json:"primaryColor" yaml:"primaryColor"`

	// SecondaryColor Secondary color associated with the model.
	SecondaryColor *string `json:"secondaryColor" yaml:"secondaryColor"`

	// SvgWhite SVG representation of the model in white color.
	SvgWhite string `json:"svgWhite" yaml:"svgWhite"`

	// SvgColor SVG representation of the model in colored format.
	SvgColor string `json:"svgColor" yaml:"svgColor"`

	// SvgComplete SVG representation of the complete model.
	SvgComplete *string `json:"svgComplete" yaml:"svgComplete"`

	// Shape The shape of the nodes body. Note that each shape fits within the specified width and height, and so you may have to adjust width and height if you desire an equilateral shape (i.e. width !== height for several equilateral shapes)
	Shape                *RelationshipDefinitionSelectorsAllowToModelMetadataShape `json:"shape,omitempty" yaml:"shape,omitempty"`
	AdditionalProperties map[string]interface{}                                    `json:"-" yaml:"-"`
}

// RelationshipDefinitionSelectorsAllowToPatchPatchStrategy patchStrategy allows you to make specific changes to a resource using a standard JSON Patch format (RFC 6902).
//
// add: Inserts a value into an array or adds a member to an object.
// replace: Replaces a value.
// merge: Combines the values of the target location with the values from the patch. If the target location doesn't exist, it is created.
// strategic:specific to Kubernetes and understands the structure of Kubernetes objects. It can handle complex changes like updating lists and maps, as well as preserving default values. However, it's not supported for custom resources. For custom resources, only JSON Patch and Merge Patch are typically supported.
// remove: Removes a value.
// copy: Copies a value from one location to another.
// move: Moves a value from one location to another.
// test: Tests that a value at the target location is equal to a specified value.
type RelationshipDefinitionSelectorsAllowToPatchPatchStrategy string

// RelationshipDefinitionSelectorsAllowToPatch0 defines model for .
type RelationshipDefinitionSelectorsAllowToPatch0 struct {
	// MutatorRef JSON ref to value from where patch should be applied.
	MutatorRef *[][]string `json:"mutatorRef,omitempty" yaml:"mutatorRef,omitempty"`
}

// RelationshipDefinitionSelectorsAllowToPatch1 defines model for .
type RelationshipDefinitionSelectorsAllowToPatch1 struct {
	MutatedRef *[][]string `json:"mutatedRef,omitempty" yaml:"mutatedRef,omitempty"`
}

// RelationshipDefinition_Selectors_Allow_To_Patch defines model for RelationshipDefinition.Selectors.Allow.To.Patch.
type RelationshipDefinition_Selectors_Allow_To_Patch struct {
	// PatchStrategy patchStrategy allows you to make specific changes to a resource using a standard JSON Patch format (RFC 6902).
	//
	// add: Inserts a value into an array or adds a member to an object.
	// replace: Replaces a value.
	// merge: Combines the values of the target location with the values from the patch. If the target location doesn't exist, it is created.
	// strategic:specific to Kubernetes and understands the structure of Kubernetes objects. It can handle complex changes like updating lists and maps, as well as preserving default values. However, it's not supported for custom resources. For custom resources, only JSON Patch and Merge Patch are typically supported.
	// remove: Removes a value.
	// copy: Copies a value from one location to another.
	// move: Moves a value from one location to another.
	// test: Tests that a value at the target location is equal to a specified value.
	PatchStrategy *RelationshipDefinitionSelectorsAllowToPatchPatchStrategy `json:"patchStrategy,omitempty" yaml:"patchStrategy,omitempty"`
	union         json.RawMessage
}

// RelationshipDefinitionSelectorsDenyFromMatch0 defines model for .
type RelationshipDefinitionSelectorsDenyFromMatch0 struct {
	Refs *[][]string `json:"refs,omitempty" yaml:"refs,omitempty"`
}

// RelationshipDefinitionSelectorsDenyFromMatch1 defines model for .
type RelationshipDefinitionSelectorsDenyFromMatch1 struct {
	From *[]RelationshipDefinition_Selectors_Deny_From_Match_1_From_Item `json:"from,omitempty" yaml:"from,omitempty"`
	To   *[]RelationshipDefinition_Selectors_Deny_From_Match_1_To_Item   `json:"to,omitempty" yaml:"to,omitempty"`
}

// RelationshipDefinitionSelectorsDenyFromMatch1From0 defines model for .
type RelationshipDefinitionSelectorsDenyFromMatch1From0 struct {
	// MutatorRef JSON ref to value from where patch should be applied.
	MutatorRef *[][]string `json:"mutatorRef,omitempty" yaml:"mutatorRef,omitempty"`
}

// RelationshipDefinitionSelectorsDenyFromMatch1From1 defines model for .
type RelationshipDefinitionSelectorsDenyFromMatch1From1 struct {
	MutatedRef *[][]string `json:"mutatedRef,omitempty" yaml:"mutatedRef,omitempty"`
}

// RelationshipDefinition_Selectors_Deny_From_Match_1_From_Item defines model for RelationshipDefinition.Selectors.Deny.From.Match.1.From.Item.
type RelationshipDefinition_Selectors_Deny_From_Match_1_From_Item struct {
	// Id A Universally Unique Identifier used to uniquely identify entites in Meshery. The UUID core defintion is used across different schemas.
	Id    *uuid.UUID `json:"id,omitempty" yaml:"id,omitempty"`
	Kind  *string    `json:"kind,omitempty" yaml:"kind,omitempty"`
	union json.RawMessage
}

// RelationshipDefinitionSelectorsDenyFromMatch1To0 defines model for .
type RelationshipDefinitionSelectorsDenyFromMatch1To0 struct {
	// MutatorRef JSON ref to value from where patch should be applied.
	MutatorRef *[][]string `json:"mutatorRef,omitempty" yaml:"mutatorRef,omitempty"`
}

// RelationshipDefinitionSelectorsDenyFromMatch1To1 defines model for .
type RelationshipDefinitionSelectorsDenyFromMatch1To1 struct {
	MutatedRef *[][]string `json:"mutatedRef,omitempty" yaml:"mutatedRef,omitempty"`
}

// RelationshipDefinition_Selectors_Deny_From_Match_1_To_Item defines model for RelationshipDefinition.Selectors.Deny.From.Match.1.To.Item.
type RelationshipDefinition_Selectors_Deny_From_Match_1_To_Item struct {
	// Id A Universally Unique Identifier used to uniquely identify entites in Meshery. The UUID core defintion is used across different schemas.
	Id    *uuid.UUID `json:"id,omitempty" yaml:"id,omitempty"`
	Kind  *string    `json:"kind,omitempty" yaml:"kind,omitempty"`
	union json.RawMessage
}

// RelationshipDefinition_Selectors_Deny_From_Match defines model for RelationshipDefinition.Selectors.Deny.From.Match.
type RelationshipDefinition_Selectors_Deny_From_Match struct {
	union json.RawMessage
}

// RelationshipDefinitionSelectorsDenyFromModelStatus Status of model, including:
// - duplicate: this component is a duplicate of another. The component that is to be the canonical reference and that is duplicated by other components should not be assigned the 'duplicate' status.
// - maintenance: model is unavailable for a period of time.
// - enabled: model is available for use for all users of this Meshery Server.
// - ignored: model is unavailable for use for all users of this Meshery Server.
type RelationshipDefinitionSelectorsDenyFromModelStatus string

// RelationshipDefinitionSelectorsDenyFromModelMetadataShape The shape of the nodes body. Note that each shape fits within the specified width and height, and so you may have to adjust width and height if you desire an equilateral shape (i.e. width !== height for several equilateral shapes)
type RelationshipDefinitionSelectorsDenyFromModelMetadataShape string

// RelationshipDefinition_Selectors_Deny_From_Model_Metadata Metadata containing additional information associated with the model.
type RelationshipDefinition_Selectors_Deny_From_Model_Metadata struct {
	// Capabilities Capabilities associated with the model
	Capabilities *[]capability.Capability `json:"capabilities,omitempty" yaml:"capabilities,omitempty"`

	// IsAnnotation Indicates whether the model and its entities should be treated as deployable entities or as logical representations.
	IsAnnotation *bool `json:"isAnnotation" yaml:"isAnnotation"`

	// PrimaryColor Primary color associated with the model.
	PrimaryColor *string `json:"primaryColor" yaml:"primaryColor"`

	// SecondaryColor Secondary color associated with the model.
	SecondaryColor *string `json:"secondaryColor" yaml:"secondaryColor"`

	// SvgWhite SVG representation of the model in white color.
	SvgWhite string `json:"svgWhite" yaml:"svgWhite"`

	// SvgColor SVG representation of the model in colored format.
	SvgColor string `json:"svgColor" yaml:"svgColor"`

	// SvgComplete SVG representation of the complete model.
	SvgComplete *string `json:"svgComplete" yaml:"svgComplete"`

	// Shape The shape of the nodes body. Note that each shape fits within the specified width and height, and so you may have to adjust width and height if you desire an equilateral shape (i.e. width !== height for several equilateral shapes)
	Shape                *RelationshipDefinitionSelectorsDenyFromModelMetadataShape `json:"shape,omitempty" yaml:"shape,omitempty"`
	AdditionalProperties map[string]interface{}                                     `json:"-" yaml:"-"`
}

// RelationshipDefinitionSelectorsDenyFromPatchPatchStrategy patchStrategy allows you to make specific changes to a resource using a standard JSON Patch format (RFC 6902).
//
// add: Inserts a value into an array or adds a member to an object.
// replace: Replaces a value.
// merge: Combines the values of the target location with the values from the patch. If the target location doesn't exist, it is created.
// strategic:specific to Kubernetes and understands the structure of Kubernetes objects. It can handle complex changes like updating lists and maps, as well as preserving default values. However, it's not supported for custom resources. For custom resources, only JSON Patch and Merge Patch are typically supported.
// remove: Removes a value.
// copy: Copies a value from one location to another.
// move: Moves a value from one location to another.
// test: Tests that a value at the target location is equal to a specified value.
type RelationshipDefinitionSelectorsDenyFromPatchPatchStrategy string

// RelationshipDefinitionSelectorsDenyFromPatch0 defines model for .
type RelationshipDefinitionSelectorsDenyFromPatch0 struct {
	// MutatorRef JSON ref to value from where patch should be applied.
	MutatorRef *[][]string `json:"mutatorRef,omitempty" yaml:"mutatorRef,omitempty"`
}

// RelationshipDefinitionSelectorsDenyFromPatch1 defines model for .
type RelationshipDefinitionSelectorsDenyFromPatch1 struct {
	MutatedRef *[][]string `json:"mutatedRef,omitempty" yaml:"mutatedRef,omitempty"`
}

// RelationshipDefinition_Selectors_Deny_From_Patch defines model for RelationshipDefinition.Selectors.Deny.From.Patch.
type RelationshipDefinition_Selectors_Deny_From_Patch struct {
	// PatchStrategy patchStrategy allows you to make specific changes to a resource using a standard JSON Patch format (RFC 6902).
	//
	// add: Inserts a value into an array or adds a member to an object.
	// replace: Replaces a value.
	// merge: Combines the values of the target location with the values from the patch. If the target location doesn't exist, it is created.
	// strategic:specific to Kubernetes and understands the structure of Kubernetes objects. It can handle complex changes like updating lists and maps, as well as preserving default values. However, it's not supported for custom resources. For custom resources, only JSON Patch and Merge Patch are typically supported.
	// remove: Removes a value.
	// copy: Copies a value from one location to another.
	// move: Moves a value from one location to another.
	// test: Tests that a value at the target location is equal to a specified value.
	PatchStrategy *RelationshipDefinitionSelectorsDenyFromPatchPatchStrategy `json:"patchStrategy,omitempty" yaml:"patchStrategy,omitempty"`
	union         json.RawMessage
}

// RelationshipDefinitionSelectorsDenyToMatch0 defines model for .
type RelationshipDefinitionSelectorsDenyToMatch0 struct {
	Refs *[][]string `json:"refs,omitempty" yaml:"refs,omitempty"`
}

// RelationshipDefinitionSelectorsDenyToMatch1 defines model for .
type RelationshipDefinitionSelectorsDenyToMatch1 struct {
	From *[]RelationshipDefinition_Selectors_Deny_To_Match_1_From_Item `json:"from,omitempty" yaml:"from,omitempty"`
	To   *[]RelationshipDefinition_Selectors_Deny_To_Match_1_To_Item   `json:"to,omitempty" yaml:"to,omitempty"`
}

// RelationshipDefinitionSelectorsDenyToMatch1From0 defines model for .
type RelationshipDefinitionSelectorsDenyToMatch1From0 struct {
	// MutatorRef JSON ref to value from where patch should be applied.
	MutatorRef *[][]string `json:"mutatorRef,omitempty" yaml:"mutatorRef,omitempty"`
}

// RelationshipDefinitionSelectorsDenyToMatch1From1 defines model for .
type RelationshipDefinitionSelectorsDenyToMatch1From1 struct {
	MutatedRef *[][]string `json:"mutatedRef,omitempty" yaml:"mutatedRef,omitempty"`
}

// RelationshipDefinition_Selectors_Deny_To_Match_1_From_Item defines model for RelationshipDefinition.Selectors.Deny.To.Match.1.From.Item.
type RelationshipDefinition_Selectors_Deny_To_Match_1_From_Item struct {
	// Id A Universally Unique Identifier used to uniquely identify entites in Meshery. The UUID core defintion is used across different schemas.
	Id    *uuid.UUID `json:"id,omitempty" yaml:"id,omitempty"`
	Kind  *string    `json:"kind,omitempty" yaml:"kind,omitempty"`
	union json.RawMessage
}

// RelationshipDefinitionSelectorsDenyToMatch1To0 defines model for .
type RelationshipDefinitionSelectorsDenyToMatch1To0 struct {
	// MutatorRef JSON ref to value from where patch should be applied.
	MutatorRef *[][]string `json:"mutatorRef,omitempty" yaml:"mutatorRef,omitempty"`
}

// RelationshipDefinitionSelectorsDenyToMatch1To1 defines model for .
type RelationshipDefinitionSelectorsDenyToMatch1To1 struct {
	MutatedRef *[][]string `json:"mutatedRef,omitempty" yaml:"mutatedRef,omitempty"`
}

// RelationshipDefinition_Selectors_Deny_To_Match_1_To_Item defines model for RelationshipDefinition.Selectors.Deny.To.Match.1.To.Item.
type RelationshipDefinition_Selectors_Deny_To_Match_1_To_Item struct {
	// Id A Universally Unique Identifier used to uniquely identify entites in Meshery. The UUID core defintion is used across different schemas.
	Id    *uuid.UUID `json:"id,omitempty" yaml:"id,omitempty"`
	Kind  *string    `json:"kind,omitempty" yaml:"kind,omitempty"`
	union json.RawMessage
}

// RelationshipDefinition_Selectors_Deny_To_Match defines model for RelationshipDefinition.Selectors.Deny.To.Match.
type RelationshipDefinition_Selectors_Deny_To_Match struct {
	union json.RawMessage
}

// RelationshipDefinitionSelectorsDenyToModelStatus Status of model, including:
// - duplicate: this component is a duplicate of another. The component that is to be the canonical reference and that is duplicated by other components should not be assigned the 'duplicate' status.
// - maintenance: model is unavailable for a period of time.
// - enabled: model is available for use for all users of this Meshery Server.
// - ignored: model is unavailable for use for all users of this Meshery Server.
type RelationshipDefinitionSelectorsDenyToModelStatus string

// RelationshipDefinitionSelectorsDenyToModelMetadataShape The shape of the nodes body. Note that each shape fits within the specified width and height, and so you may have to adjust width and height if you desire an equilateral shape (i.e. width !== height for several equilateral shapes)
type RelationshipDefinitionSelectorsDenyToModelMetadataShape string

// RelationshipDefinition_Selectors_Deny_To_Model_Metadata Metadata containing additional information associated with the model.
type RelationshipDefinition_Selectors_Deny_To_Model_Metadata struct {
	// Capabilities Capabilities associated with the model
	Capabilities *[]capability.Capability `json:"capabilities,omitempty" yaml:"capabilities,omitempty"`

	// IsAnnotation Indicates whether the model and its entities should be treated as deployable entities or as logical representations.
	IsAnnotation *bool `json:"isAnnotation" yaml:"isAnnotation"`

	// PrimaryColor Primary color associated with the model.
	PrimaryColor *string `json:"primaryColor" yaml:"primaryColor"`

	// SecondaryColor Secondary color associated with the model.
	SecondaryColor *string `json:"secondaryColor" yaml:"secondaryColor"`

	// SvgWhite SVG representation of the model in white color.
	SvgWhite string `json:"svgWhite" yaml:"svgWhite"`

	// SvgColor SVG representation of the model in colored format.
	SvgColor string `json:"svgColor" yaml:"svgColor"`

	// SvgComplete SVG representation of the complete model.
	SvgComplete *string `json:"svgComplete" yaml:"svgComplete"`

	// Shape The shape of the nodes body. Note that each shape fits within the specified width and height, and so you may have to adjust width and height if you desire an equilateral shape (i.e. width !== height for several equilateral shapes)
	Shape                *RelationshipDefinitionSelectorsDenyToModelMetadataShape `json:"shape,omitempty" yaml:"shape,omitempty"`
	AdditionalProperties map[string]interface{}                                   `json:"-" yaml:"-"`
}

// RelationshipDefinitionSelectorsDenyToPatchPatchStrategy patchStrategy allows you to make specific changes to a resource using a standard JSON Patch format (RFC 6902).
//
// add: Inserts a value into an array or adds a member to an object.
// replace: Replaces a value.
// merge: Combines the values of the target location with the values from the patch. If the target location doesn't exist, it is created.
// strategic:specific to Kubernetes and understands the structure of Kubernetes objects. It can handle complex changes like updating lists and maps, as well as preserving default values. However, it's not supported for custom resources. For custom resources, only JSON Patch and Merge Patch are typically supported.
// remove: Removes a value.
// copy: Copies a value from one location to another.
// move: Moves a value from one location to another.
// test: Tests that a value at the target location is equal to a specified value.
type RelationshipDefinitionSelectorsDenyToPatchPatchStrategy string

// RelationshipDefinitionSelectorsDenyToPatch0 defines model for .
type RelationshipDefinitionSelectorsDenyToPatch0 struct {
	// MutatorRef JSON ref to value from where patch should be applied.
	MutatorRef *[][]string `json:"mutatorRef,omitempty" yaml:"mutatorRef,omitempty"`
}

// RelationshipDefinitionSelectorsDenyToPatch1 defines model for .
type RelationshipDefinitionSelectorsDenyToPatch1 struct {
	MutatedRef *[][]string `json:"mutatedRef,omitempty" yaml:"mutatedRef,omitempty"`
}

// RelationshipDefinition_Selectors_Deny_To_Patch defines model for RelationshipDefinition.Selectors.Deny.To.Patch.
type RelationshipDefinition_Selectors_Deny_To_Patch struct {
	// PatchStrategy patchStrategy allows you to make specific changes to a resource using a standard JSON Patch format (RFC 6902).
	//
	// add: Inserts a value into an array or adds a member to an object.
	// replace: Replaces a value.
	// merge: Combines the values of the target location with the values from the patch. If the target location doesn't exist, it is created.
	// strategic:specific to Kubernetes and understands the structure of Kubernetes objects. It can handle complex changes like updating lists and maps, as well as preserving default values. However, it's not supported for custom resources. For custom resources, only JSON Patch and Merge Patch are typically supported.
	// remove: Removes a value.
	// copy: Copies a value from one location to another.
	// move: Moves a value from one location to another.
	// test: Tests that a value at the target location is equal to a specified value.
	PatchStrategy *RelationshipDefinitionSelectorsDenyToPatchPatchStrategy `json:"patchStrategy,omitempty" yaml:"patchStrategy,omitempty"`
	union         json.RawMessage
}

// RelationshipDefinitionStatus Status of the relationship.
type RelationshipDefinitionStatus string

// Getter for additional properties for RelationshipDefinitionMetadataStyles0. Returns the specified
// element and whether it was found
func (a RelationshipDefinitionMetadataStyles0) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for RelationshipDefinitionMetadataStyles0
func (a *RelationshipDefinitionMetadataStyles0) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for RelationshipDefinitionMetadataStyles0 to handle AdditionalProperties
func (a *RelationshipDefinitionMetadataStyles0) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["animation"]; found {
		err = json.Unmarshal(raw, &a.Animation)
		if err != nil {
			return fmt.Errorf("error reading 'animation': %w", err)
		}
		delete(object, "animation")
	}

	if raw, found := object["arrow-scale"]; found {
		err = json.Unmarshal(raw, &a.ArrowScale)
		if err != nil {
			return fmt.Errorf("error reading 'arrow-scale': %w", err)
		}
		delete(object, "arrow-scale")
	}

	if raw, found := object["color"]; found {
		err = json.Unmarshal(raw, &a.Color)
		if err != nil {
			return fmt.Errorf("error reading 'color': %w", err)
		}
		delete(object, "color")
	}

	if raw, found := object["curve-style"]; found {
		err = json.Unmarshal(raw, &a.CurveStyle)
		if err != nil {
			return fmt.Errorf("error reading 'curve-style': %w", err)
		}
		delete(object, "curve-style")
	}

	if raw, found := object["edge-animation"]; found {
		err = json.Unmarshal(raw, &a.EdgeAnimation)
		if err != nil {
			return fmt.Errorf("error reading 'edge-animation': %w", err)
		}
		delete(object, "edge-animation")
	}

	if raw, found := object["font-family"]; found {
		err = json.Unmarshal(raw, &a.FontFamily)
		if err != nil {
			return fmt.Errorf("error reading 'font-family': %w", err)
		}
		delete(object, "font-family")
	}

	if raw, found := object["font-size"]; found {
		err = json.Unmarshal(raw, &a.FontSize)
		if err != nil {
			return fmt.Errorf("error reading 'font-size': %w", err)
		}
		delete(object, "font-size")
	}

	if raw, found := object["font-style"]; found {
		err = json.Unmarshal(raw, &a.FontStyle)
		if err != nil {
			return fmt.Errorf("error reading 'font-style': %w", err)
		}
		delete(object, "font-style")
	}

	if raw, found := object["font-weight"]; found {
		err = json.Unmarshal(raw, &a.FontWeight)
		if err != nil {
			return fmt.Errorf("error reading 'font-weight': %w", err)
		}
		delete(object, "font-weight")
	}

	if raw, found := object["label"]; found {
		err = json.Unmarshal(raw, &a.Label)
		if err != nil {
			return fmt.Errorf("error reading 'label': %w", err)
		}
		delete(object, "label")
	}

	if raw, found := object["line-cap"]; found {
		err = json.Unmarshal(raw, &a.LineCap)
		if err != nil {
			return fmt.Errorf("error reading 'line-cap': %w", err)
		}
		delete(object, "line-cap")
	}

	if raw, found := object["line-color"]; found {
		err = json.Unmarshal(raw, &a.LineColor)
		if err != nil {
			return fmt.Errorf("error reading 'line-color': %w", err)
		}
		delete(object, "line-color")
	}

	if raw, found := object["line-opacity"]; found {
		err = json.Unmarshal(raw, &a.LineOpacity)
		if err != nil {
			return fmt.Errorf("error reading 'line-opacity': %w", err)
		}
		delete(object, "line-opacity")
	}

	if raw, found := object["line-style"]; found {
		err = json.Unmarshal(raw, &a.LineStyle)
		if err != nil {
			return fmt.Errorf("error reading 'line-style': %w", err)
		}
		delete(object, "line-style")
	}

	if raw, found := object["mid-target-arrow-color"]; found {
		err = json.Unmarshal(raw, &a.MidTargetArrowColor)
		if err != nil {
			return fmt.Errorf("error reading 'mid-target-arrow-color': %w", err)
		}
		delete(object, "mid-target-arrow-color")
	}

	if raw, found := object["mid-target-arrow-fill"]; found {
		err = json.Unmarshal(raw, &a.MidTargetArrowFill)
		if err != nil {
			return fmt.Errorf("error reading 'mid-target-arrow-fill': %w", err)
		}
		delete(object, "mid-target-arrow-fill")
	}

	if raw, found := object["mid-target-arrow-shape"]; found {
		err = json.Unmarshal(raw, &a.MidTargetArrowShape)
		if err != nil {
			return fmt.Errorf("error reading 'mid-target-arrow-shape': %w", err)
		}
		delete(object, "mid-target-arrow-shape")
	}

	if raw, found := object["opacity"]; found {
		err = json.Unmarshal(raw, &a.Opacity)
		if err != nil {
			return fmt.Errorf("error reading 'opacity': %w", err)
		}
		delete(object, "opacity")
	}

	if raw, found := object["primaryColor"]; found {
		err = json.Unmarshal(raw, &a.PrimaryColor)
		if err != nil {
			return fmt.Errorf("error reading 'primaryColor': %w", err)
		}
		delete(object, "primaryColor")
	}

	if raw, found := object["secondaryColor"]; found {
		err = json.Unmarshal(raw, &a.SecondaryColor)
		if err != nil {
			return fmt.Errorf("error reading 'secondaryColor': %w", err)
		}
		delete(object, "secondaryColor")
	}

	if raw, found := object["source-label"]; found {
		err = json.Unmarshal(raw, &a.SourceLabel)
		if err != nil {
			return fmt.Errorf("error reading 'source-label': %w", err)
		}
		delete(object, "source-label")
	}

	if raw, found := object["svgColor"]; found {
		err = json.Unmarshal(raw, &a.SvgColor)
		if err != nil {
			return fmt.Errorf("error reading 'svgColor': %w", err)
		}
		delete(object, "svgColor")
	}

	if raw, found := object["svgComplete"]; found {
		err = json.Unmarshal(raw, &a.SvgComplete)
		if err != nil {
			return fmt.Errorf("error reading 'svgComplete': %w", err)
		}
		delete(object, "svgComplete")
	}

	if raw, found := object["svgWhite"]; found {
		err = json.Unmarshal(raw, &a.SvgWhite)
		if err != nil {
			return fmt.Errorf("error reading 'svgWhite': %w", err)
		}
		delete(object, "svgWhite")
	}

	if raw, found := object["target-arrow-color"]; found {
		err = json.Unmarshal(raw, &a.TargetArrowColor)
		if err != nil {
			return fmt.Errorf("error reading 'target-arrow-color': %w", err)
		}
		delete(object, "target-arrow-color")
	}

	if raw, found := object["target-arrow-fill"]; found {
		err = json.Unmarshal(raw, &a.TargetArrowFill)
		if err != nil {
			return fmt.Errorf("error reading 'target-arrow-fill': %w", err)
		}
		delete(object, "target-arrow-fill")
	}

	if raw, found := object["target-arrow-shape"]; found {
		err = json.Unmarshal(raw, &a.TargetArrowShape)
		if err != nil {
			return fmt.Errorf("error reading 'target-arrow-shape': %w", err)
		}
		delete(object, "target-arrow-shape")
	}

	if raw, found := object["target-label"]; found {
		err = json.Unmarshal(raw, &a.TargetLabel)
		if err != nil {
			return fmt.Errorf("error reading 'target-label': %w", err)
		}
		delete(object, "target-label")
	}

	if raw, found := object["text-opacity"]; found {
		err = json.Unmarshal(raw, &a.TextOpacity)
		if err != nil {
			return fmt.Errorf("error reading 'text-opacity': %w", err)
		}
		delete(object, "text-opacity")
	}

	if raw, found := object["text-transform"]; found {
		err = json.Unmarshal(raw, &a.TextTransform)
		if err != nil {
			return fmt.Errorf("error reading 'text-transform': %w", err)
		}
		delete(object, "text-transform")
	}

	if raw, found := object["z-index"]; found {
		err = json.Unmarshal(raw, &a.ZIndex)
		if err != nil {
			return fmt.Errorf("error reading 'z-index': %w", err)
		}
		delete(object, "z-index")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for RelationshipDefinitionMetadataStyles0 to handle AdditionalProperties
func (a RelationshipDefinitionMetadataStyles0) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Animation != nil {
		object["animation"], err = json.Marshal(a.Animation)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'animation': %w", err)
		}
	}

	if a.ArrowScale != nil {
		object["arrow-scale"], err = json.Marshal(a.ArrowScale)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'arrow-scale': %w", err)
		}
	}

	if a.Color != nil {
		object["color"], err = json.Marshal(a.Color)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'color': %w", err)
		}
	}

	if a.CurveStyle != nil {
		object["curve-style"], err = json.Marshal(a.CurveStyle)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'curve-style': %w", err)
		}
	}

	if a.EdgeAnimation != nil {
		object["edge-animation"], err = json.Marshal(a.EdgeAnimation)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'edge-animation': %w", err)
		}
	}

	if a.FontFamily != nil {
		object["font-family"], err = json.Marshal(a.FontFamily)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'font-family': %w", err)
		}
	}

	if a.FontSize != nil {
		object["font-size"], err = json.Marshal(a.FontSize)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'font-size': %w", err)
		}
	}

	if a.FontStyle != nil {
		object["font-style"], err = json.Marshal(a.FontStyle)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'font-style': %w", err)
		}
	}

	if a.FontWeight != nil {
		object["font-weight"], err = json.Marshal(a.FontWeight)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'font-weight': %w", err)
		}
	}

	if a.Label != nil {
		object["label"], err = json.Marshal(a.Label)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'label': %w", err)
		}
	}

	if a.LineCap != nil {
		object["line-cap"], err = json.Marshal(a.LineCap)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'line-cap': %w", err)
		}
	}

	if a.LineColor != nil {
		object["line-color"], err = json.Marshal(a.LineColor)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'line-color': %w", err)
		}
	}

	if a.LineOpacity != nil {
		object["line-opacity"], err = json.Marshal(a.LineOpacity)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'line-opacity': %w", err)
		}
	}

	if a.LineStyle != nil {
		object["line-style"], err = json.Marshal(a.LineStyle)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'line-style': %w", err)
		}
	}

	if a.MidTargetArrowColor != nil {
		object["mid-target-arrow-color"], err = json.Marshal(a.MidTargetArrowColor)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'mid-target-arrow-color': %w", err)
		}
	}

	if a.MidTargetArrowFill != nil {
		object["mid-target-arrow-fill"], err = json.Marshal(a.MidTargetArrowFill)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'mid-target-arrow-fill': %w", err)
		}
	}

	if a.MidTargetArrowShape != nil {
		object["mid-target-arrow-shape"], err = json.Marshal(a.MidTargetArrowShape)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'mid-target-arrow-shape': %w", err)
		}
	}

	if a.Opacity != nil {
		object["opacity"], err = json.Marshal(a.Opacity)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'opacity': %w", err)
		}
	}

	object["primaryColor"], err = json.Marshal(a.PrimaryColor)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'primaryColor': %w", err)
	}

	if a.SecondaryColor != nil {
		object["secondaryColor"], err = json.Marshal(a.SecondaryColor)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'secondaryColor': %w", err)
		}
	}

	if a.SourceLabel != nil {
		object["source-label"], err = json.Marshal(a.SourceLabel)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'source-label': %w", err)
		}
	}

	object["svgColor"], err = json.Marshal(a.SvgColor)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'svgColor': %w", err)
	}

	if a.SvgComplete != nil {
		object["svgComplete"], err = json.Marshal(a.SvgComplete)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'svgComplete': %w", err)
		}
	}

	object["svgWhite"], err = json.Marshal(a.SvgWhite)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'svgWhite': %w", err)
	}

	if a.TargetArrowColor != nil {
		object["target-arrow-color"], err = json.Marshal(a.TargetArrowColor)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'target-arrow-color': %w", err)
		}
	}

	if a.TargetArrowFill != nil {
		object["target-arrow-fill"], err = json.Marshal(a.TargetArrowFill)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'target-arrow-fill': %w", err)
		}
	}

	if a.TargetArrowShape != nil {
		object["target-arrow-shape"], err = json.Marshal(a.TargetArrowShape)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'target-arrow-shape': %w", err)
		}
	}

	if a.TargetLabel != nil {
		object["target-label"], err = json.Marshal(a.TargetLabel)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'target-label': %w", err)
		}
	}

	if a.TextOpacity != nil {
		object["text-opacity"], err = json.Marshal(a.TextOpacity)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'text-opacity': %w", err)
		}
	}

	if a.TextTransform != nil {
		object["text-transform"], err = json.Marshal(a.TextTransform)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'text-transform': %w", err)
		}
	}

	if a.ZIndex != nil {
		object["z-index"], err = json.Marshal(a.ZIndex)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'z-index': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for RelationshipDefinitionMetadataStyles1. Returns the specified
// element and whether it was found
func (a RelationshipDefinitionMetadataStyles1) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for RelationshipDefinitionMetadataStyles1
func (a *RelationshipDefinitionMetadataStyles1) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for RelationshipDefinitionMetadataStyles1 to handle AdditionalProperties
func (a *RelationshipDefinitionMetadataStyles1) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["animation"]; found {
		err = json.Unmarshal(raw, &a.Animation)
		if err != nil {
			return fmt.Errorf("error reading 'animation': %w", err)
		}
		delete(object, "animation")
	}

	if raw, found := object["color"]; found {
		err = json.Unmarshal(raw, &a.Color)
		if err != nil {
			return fmt.Errorf("error reading 'color': %w", err)
		}
		delete(object, "color")
	}

	if raw, found := object["font-family"]; found {
		err = json.Unmarshal(raw, &a.FontFamily)
		if err != nil {
			return fmt.Errorf("error reading 'font-family': %w", err)
		}
		delete(object, "font-family")
	}

	if raw, found := object["font-size"]; found {
		err = json.Unmarshal(raw, &a.FontSize)
		if err != nil {
			return fmt.Errorf("error reading 'font-size': %w", err)
		}
		delete(object, "font-size")
	}

	if raw, found := object["font-style"]; found {
		err = json.Unmarshal(raw, &a.FontStyle)
		if err != nil {
			return fmt.Errorf("error reading 'font-style': %w", err)
		}
		delete(object, "font-style")
	}

	if raw, found := object["font-weight"]; found {
		err = json.Unmarshal(raw, &a.FontWeight)
		if err != nil {
			return fmt.Errorf("error reading 'font-weight': %w", err)
		}
		delete(object, "font-weight")
	}

	if raw, found := object["label"]; found {
		err = json.Unmarshal(raw, &a.Label)
		if err != nil {
			return fmt.Errorf("error reading 'label': %w", err)
		}
		delete(object, "label")
	}

	if raw, found := object["opacity"]; found {
		err = json.Unmarshal(raw, &a.Opacity)
		if err != nil {
			return fmt.Errorf("error reading 'opacity': %w", err)
		}
		delete(object, "opacity")
	}

	if raw, found := object["primaryColor"]; found {
		err = json.Unmarshal(raw, &a.PrimaryColor)
		if err != nil {
			return fmt.Errorf("error reading 'primaryColor': %w", err)
		}
		delete(object, "primaryColor")
	}

	if raw, found := object["secondaryColor"]; found {
		err = json.Unmarshal(raw, &a.SecondaryColor)
		if err != nil {
			return fmt.Errorf("error reading 'secondaryColor': %w", err)
		}
		delete(object, "secondaryColor")
	}

	if raw, found := object["svgColor"]; found {
		err = json.Unmarshal(raw, &a.SvgColor)
		if err != nil {
			return fmt.Errorf("error reading 'svgColor': %w", err)
		}
		delete(object, "svgColor")
	}

	if raw, found := object["svgComplete"]; found {
		err = json.Unmarshal(raw, &a.SvgComplete)
		if err != nil {
			return fmt.Errorf("error reading 'svgComplete': %w", err)
		}
		delete(object, "svgComplete")
	}

	if raw, found := object["svgWhite"]; found {
		err = json.Unmarshal(raw, &a.SvgWhite)
		if err != nil {
			return fmt.Errorf("error reading 'svgWhite': %w", err)
		}
		delete(object, "svgWhite")
	}

	if raw, found := object["text-opacity"]; found {
		err = json.Unmarshal(raw, &a.TextOpacity)
		if err != nil {
			return fmt.Errorf("error reading 'text-opacity': %w", err)
		}
		delete(object, "text-opacity")
	}

	if raw, found := object["text-transform"]; found {
		err = json.Unmarshal(raw, &a.TextTransform)
		if err != nil {
			return fmt.Errorf("error reading 'text-transform': %w", err)
		}
		delete(object, "text-transform")
	}

	if raw, found := object["z-index"]; found {
		err = json.Unmarshal(raw, &a.ZIndex)
		if err != nil {
			return fmt.Errorf("error reading 'z-index': %w", err)
		}
		delete(object, "z-index")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for RelationshipDefinitionMetadataStyles1 to handle AdditionalProperties
func (a RelationshipDefinitionMetadataStyles1) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Animation != nil {
		object["animation"], err = json.Marshal(a.Animation)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'animation': %w", err)
		}
	}

	if a.Color != nil {
		object["color"], err = json.Marshal(a.Color)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'color': %w", err)
		}
	}

	if a.FontFamily != nil {
		object["font-family"], err = json.Marshal(a.FontFamily)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'font-family': %w", err)
		}
	}

	if a.FontSize != nil {
		object["font-size"], err = json.Marshal(a.FontSize)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'font-size': %w", err)
		}
	}

	if a.FontStyle != nil {
		object["font-style"], err = json.Marshal(a.FontStyle)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'font-style': %w", err)
		}
	}

	if a.FontWeight != nil {
		object["font-weight"], err = json.Marshal(a.FontWeight)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'font-weight': %w", err)
		}
	}

	if a.Label != nil {
		object["label"], err = json.Marshal(a.Label)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'label': %w", err)
		}
	}

	if a.Opacity != nil {
		object["opacity"], err = json.Marshal(a.Opacity)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'opacity': %w", err)
		}
	}

	object["primaryColor"], err = json.Marshal(a.PrimaryColor)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'primaryColor': %w", err)
	}

	if a.SecondaryColor != nil {
		object["secondaryColor"], err = json.Marshal(a.SecondaryColor)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'secondaryColor': %w", err)
		}
	}

	object["svgColor"], err = json.Marshal(a.SvgColor)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'svgColor': %w", err)
	}

	if a.SvgComplete != nil {
		object["svgComplete"], err = json.Marshal(a.SvgComplete)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'svgComplete': %w", err)
		}
	}

	object["svgWhite"], err = json.Marshal(a.SvgWhite)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'svgWhite': %w", err)
	}

	if a.TextOpacity != nil {
		object["text-opacity"], err = json.Marshal(a.TextOpacity)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'text-opacity': %w", err)
		}
	}

	if a.TextTransform != nil {
		object["text-transform"], err = json.Marshal(a.TextTransform)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'text-transform': %w", err)
		}
	}

	if a.ZIndex != nil {
		object["z-index"], err = json.Marshal(a.ZIndex)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'z-index': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for RelationshipDefinition_Metadata. Returns the specified
// element and whether it was found
func (a RelationshipDefinition_Metadata) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for RelationshipDefinition_Metadata
func (a *RelationshipDefinition_Metadata) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for RelationshipDefinition_Metadata to handle AdditionalProperties
func (a *RelationshipDefinition_Metadata) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["description"]; found {
		err = json.Unmarshal(raw, &a.Description)
		if err != nil {
			return fmt.Errorf("error reading 'description': %w", err)
		}
		delete(object, "description")
	}

	if raw, found := object["isAnnotation"]; found {
		err = json.Unmarshal(raw, &a.IsAnnotation)
		if err != nil {
			return fmt.Errorf("error reading 'isAnnotation': %w", err)
		}
		delete(object, "isAnnotation")
	}

	if raw, found := object["styles"]; found {
		err = json.Unmarshal(raw, &a.Styles)
		if err != nil {
			return fmt.Errorf("error reading 'styles': %w", err)
		}
		delete(object, "styles")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for RelationshipDefinition_Metadata to handle AdditionalProperties
func (a RelationshipDefinition_Metadata) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Description != nil {
		object["description"], err = json.Marshal(a.Description)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'description': %w", err)
		}
	}

	if a.IsAnnotation != nil {
		object["isAnnotation"], err = json.Marshal(a.IsAnnotation)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'isAnnotation': %w", err)
		}
	}

	if a.Styles != nil {
		object["styles"], err = json.Marshal(a.Styles)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'styles': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for RelationshipDefinition_Model_Metadata. Returns the specified
// element and whether it was found
func (a RelationshipDefinition_Model_Metadata) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for RelationshipDefinition_Model_Metadata
func (a *RelationshipDefinition_Model_Metadata) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for RelationshipDefinition_Model_Metadata to handle AdditionalProperties
func (a *RelationshipDefinition_Model_Metadata) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["capabilities"]; found {
		err = json.Unmarshal(raw, &a.Capabilities)
		if err != nil {
			return fmt.Errorf("error reading 'capabilities': %w", err)
		}
		delete(object, "capabilities")
	}

	if raw, found := object["isAnnotation"]; found {
		err = json.Unmarshal(raw, &a.IsAnnotation)
		if err != nil {
			return fmt.Errorf("error reading 'isAnnotation': %w", err)
		}
		delete(object, "isAnnotation")
	}

	if raw, found := object["primaryColor"]; found {
		err = json.Unmarshal(raw, &a.PrimaryColor)
		if err != nil {
			return fmt.Errorf("error reading 'primaryColor': %w", err)
		}
		delete(object, "primaryColor")
	}

	if raw, found := object["secondaryColor"]; found {
		err = json.Unmarshal(raw, &a.SecondaryColor)
		if err != nil {
			return fmt.Errorf("error reading 'secondaryColor': %w", err)
		}
		delete(object, "secondaryColor")
	}

	if raw, found := object["svgWhite"]; found {
		err = json.Unmarshal(raw, &a.SvgWhite)
		if err != nil {
			return fmt.Errorf("error reading 'svgWhite': %w", err)
		}
		delete(object, "svgWhite")
	}

	if raw, found := object["svgColor"]; found {
		err = json.Unmarshal(raw, &a.SvgColor)
		if err != nil {
			return fmt.Errorf("error reading 'svgColor': %w", err)
		}
		delete(object, "svgColor")
	}

	if raw, found := object["svgComplete"]; found {
		err = json.Unmarshal(raw, &a.SvgComplete)
		if err != nil {
			return fmt.Errorf("error reading 'svgComplete': %w", err)
		}
		delete(object, "svgComplete")
	}

	if raw, found := object["shape"]; found {
		err = json.Unmarshal(raw, &a.Shape)
		if err != nil {
			return fmt.Errorf("error reading 'shape': %w", err)
		}
		delete(object, "shape")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for RelationshipDefinition_Model_Metadata to handle AdditionalProperties
func (a RelationshipDefinition_Model_Metadata) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Capabilities != nil {
		object["capabilities"], err = json.Marshal(a.Capabilities)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'capabilities': %w", err)
		}
	}

	if a.IsAnnotation != nil {
		object["isAnnotation"], err = json.Marshal(a.IsAnnotation)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'isAnnotation': %w", err)
		}
	}

	if a.PrimaryColor != nil {
		object["primaryColor"], err = json.Marshal(a.PrimaryColor)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'primaryColor': %w", err)
		}
	}

	if a.SecondaryColor != nil {
		object["secondaryColor"], err = json.Marshal(a.SecondaryColor)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'secondaryColor': %w", err)
		}
	}

	object["svgWhite"], err = json.Marshal(a.SvgWhite)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'svgWhite': %w", err)
	}

	object["svgColor"], err = json.Marshal(a.SvgColor)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'svgColor': %w", err)
	}

	if a.SvgComplete != nil {
		object["svgComplete"], err = json.Marshal(a.SvgComplete)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'svgComplete': %w", err)
		}
	}

	if a.Shape != nil {
		object["shape"], err = json.Marshal(a.Shape)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'shape': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for RelationshipDefinition_Selectors_Allow_From_Model_Metadata. Returns the specified
// element and whether it was found
func (a RelationshipDefinition_Selectors_Allow_From_Model_Metadata) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for RelationshipDefinition_Selectors_Allow_From_Model_Metadata
func (a *RelationshipDefinition_Selectors_Allow_From_Model_Metadata) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for RelationshipDefinition_Selectors_Allow_From_Model_Metadata to handle AdditionalProperties
func (a *RelationshipDefinition_Selectors_Allow_From_Model_Metadata) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["capabilities"]; found {
		err = json.Unmarshal(raw, &a.Capabilities)
		if err != nil {
			return fmt.Errorf("error reading 'capabilities': %w", err)
		}
		delete(object, "capabilities")
	}

	if raw, found := object["isAnnotation"]; found {
		err = json.Unmarshal(raw, &a.IsAnnotation)
		if err != nil {
			return fmt.Errorf("error reading 'isAnnotation': %w", err)
		}
		delete(object, "isAnnotation")
	}

	if raw, found := object["primaryColor"]; found {
		err = json.Unmarshal(raw, &a.PrimaryColor)
		if err != nil {
			return fmt.Errorf("error reading 'primaryColor': %w", err)
		}
		delete(object, "primaryColor")
	}

	if raw, found := object["secondaryColor"]; found {
		err = json.Unmarshal(raw, &a.SecondaryColor)
		if err != nil {
			return fmt.Errorf("error reading 'secondaryColor': %w", err)
		}
		delete(object, "secondaryColor")
	}

	if raw, found := object["svgWhite"]; found {
		err = json.Unmarshal(raw, &a.SvgWhite)
		if err != nil {
			return fmt.Errorf("error reading 'svgWhite': %w", err)
		}
		delete(object, "svgWhite")
	}

	if raw, found := object["svgColor"]; found {
		err = json.Unmarshal(raw, &a.SvgColor)
		if err != nil {
			return fmt.Errorf("error reading 'svgColor': %w", err)
		}
		delete(object, "svgColor")
	}

	if raw, found := object["svgComplete"]; found {
		err = json.Unmarshal(raw, &a.SvgComplete)
		if err != nil {
			return fmt.Errorf("error reading 'svgComplete': %w", err)
		}
		delete(object, "svgComplete")
	}

	if raw, found := object["shape"]; found {
		err = json.Unmarshal(raw, &a.Shape)
		if err != nil {
			return fmt.Errorf("error reading 'shape': %w", err)
		}
		delete(object, "shape")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for RelationshipDefinition_Selectors_Allow_From_Model_Metadata to handle AdditionalProperties
func (a RelationshipDefinition_Selectors_Allow_From_Model_Metadata) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Capabilities != nil {
		object["capabilities"], err = json.Marshal(a.Capabilities)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'capabilities': %w", err)
		}
	}

	if a.IsAnnotation != nil {
		object["isAnnotation"], err = json.Marshal(a.IsAnnotation)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'isAnnotation': %w", err)
		}
	}

	if a.PrimaryColor != nil {
		object["primaryColor"], err = json.Marshal(a.PrimaryColor)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'primaryColor': %w", err)
		}
	}

	if a.SecondaryColor != nil {
		object["secondaryColor"], err = json.Marshal(a.SecondaryColor)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'secondaryColor': %w", err)
		}
	}

	object["svgWhite"], err = json.Marshal(a.SvgWhite)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'svgWhite': %w", err)
	}

	object["svgColor"], err = json.Marshal(a.SvgColor)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'svgColor': %w", err)
	}

	if a.SvgComplete != nil {
		object["svgComplete"], err = json.Marshal(a.SvgComplete)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'svgComplete': %w", err)
		}
	}

	if a.Shape != nil {
		object["shape"], err = json.Marshal(a.Shape)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'shape': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for RelationshipDefinition_Selectors_Allow_To_Model_Metadata. Returns the specified
// element and whether it was found
func (a RelationshipDefinition_Selectors_Allow_To_Model_Metadata) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for RelationshipDefinition_Selectors_Allow_To_Model_Metadata
func (a *RelationshipDefinition_Selectors_Allow_To_Model_Metadata) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for RelationshipDefinition_Selectors_Allow_To_Model_Metadata to handle AdditionalProperties
func (a *RelationshipDefinition_Selectors_Allow_To_Model_Metadata) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["capabilities"]; found {
		err = json.Unmarshal(raw, &a.Capabilities)
		if err != nil {
			return fmt.Errorf("error reading 'capabilities': %w", err)
		}
		delete(object, "capabilities")
	}

	if raw, found := object["isAnnotation"]; found {
		err = json.Unmarshal(raw, &a.IsAnnotation)
		if err != nil {
			return fmt.Errorf("error reading 'isAnnotation': %w", err)
		}
		delete(object, "isAnnotation")
	}

	if raw, found := object["primaryColor"]; found {
		err = json.Unmarshal(raw, &a.PrimaryColor)
		if err != nil {
			return fmt.Errorf("error reading 'primaryColor': %w", err)
		}
		delete(object, "primaryColor")
	}

	if raw, found := object["secondaryColor"]; found {
		err = json.Unmarshal(raw, &a.SecondaryColor)
		if err != nil {
			return fmt.Errorf("error reading 'secondaryColor': %w", err)
		}
		delete(object, "secondaryColor")
	}

	if raw, found := object["svgWhite"]; found {
		err = json.Unmarshal(raw, &a.SvgWhite)
		if err != nil {
			return fmt.Errorf("error reading 'svgWhite': %w", err)
		}
		delete(object, "svgWhite")
	}

	if raw, found := object["svgColor"]; found {
		err = json.Unmarshal(raw, &a.SvgColor)
		if err != nil {
			return fmt.Errorf("error reading 'svgColor': %w", err)
		}
		delete(object, "svgColor")
	}

	if raw, found := object["svgComplete"]; found {
		err = json.Unmarshal(raw, &a.SvgComplete)
		if err != nil {
			return fmt.Errorf("error reading 'svgComplete': %w", err)
		}
		delete(object, "svgComplete")
	}

	if raw, found := object["shape"]; found {
		err = json.Unmarshal(raw, &a.Shape)
		if err != nil {
			return fmt.Errorf("error reading 'shape': %w", err)
		}
		delete(object, "shape")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for RelationshipDefinition_Selectors_Allow_To_Model_Metadata to handle AdditionalProperties
func (a RelationshipDefinition_Selectors_Allow_To_Model_Metadata) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Capabilities != nil {
		object["capabilities"], err = json.Marshal(a.Capabilities)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'capabilities': %w", err)
		}
	}

	if a.IsAnnotation != nil {
		object["isAnnotation"], err = json.Marshal(a.IsAnnotation)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'isAnnotation': %w", err)
		}
	}

	if a.PrimaryColor != nil {
		object["primaryColor"], err = json.Marshal(a.PrimaryColor)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'primaryColor': %w", err)
		}
	}

	if a.SecondaryColor != nil {
		object["secondaryColor"], err = json.Marshal(a.SecondaryColor)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'secondaryColor': %w", err)
		}
	}

	object["svgWhite"], err = json.Marshal(a.SvgWhite)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'svgWhite': %w", err)
	}

	object["svgColor"], err = json.Marshal(a.SvgColor)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'svgColor': %w", err)
	}

	if a.SvgComplete != nil {
		object["svgComplete"], err = json.Marshal(a.SvgComplete)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'svgComplete': %w", err)
		}
	}

	if a.Shape != nil {
		object["shape"], err = json.Marshal(a.Shape)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'shape': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for RelationshipDefinition_Selectors_Deny_From_Model_Metadata. Returns the specified
// element and whether it was found
func (a RelationshipDefinition_Selectors_Deny_From_Model_Metadata) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for RelationshipDefinition_Selectors_Deny_From_Model_Metadata
func (a *RelationshipDefinition_Selectors_Deny_From_Model_Metadata) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for RelationshipDefinition_Selectors_Deny_From_Model_Metadata to handle AdditionalProperties
func (a *RelationshipDefinition_Selectors_Deny_From_Model_Metadata) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["capabilities"]; found {
		err = json.Unmarshal(raw, &a.Capabilities)
		if err != nil {
			return fmt.Errorf("error reading 'capabilities': %w", err)
		}
		delete(object, "capabilities")
	}

	if raw, found := object["isAnnotation"]; found {
		err = json.Unmarshal(raw, &a.IsAnnotation)
		if err != nil {
			return fmt.Errorf("error reading 'isAnnotation': %w", err)
		}
		delete(object, "isAnnotation")
	}

	if raw, found := object["primaryColor"]; found {
		err = json.Unmarshal(raw, &a.PrimaryColor)
		if err != nil {
			return fmt.Errorf("error reading 'primaryColor': %w", err)
		}
		delete(object, "primaryColor")
	}

	if raw, found := object["secondaryColor"]; found {
		err = json.Unmarshal(raw, &a.SecondaryColor)
		if err != nil {
			return fmt.Errorf("error reading 'secondaryColor': %w", err)
		}
		delete(object, "secondaryColor")
	}

	if raw, found := object["svgWhite"]; found {
		err = json.Unmarshal(raw, &a.SvgWhite)
		if err != nil {
			return fmt.Errorf("error reading 'svgWhite': %w", err)
		}
		delete(object, "svgWhite")
	}

	if raw, found := object["svgColor"]; found {
		err = json.Unmarshal(raw, &a.SvgColor)
		if err != nil {
			return fmt.Errorf("error reading 'svgColor': %w", err)
		}
		delete(object, "svgColor")
	}

	if raw, found := object["svgComplete"]; found {
		err = json.Unmarshal(raw, &a.SvgComplete)
		if err != nil {
			return fmt.Errorf("error reading 'svgComplete': %w", err)
		}
		delete(object, "svgComplete")
	}

	if raw, found := object["shape"]; found {
		err = json.Unmarshal(raw, &a.Shape)
		if err != nil {
			return fmt.Errorf("error reading 'shape': %w", err)
		}
		delete(object, "shape")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for RelationshipDefinition_Selectors_Deny_From_Model_Metadata to handle AdditionalProperties
func (a RelationshipDefinition_Selectors_Deny_From_Model_Metadata) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Capabilities != nil {
		object["capabilities"], err = json.Marshal(a.Capabilities)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'capabilities': %w", err)
		}
	}

	if a.IsAnnotation != nil {
		object["isAnnotation"], err = json.Marshal(a.IsAnnotation)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'isAnnotation': %w", err)
		}
	}

	if a.PrimaryColor != nil {
		object["primaryColor"], err = json.Marshal(a.PrimaryColor)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'primaryColor': %w", err)
		}
	}

	if a.SecondaryColor != nil {
		object["secondaryColor"], err = json.Marshal(a.SecondaryColor)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'secondaryColor': %w", err)
		}
	}

	object["svgWhite"], err = json.Marshal(a.SvgWhite)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'svgWhite': %w", err)
	}

	object["svgColor"], err = json.Marshal(a.SvgColor)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'svgColor': %w", err)
	}

	if a.SvgComplete != nil {
		object["svgComplete"], err = json.Marshal(a.SvgComplete)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'svgComplete': %w", err)
		}
	}

	if a.Shape != nil {
		object["shape"], err = json.Marshal(a.Shape)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'shape': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for RelationshipDefinition_Selectors_Deny_To_Model_Metadata. Returns the specified
// element and whether it was found
func (a RelationshipDefinition_Selectors_Deny_To_Model_Metadata) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for RelationshipDefinition_Selectors_Deny_To_Model_Metadata
func (a *RelationshipDefinition_Selectors_Deny_To_Model_Metadata) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for RelationshipDefinition_Selectors_Deny_To_Model_Metadata to handle AdditionalProperties
func (a *RelationshipDefinition_Selectors_Deny_To_Model_Metadata) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["capabilities"]; found {
		err = json.Unmarshal(raw, &a.Capabilities)
		if err != nil {
			return fmt.Errorf("error reading 'capabilities': %w", err)
		}
		delete(object, "capabilities")
	}

	if raw, found := object["isAnnotation"]; found {
		err = json.Unmarshal(raw, &a.IsAnnotation)
		if err != nil {
			return fmt.Errorf("error reading 'isAnnotation': %w", err)
		}
		delete(object, "isAnnotation")
	}

	if raw, found := object["primaryColor"]; found {
		err = json.Unmarshal(raw, &a.PrimaryColor)
		if err != nil {
			return fmt.Errorf("error reading 'primaryColor': %w", err)
		}
		delete(object, "primaryColor")
	}

	if raw, found := object["secondaryColor"]; found {
		err = json.Unmarshal(raw, &a.SecondaryColor)
		if err != nil {
			return fmt.Errorf("error reading 'secondaryColor': %w", err)
		}
		delete(object, "secondaryColor")
	}

	if raw, found := object["svgWhite"]; found {
		err = json.Unmarshal(raw, &a.SvgWhite)
		if err != nil {
			return fmt.Errorf("error reading 'svgWhite': %w", err)
		}
		delete(object, "svgWhite")
	}

	if raw, found := object["svgColor"]; found {
		err = json.Unmarshal(raw, &a.SvgColor)
		if err != nil {
			return fmt.Errorf("error reading 'svgColor': %w", err)
		}
		delete(object, "svgColor")
	}

	if raw, found := object["svgComplete"]; found {
		err = json.Unmarshal(raw, &a.SvgComplete)
		if err != nil {
			return fmt.Errorf("error reading 'svgComplete': %w", err)
		}
		delete(object, "svgComplete")
	}

	if raw, found := object["shape"]; found {
		err = json.Unmarshal(raw, &a.Shape)
		if err != nil {
			return fmt.Errorf("error reading 'shape': %w", err)
		}
		delete(object, "shape")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for RelationshipDefinition_Selectors_Deny_To_Model_Metadata to handle AdditionalProperties
func (a RelationshipDefinition_Selectors_Deny_To_Model_Metadata) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Capabilities != nil {
		object["capabilities"], err = json.Marshal(a.Capabilities)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'capabilities': %w", err)
		}
	}

	if a.IsAnnotation != nil {
		object["isAnnotation"], err = json.Marshal(a.IsAnnotation)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'isAnnotation': %w", err)
		}
	}

	if a.PrimaryColor != nil {
		object["primaryColor"], err = json.Marshal(a.PrimaryColor)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'primaryColor': %w", err)
		}
	}

	if a.SecondaryColor != nil {
		object["secondaryColor"], err = json.Marshal(a.SecondaryColor)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'secondaryColor': %w", err)
		}
	}

	object["svgWhite"], err = json.Marshal(a.SvgWhite)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'svgWhite': %w", err)
	}

	object["svgColor"], err = json.Marshal(a.SvgColor)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'svgColor': %w", err)
	}

	if a.SvgComplete != nil {
		object["svgComplete"], err = json.Marshal(a.SvgComplete)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'svgComplete': %w", err)
		}
	}

	if a.Shape != nil {
		object["shape"], err = json.Marshal(a.Shape)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'shape': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// AsRelationshipDefinitionMetadataStyles0 returns the union data inside the RelationshipDefinition_Metadata_Styles as a RelationshipDefinitionMetadataStyles0
func (t RelationshipDefinition_Metadata_Styles) AsRelationshipDefinitionMetadataStyles0() (RelationshipDefinitionMetadataStyles0, error) {
	var body RelationshipDefinitionMetadataStyles0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRelationshipDefinitionMetadataStyles0 overwrites any union data inside the RelationshipDefinition_Metadata_Styles as the provided RelationshipDefinitionMetadataStyles0
func (t *RelationshipDefinition_Metadata_Styles) FromRelationshipDefinitionMetadataStyles0(v RelationshipDefinitionMetadataStyles0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRelationshipDefinitionMetadataStyles0 performs a merge with any union data inside the RelationshipDefinition_Metadata_Styles, using the provided RelationshipDefinitionMetadataStyles0
func (t *RelationshipDefinition_Metadata_Styles) MergeRelationshipDefinitionMetadataStyles0(v RelationshipDefinitionMetadataStyles0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRelationshipDefinitionMetadataStyles1 returns the union data inside the RelationshipDefinition_Metadata_Styles as a RelationshipDefinitionMetadataStyles1
func (t RelationshipDefinition_Metadata_Styles) AsRelationshipDefinitionMetadataStyles1() (RelationshipDefinitionMetadataStyles1, error) {
	var body RelationshipDefinitionMetadataStyles1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRelationshipDefinitionMetadataStyles1 overwrites any union data inside the RelationshipDefinition_Metadata_Styles as the provided RelationshipDefinitionMetadataStyles1
func (t *RelationshipDefinition_Metadata_Styles) FromRelationshipDefinitionMetadataStyles1(v RelationshipDefinitionMetadataStyles1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRelationshipDefinitionMetadataStyles1 performs a merge with any union data inside the RelationshipDefinition_Metadata_Styles, using the provided RelationshipDefinitionMetadataStyles1
func (t *RelationshipDefinition_Metadata_Styles) MergeRelationshipDefinitionMetadataStyles1(v RelationshipDefinitionMetadataStyles1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t RelationshipDefinition_Metadata_Styles) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *RelationshipDefinition_Metadata_Styles) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsRelationshipDefinitionSelectorsAllowFromMatch1From0 returns the union data inside the RelationshipDefinition_Selectors_Allow_From_Match_1_From_Item as a RelationshipDefinitionSelectorsAllowFromMatch1From0
func (t RelationshipDefinition_Selectors_Allow_From_Match_1_From_Item) AsRelationshipDefinitionSelectorsAllowFromMatch1From0() (RelationshipDefinitionSelectorsAllowFromMatch1From0, error) {
	var body RelationshipDefinitionSelectorsAllowFromMatch1From0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRelationshipDefinitionSelectorsAllowFromMatch1From0 overwrites any union data inside the RelationshipDefinition_Selectors_Allow_From_Match_1_From_Item as the provided RelationshipDefinitionSelectorsAllowFromMatch1From0
func (t *RelationshipDefinition_Selectors_Allow_From_Match_1_From_Item) FromRelationshipDefinitionSelectorsAllowFromMatch1From0(v RelationshipDefinitionSelectorsAllowFromMatch1From0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRelationshipDefinitionSelectorsAllowFromMatch1From0 performs a merge with any union data inside the RelationshipDefinition_Selectors_Allow_From_Match_1_From_Item, using the provided RelationshipDefinitionSelectorsAllowFromMatch1From0
func (t *RelationshipDefinition_Selectors_Allow_From_Match_1_From_Item) MergeRelationshipDefinitionSelectorsAllowFromMatch1From0(v RelationshipDefinitionSelectorsAllowFromMatch1From0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRelationshipDefinitionSelectorsAllowFromMatch1From1 returns the union data inside the RelationshipDefinition_Selectors_Allow_From_Match_1_From_Item as a RelationshipDefinitionSelectorsAllowFromMatch1From1
func (t RelationshipDefinition_Selectors_Allow_From_Match_1_From_Item) AsRelationshipDefinitionSelectorsAllowFromMatch1From1() (RelationshipDefinitionSelectorsAllowFromMatch1From1, error) {
	var body RelationshipDefinitionSelectorsAllowFromMatch1From1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRelationshipDefinitionSelectorsAllowFromMatch1From1 overwrites any union data inside the RelationshipDefinition_Selectors_Allow_From_Match_1_From_Item as the provided RelationshipDefinitionSelectorsAllowFromMatch1From1
func (t *RelationshipDefinition_Selectors_Allow_From_Match_1_From_Item) FromRelationshipDefinitionSelectorsAllowFromMatch1From1(v RelationshipDefinitionSelectorsAllowFromMatch1From1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRelationshipDefinitionSelectorsAllowFromMatch1From1 performs a merge with any union data inside the RelationshipDefinition_Selectors_Allow_From_Match_1_From_Item, using the provided RelationshipDefinitionSelectorsAllowFromMatch1From1
func (t *RelationshipDefinition_Selectors_Allow_From_Match_1_From_Item) MergeRelationshipDefinitionSelectorsAllowFromMatch1From1(v RelationshipDefinitionSelectorsAllowFromMatch1From1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t RelationshipDefinition_Selectors_Allow_From_Match_1_From_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.Id != nil {
		object["id"], err = json.Marshal(t.Id)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'id': %w", err)
		}
	}

	if t.Kind != nil {
		object["kind"], err = json.Marshal(t.Kind)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'kind': %w", err)
		}
	}
	b, err = json.Marshal(object)
	return b, err
}

func (t *RelationshipDefinition_Selectors_Allow_From_Match_1_From_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &t.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
	}

	if raw, found := object["kind"]; found {
		err = json.Unmarshal(raw, &t.Kind)
		if err != nil {
			return fmt.Errorf("error reading 'kind': %w", err)
		}
	}

	return err
}

// AsRelationshipDefinitionSelectorsAllowFromMatch1To0 returns the union data inside the RelationshipDefinition_Selectors_Allow_From_Match_1_To_Item as a RelationshipDefinitionSelectorsAllowFromMatch1To0
func (t RelationshipDefinition_Selectors_Allow_From_Match_1_To_Item) AsRelationshipDefinitionSelectorsAllowFromMatch1To0() (RelationshipDefinitionSelectorsAllowFromMatch1To0, error) {
	var body RelationshipDefinitionSelectorsAllowFromMatch1To0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRelationshipDefinitionSelectorsAllowFromMatch1To0 overwrites any union data inside the RelationshipDefinition_Selectors_Allow_From_Match_1_To_Item as the provided RelationshipDefinitionSelectorsAllowFromMatch1To0
func (t *RelationshipDefinition_Selectors_Allow_From_Match_1_To_Item) FromRelationshipDefinitionSelectorsAllowFromMatch1To0(v RelationshipDefinitionSelectorsAllowFromMatch1To0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRelationshipDefinitionSelectorsAllowFromMatch1To0 performs a merge with any union data inside the RelationshipDefinition_Selectors_Allow_From_Match_1_To_Item, using the provided RelationshipDefinitionSelectorsAllowFromMatch1To0
func (t *RelationshipDefinition_Selectors_Allow_From_Match_1_To_Item) MergeRelationshipDefinitionSelectorsAllowFromMatch1To0(v RelationshipDefinitionSelectorsAllowFromMatch1To0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRelationshipDefinitionSelectorsAllowFromMatch1To1 returns the union data inside the RelationshipDefinition_Selectors_Allow_From_Match_1_To_Item as a RelationshipDefinitionSelectorsAllowFromMatch1To1
func (t RelationshipDefinition_Selectors_Allow_From_Match_1_To_Item) AsRelationshipDefinitionSelectorsAllowFromMatch1To1() (RelationshipDefinitionSelectorsAllowFromMatch1To1, error) {
	var body RelationshipDefinitionSelectorsAllowFromMatch1To1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRelationshipDefinitionSelectorsAllowFromMatch1To1 overwrites any union data inside the RelationshipDefinition_Selectors_Allow_From_Match_1_To_Item as the provided RelationshipDefinitionSelectorsAllowFromMatch1To1
func (t *RelationshipDefinition_Selectors_Allow_From_Match_1_To_Item) FromRelationshipDefinitionSelectorsAllowFromMatch1To1(v RelationshipDefinitionSelectorsAllowFromMatch1To1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRelationshipDefinitionSelectorsAllowFromMatch1To1 performs a merge with any union data inside the RelationshipDefinition_Selectors_Allow_From_Match_1_To_Item, using the provided RelationshipDefinitionSelectorsAllowFromMatch1To1
func (t *RelationshipDefinition_Selectors_Allow_From_Match_1_To_Item) MergeRelationshipDefinitionSelectorsAllowFromMatch1To1(v RelationshipDefinitionSelectorsAllowFromMatch1To1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t RelationshipDefinition_Selectors_Allow_From_Match_1_To_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.Id != nil {
		object["id"], err = json.Marshal(t.Id)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'id': %w", err)
		}
	}

	if t.Kind != nil {
		object["kind"], err = json.Marshal(t.Kind)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'kind': %w", err)
		}
	}
	b, err = json.Marshal(object)
	return b, err
}

func (t *RelationshipDefinition_Selectors_Allow_From_Match_1_To_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &t.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
	}

	if raw, found := object["kind"]; found {
		err = json.Unmarshal(raw, &t.Kind)
		if err != nil {
			return fmt.Errorf("error reading 'kind': %w", err)
		}
	}

	return err
}

// AsRelationshipDefinitionSelectorsAllowFromMatch0 returns the union data inside the RelationshipDefinition_Selectors_Allow_From_Match as a RelationshipDefinitionSelectorsAllowFromMatch0
func (t RelationshipDefinition_Selectors_Allow_From_Match) AsRelationshipDefinitionSelectorsAllowFromMatch0() (RelationshipDefinitionSelectorsAllowFromMatch0, error) {
	var body RelationshipDefinitionSelectorsAllowFromMatch0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRelationshipDefinitionSelectorsAllowFromMatch0 overwrites any union data inside the RelationshipDefinition_Selectors_Allow_From_Match as the provided RelationshipDefinitionSelectorsAllowFromMatch0
func (t *RelationshipDefinition_Selectors_Allow_From_Match) FromRelationshipDefinitionSelectorsAllowFromMatch0(v RelationshipDefinitionSelectorsAllowFromMatch0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRelationshipDefinitionSelectorsAllowFromMatch0 performs a merge with any union data inside the RelationshipDefinition_Selectors_Allow_From_Match, using the provided RelationshipDefinitionSelectorsAllowFromMatch0
func (t *RelationshipDefinition_Selectors_Allow_From_Match) MergeRelationshipDefinitionSelectorsAllowFromMatch0(v RelationshipDefinitionSelectorsAllowFromMatch0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRelationshipDefinitionSelectorsAllowFromMatch1 returns the union data inside the RelationshipDefinition_Selectors_Allow_From_Match as a RelationshipDefinitionSelectorsAllowFromMatch1
func (t RelationshipDefinition_Selectors_Allow_From_Match) AsRelationshipDefinitionSelectorsAllowFromMatch1() (RelationshipDefinitionSelectorsAllowFromMatch1, error) {
	var body RelationshipDefinitionSelectorsAllowFromMatch1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRelationshipDefinitionSelectorsAllowFromMatch1 overwrites any union data inside the RelationshipDefinition_Selectors_Allow_From_Match as the provided RelationshipDefinitionSelectorsAllowFromMatch1
func (t *RelationshipDefinition_Selectors_Allow_From_Match) FromRelationshipDefinitionSelectorsAllowFromMatch1(v RelationshipDefinitionSelectorsAllowFromMatch1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRelationshipDefinitionSelectorsAllowFromMatch1 performs a merge with any union data inside the RelationshipDefinition_Selectors_Allow_From_Match, using the provided RelationshipDefinitionSelectorsAllowFromMatch1
func (t *RelationshipDefinition_Selectors_Allow_From_Match) MergeRelationshipDefinitionSelectorsAllowFromMatch1(v RelationshipDefinitionSelectorsAllowFromMatch1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t RelationshipDefinition_Selectors_Allow_From_Match) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *RelationshipDefinition_Selectors_Allow_From_Match) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsRelationshipDefinitionSelectorsAllowFromPatch0 returns the union data inside the RelationshipDefinition_Selectors_Allow_From_Patch as a RelationshipDefinitionSelectorsAllowFromPatch0
func (t RelationshipDefinition_Selectors_Allow_From_Patch) AsRelationshipDefinitionSelectorsAllowFromPatch0() (RelationshipDefinitionSelectorsAllowFromPatch0, error) {
	var body RelationshipDefinitionSelectorsAllowFromPatch0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRelationshipDefinitionSelectorsAllowFromPatch0 overwrites any union data inside the RelationshipDefinition_Selectors_Allow_From_Patch as the provided RelationshipDefinitionSelectorsAllowFromPatch0
func (t *RelationshipDefinition_Selectors_Allow_From_Patch) FromRelationshipDefinitionSelectorsAllowFromPatch0(v RelationshipDefinitionSelectorsAllowFromPatch0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRelationshipDefinitionSelectorsAllowFromPatch0 performs a merge with any union data inside the RelationshipDefinition_Selectors_Allow_From_Patch, using the provided RelationshipDefinitionSelectorsAllowFromPatch0
func (t *RelationshipDefinition_Selectors_Allow_From_Patch) MergeRelationshipDefinitionSelectorsAllowFromPatch0(v RelationshipDefinitionSelectorsAllowFromPatch0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRelationshipDefinitionSelectorsAllowFromPatch1 returns the union data inside the RelationshipDefinition_Selectors_Allow_From_Patch as a RelationshipDefinitionSelectorsAllowFromPatch1
func (t RelationshipDefinition_Selectors_Allow_From_Patch) AsRelationshipDefinitionSelectorsAllowFromPatch1() (RelationshipDefinitionSelectorsAllowFromPatch1, error) {
	var body RelationshipDefinitionSelectorsAllowFromPatch1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRelationshipDefinitionSelectorsAllowFromPatch1 overwrites any union data inside the RelationshipDefinition_Selectors_Allow_From_Patch as the provided RelationshipDefinitionSelectorsAllowFromPatch1
func (t *RelationshipDefinition_Selectors_Allow_From_Patch) FromRelationshipDefinitionSelectorsAllowFromPatch1(v RelationshipDefinitionSelectorsAllowFromPatch1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRelationshipDefinitionSelectorsAllowFromPatch1 performs a merge with any union data inside the RelationshipDefinition_Selectors_Allow_From_Patch, using the provided RelationshipDefinitionSelectorsAllowFromPatch1
func (t *RelationshipDefinition_Selectors_Allow_From_Patch) MergeRelationshipDefinitionSelectorsAllowFromPatch1(v RelationshipDefinitionSelectorsAllowFromPatch1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t RelationshipDefinition_Selectors_Allow_From_Patch) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.PatchStrategy != nil {
		object["patchStrategy"], err = json.Marshal(t.PatchStrategy)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'patchStrategy': %w", err)
		}
	}
	b, err = json.Marshal(object)
	return b, err
}

func (t *RelationshipDefinition_Selectors_Allow_From_Patch) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["patchStrategy"]; found {
		err = json.Unmarshal(raw, &t.PatchStrategy)
		if err != nil {
			return fmt.Errorf("error reading 'patchStrategy': %w", err)
		}
	}

	return err
}

// AsRelationshipDefinitionSelectorsAllowToMatch1From0 returns the union data inside the RelationshipDefinition_Selectors_Allow_To_Match_1_From_Item as a RelationshipDefinitionSelectorsAllowToMatch1From0
func (t RelationshipDefinition_Selectors_Allow_To_Match_1_From_Item) AsRelationshipDefinitionSelectorsAllowToMatch1From0() (RelationshipDefinitionSelectorsAllowToMatch1From0, error) {
	var body RelationshipDefinitionSelectorsAllowToMatch1From0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRelationshipDefinitionSelectorsAllowToMatch1From0 overwrites any union data inside the RelationshipDefinition_Selectors_Allow_To_Match_1_From_Item as the provided RelationshipDefinitionSelectorsAllowToMatch1From0
func (t *RelationshipDefinition_Selectors_Allow_To_Match_1_From_Item) FromRelationshipDefinitionSelectorsAllowToMatch1From0(v RelationshipDefinitionSelectorsAllowToMatch1From0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRelationshipDefinitionSelectorsAllowToMatch1From0 performs a merge with any union data inside the RelationshipDefinition_Selectors_Allow_To_Match_1_From_Item, using the provided RelationshipDefinitionSelectorsAllowToMatch1From0
func (t *RelationshipDefinition_Selectors_Allow_To_Match_1_From_Item) MergeRelationshipDefinitionSelectorsAllowToMatch1From0(v RelationshipDefinitionSelectorsAllowToMatch1From0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRelationshipDefinitionSelectorsAllowToMatch1From1 returns the union data inside the RelationshipDefinition_Selectors_Allow_To_Match_1_From_Item as a RelationshipDefinitionSelectorsAllowToMatch1From1
func (t RelationshipDefinition_Selectors_Allow_To_Match_1_From_Item) AsRelationshipDefinitionSelectorsAllowToMatch1From1() (RelationshipDefinitionSelectorsAllowToMatch1From1, error) {
	var body RelationshipDefinitionSelectorsAllowToMatch1From1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRelationshipDefinitionSelectorsAllowToMatch1From1 overwrites any union data inside the RelationshipDefinition_Selectors_Allow_To_Match_1_From_Item as the provided RelationshipDefinitionSelectorsAllowToMatch1From1
func (t *RelationshipDefinition_Selectors_Allow_To_Match_1_From_Item) FromRelationshipDefinitionSelectorsAllowToMatch1From1(v RelationshipDefinitionSelectorsAllowToMatch1From1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRelationshipDefinitionSelectorsAllowToMatch1From1 performs a merge with any union data inside the RelationshipDefinition_Selectors_Allow_To_Match_1_From_Item, using the provided RelationshipDefinitionSelectorsAllowToMatch1From1
func (t *RelationshipDefinition_Selectors_Allow_To_Match_1_From_Item) MergeRelationshipDefinitionSelectorsAllowToMatch1From1(v RelationshipDefinitionSelectorsAllowToMatch1From1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t RelationshipDefinition_Selectors_Allow_To_Match_1_From_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.Id != nil {
		object["id"], err = json.Marshal(t.Id)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'id': %w", err)
		}
	}

	if t.Kind != nil {
		object["kind"], err = json.Marshal(t.Kind)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'kind': %w", err)
		}
	}
	b, err = json.Marshal(object)
	return b, err
}

func (t *RelationshipDefinition_Selectors_Allow_To_Match_1_From_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &t.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
	}

	if raw, found := object["kind"]; found {
		err = json.Unmarshal(raw, &t.Kind)
		if err != nil {
			return fmt.Errorf("error reading 'kind': %w", err)
		}
	}

	return err
}

// AsRelationshipDefinitionSelectorsAllowToMatch1To0 returns the union data inside the RelationshipDefinition_Selectors_Allow_To_Match_1_To_Item as a RelationshipDefinitionSelectorsAllowToMatch1To0
func (t RelationshipDefinition_Selectors_Allow_To_Match_1_To_Item) AsRelationshipDefinitionSelectorsAllowToMatch1To0() (RelationshipDefinitionSelectorsAllowToMatch1To0, error) {
	var body RelationshipDefinitionSelectorsAllowToMatch1To0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRelationshipDefinitionSelectorsAllowToMatch1To0 overwrites any union data inside the RelationshipDefinition_Selectors_Allow_To_Match_1_To_Item as the provided RelationshipDefinitionSelectorsAllowToMatch1To0
func (t *RelationshipDefinition_Selectors_Allow_To_Match_1_To_Item) FromRelationshipDefinitionSelectorsAllowToMatch1To0(v RelationshipDefinitionSelectorsAllowToMatch1To0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRelationshipDefinitionSelectorsAllowToMatch1To0 performs a merge with any union data inside the RelationshipDefinition_Selectors_Allow_To_Match_1_To_Item, using the provided RelationshipDefinitionSelectorsAllowToMatch1To0
func (t *RelationshipDefinition_Selectors_Allow_To_Match_1_To_Item) MergeRelationshipDefinitionSelectorsAllowToMatch1To0(v RelationshipDefinitionSelectorsAllowToMatch1To0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRelationshipDefinitionSelectorsAllowToMatch1To1 returns the union data inside the RelationshipDefinition_Selectors_Allow_To_Match_1_To_Item as a RelationshipDefinitionSelectorsAllowToMatch1To1
func (t RelationshipDefinition_Selectors_Allow_To_Match_1_To_Item) AsRelationshipDefinitionSelectorsAllowToMatch1To1() (RelationshipDefinitionSelectorsAllowToMatch1To1, error) {
	var body RelationshipDefinitionSelectorsAllowToMatch1To1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRelationshipDefinitionSelectorsAllowToMatch1To1 overwrites any union data inside the RelationshipDefinition_Selectors_Allow_To_Match_1_To_Item as the provided RelationshipDefinitionSelectorsAllowToMatch1To1
func (t *RelationshipDefinition_Selectors_Allow_To_Match_1_To_Item) FromRelationshipDefinitionSelectorsAllowToMatch1To1(v RelationshipDefinitionSelectorsAllowToMatch1To1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRelationshipDefinitionSelectorsAllowToMatch1To1 performs a merge with any union data inside the RelationshipDefinition_Selectors_Allow_To_Match_1_To_Item, using the provided RelationshipDefinitionSelectorsAllowToMatch1To1
func (t *RelationshipDefinition_Selectors_Allow_To_Match_1_To_Item) MergeRelationshipDefinitionSelectorsAllowToMatch1To1(v RelationshipDefinitionSelectorsAllowToMatch1To1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t RelationshipDefinition_Selectors_Allow_To_Match_1_To_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.Id != nil {
		object["id"], err = json.Marshal(t.Id)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'id': %w", err)
		}
	}

	if t.Kind != nil {
		object["kind"], err = json.Marshal(t.Kind)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'kind': %w", err)
		}
	}
	b, err = json.Marshal(object)
	return b, err
}

func (t *RelationshipDefinition_Selectors_Allow_To_Match_1_To_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &t.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
	}

	if raw, found := object["kind"]; found {
		err = json.Unmarshal(raw, &t.Kind)
		if err != nil {
			return fmt.Errorf("error reading 'kind': %w", err)
		}
	}

	return err
}

// AsRelationshipDefinitionSelectorsAllowToMatch0 returns the union data inside the RelationshipDefinition_Selectors_Allow_To_Match as a RelationshipDefinitionSelectorsAllowToMatch0
func (t RelationshipDefinition_Selectors_Allow_To_Match) AsRelationshipDefinitionSelectorsAllowToMatch0() (RelationshipDefinitionSelectorsAllowToMatch0, error) {
	var body RelationshipDefinitionSelectorsAllowToMatch0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRelationshipDefinitionSelectorsAllowToMatch0 overwrites any union data inside the RelationshipDefinition_Selectors_Allow_To_Match as the provided RelationshipDefinitionSelectorsAllowToMatch0
func (t *RelationshipDefinition_Selectors_Allow_To_Match) FromRelationshipDefinitionSelectorsAllowToMatch0(v RelationshipDefinitionSelectorsAllowToMatch0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRelationshipDefinitionSelectorsAllowToMatch0 performs a merge with any union data inside the RelationshipDefinition_Selectors_Allow_To_Match, using the provided RelationshipDefinitionSelectorsAllowToMatch0
func (t *RelationshipDefinition_Selectors_Allow_To_Match) MergeRelationshipDefinitionSelectorsAllowToMatch0(v RelationshipDefinitionSelectorsAllowToMatch0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRelationshipDefinitionSelectorsAllowToMatch1 returns the union data inside the RelationshipDefinition_Selectors_Allow_To_Match as a RelationshipDefinitionSelectorsAllowToMatch1
func (t RelationshipDefinition_Selectors_Allow_To_Match) AsRelationshipDefinitionSelectorsAllowToMatch1() (RelationshipDefinitionSelectorsAllowToMatch1, error) {
	var body RelationshipDefinitionSelectorsAllowToMatch1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRelationshipDefinitionSelectorsAllowToMatch1 overwrites any union data inside the RelationshipDefinition_Selectors_Allow_To_Match as the provided RelationshipDefinitionSelectorsAllowToMatch1
func (t *RelationshipDefinition_Selectors_Allow_To_Match) FromRelationshipDefinitionSelectorsAllowToMatch1(v RelationshipDefinitionSelectorsAllowToMatch1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRelationshipDefinitionSelectorsAllowToMatch1 performs a merge with any union data inside the RelationshipDefinition_Selectors_Allow_To_Match, using the provided RelationshipDefinitionSelectorsAllowToMatch1
func (t *RelationshipDefinition_Selectors_Allow_To_Match) MergeRelationshipDefinitionSelectorsAllowToMatch1(v RelationshipDefinitionSelectorsAllowToMatch1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t RelationshipDefinition_Selectors_Allow_To_Match) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *RelationshipDefinition_Selectors_Allow_To_Match) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsRelationshipDefinitionSelectorsAllowToPatch0 returns the union data inside the RelationshipDefinition_Selectors_Allow_To_Patch as a RelationshipDefinitionSelectorsAllowToPatch0
func (t RelationshipDefinition_Selectors_Allow_To_Patch) AsRelationshipDefinitionSelectorsAllowToPatch0() (RelationshipDefinitionSelectorsAllowToPatch0, error) {
	var body RelationshipDefinitionSelectorsAllowToPatch0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRelationshipDefinitionSelectorsAllowToPatch0 overwrites any union data inside the RelationshipDefinition_Selectors_Allow_To_Patch as the provided RelationshipDefinitionSelectorsAllowToPatch0
func (t *RelationshipDefinition_Selectors_Allow_To_Patch) FromRelationshipDefinitionSelectorsAllowToPatch0(v RelationshipDefinitionSelectorsAllowToPatch0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRelationshipDefinitionSelectorsAllowToPatch0 performs a merge with any union data inside the RelationshipDefinition_Selectors_Allow_To_Patch, using the provided RelationshipDefinitionSelectorsAllowToPatch0
func (t *RelationshipDefinition_Selectors_Allow_To_Patch) MergeRelationshipDefinitionSelectorsAllowToPatch0(v RelationshipDefinitionSelectorsAllowToPatch0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRelationshipDefinitionSelectorsAllowToPatch1 returns the union data inside the RelationshipDefinition_Selectors_Allow_To_Patch as a RelationshipDefinitionSelectorsAllowToPatch1
func (t RelationshipDefinition_Selectors_Allow_To_Patch) AsRelationshipDefinitionSelectorsAllowToPatch1() (RelationshipDefinitionSelectorsAllowToPatch1, error) {
	var body RelationshipDefinitionSelectorsAllowToPatch1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRelationshipDefinitionSelectorsAllowToPatch1 overwrites any union data inside the RelationshipDefinition_Selectors_Allow_To_Patch as the provided RelationshipDefinitionSelectorsAllowToPatch1
func (t *RelationshipDefinition_Selectors_Allow_To_Patch) FromRelationshipDefinitionSelectorsAllowToPatch1(v RelationshipDefinitionSelectorsAllowToPatch1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRelationshipDefinitionSelectorsAllowToPatch1 performs a merge with any union data inside the RelationshipDefinition_Selectors_Allow_To_Patch, using the provided RelationshipDefinitionSelectorsAllowToPatch1
func (t *RelationshipDefinition_Selectors_Allow_To_Patch) MergeRelationshipDefinitionSelectorsAllowToPatch1(v RelationshipDefinitionSelectorsAllowToPatch1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t RelationshipDefinition_Selectors_Allow_To_Patch) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.PatchStrategy != nil {
		object["patchStrategy"], err = json.Marshal(t.PatchStrategy)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'patchStrategy': %w", err)
		}
	}
	b, err = json.Marshal(object)
	return b, err
}

func (t *RelationshipDefinition_Selectors_Allow_To_Patch) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["patchStrategy"]; found {
		err = json.Unmarshal(raw, &t.PatchStrategy)
		if err != nil {
			return fmt.Errorf("error reading 'patchStrategy': %w", err)
		}
	}

	return err
}

// AsRelationshipDefinitionSelectorsDenyFromMatch1From0 returns the union data inside the RelationshipDefinition_Selectors_Deny_From_Match_1_From_Item as a RelationshipDefinitionSelectorsDenyFromMatch1From0
func (t RelationshipDefinition_Selectors_Deny_From_Match_1_From_Item) AsRelationshipDefinitionSelectorsDenyFromMatch1From0() (RelationshipDefinitionSelectorsDenyFromMatch1From0, error) {
	var body RelationshipDefinitionSelectorsDenyFromMatch1From0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRelationshipDefinitionSelectorsDenyFromMatch1From0 overwrites any union data inside the RelationshipDefinition_Selectors_Deny_From_Match_1_From_Item as the provided RelationshipDefinitionSelectorsDenyFromMatch1From0
func (t *RelationshipDefinition_Selectors_Deny_From_Match_1_From_Item) FromRelationshipDefinitionSelectorsDenyFromMatch1From0(v RelationshipDefinitionSelectorsDenyFromMatch1From0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRelationshipDefinitionSelectorsDenyFromMatch1From0 performs a merge with any union data inside the RelationshipDefinition_Selectors_Deny_From_Match_1_From_Item, using the provided RelationshipDefinitionSelectorsDenyFromMatch1From0
func (t *RelationshipDefinition_Selectors_Deny_From_Match_1_From_Item) MergeRelationshipDefinitionSelectorsDenyFromMatch1From0(v RelationshipDefinitionSelectorsDenyFromMatch1From0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRelationshipDefinitionSelectorsDenyFromMatch1From1 returns the union data inside the RelationshipDefinition_Selectors_Deny_From_Match_1_From_Item as a RelationshipDefinitionSelectorsDenyFromMatch1From1
func (t RelationshipDefinition_Selectors_Deny_From_Match_1_From_Item) AsRelationshipDefinitionSelectorsDenyFromMatch1From1() (RelationshipDefinitionSelectorsDenyFromMatch1From1, error) {
	var body RelationshipDefinitionSelectorsDenyFromMatch1From1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRelationshipDefinitionSelectorsDenyFromMatch1From1 overwrites any union data inside the RelationshipDefinition_Selectors_Deny_From_Match_1_From_Item as the provided RelationshipDefinitionSelectorsDenyFromMatch1From1
func (t *RelationshipDefinition_Selectors_Deny_From_Match_1_From_Item) FromRelationshipDefinitionSelectorsDenyFromMatch1From1(v RelationshipDefinitionSelectorsDenyFromMatch1From1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRelationshipDefinitionSelectorsDenyFromMatch1From1 performs a merge with any union data inside the RelationshipDefinition_Selectors_Deny_From_Match_1_From_Item, using the provided RelationshipDefinitionSelectorsDenyFromMatch1From1
func (t *RelationshipDefinition_Selectors_Deny_From_Match_1_From_Item) MergeRelationshipDefinitionSelectorsDenyFromMatch1From1(v RelationshipDefinitionSelectorsDenyFromMatch1From1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t RelationshipDefinition_Selectors_Deny_From_Match_1_From_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.Id != nil {
		object["id"], err = json.Marshal(t.Id)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'id': %w", err)
		}
	}

	if t.Kind != nil {
		object["kind"], err = json.Marshal(t.Kind)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'kind': %w", err)
		}
	}
	b, err = json.Marshal(object)
	return b, err
}

func (t *RelationshipDefinition_Selectors_Deny_From_Match_1_From_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &t.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
	}

	if raw, found := object["kind"]; found {
		err = json.Unmarshal(raw, &t.Kind)
		if err != nil {
			return fmt.Errorf("error reading 'kind': %w", err)
		}
	}

	return err
}

// AsRelationshipDefinitionSelectorsDenyFromMatch1To0 returns the union data inside the RelationshipDefinition_Selectors_Deny_From_Match_1_To_Item as a RelationshipDefinitionSelectorsDenyFromMatch1To0
func (t RelationshipDefinition_Selectors_Deny_From_Match_1_To_Item) AsRelationshipDefinitionSelectorsDenyFromMatch1To0() (RelationshipDefinitionSelectorsDenyFromMatch1To0, error) {
	var body RelationshipDefinitionSelectorsDenyFromMatch1To0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRelationshipDefinitionSelectorsDenyFromMatch1To0 overwrites any union data inside the RelationshipDefinition_Selectors_Deny_From_Match_1_To_Item as the provided RelationshipDefinitionSelectorsDenyFromMatch1To0
func (t *RelationshipDefinition_Selectors_Deny_From_Match_1_To_Item) FromRelationshipDefinitionSelectorsDenyFromMatch1To0(v RelationshipDefinitionSelectorsDenyFromMatch1To0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRelationshipDefinitionSelectorsDenyFromMatch1To0 performs a merge with any union data inside the RelationshipDefinition_Selectors_Deny_From_Match_1_To_Item, using the provided RelationshipDefinitionSelectorsDenyFromMatch1To0
func (t *RelationshipDefinition_Selectors_Deny_From_Match_1_To_Item) MergeRelationshipDefinitionSelectorsDenyFromMatch1To0(v RelationshipDefinitionSelectorsDenyFromMatch1To0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRelationshipDefinitionSelectorsDenyFromMatch1To1 returns the union data inside the RelationshipDefinition_Selectors_Deny_From_Match_1_To_Item as a RelationshipDefinitionSelectorsDenyFromMatch1To1
func (t RelationshipDefinition_Selectors_Deny_From_Match_1_To_Item) AsRelationshipDefinitionSelectorsDenyFromMatch1To1() (RelationshipDefinitionSelectorsDenyFromMatch1To1, error) {
	var body RelationshipDefinitionSelectorsDenyFromMatch1To1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRelationshipDefinitionSelectorsDenyFromMatch1To1 overwrites any union data inside the RelationshipDefinition_Selectors_Deny_From_Match_1_To_Item as the provided RelationshipDefinitionSelectorsDenyFromMatch1To1
func (t *RelationshipDefinition_Selectors_Deny_From_Match_1_To_Item) FromRelationshipDefinitionSelectorsDenyFromMatch1To1(v RelationshipDefinitionSelectorsDenyFromMatch1To1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRelationshipDefinitionSelectorsDenyFromMatch1To1 performs a merge with any union data inside the RelationshipDefinition_Selectors_Deny_From_Match_1_To_Item, using the provided RelationshipDefinitionSelectorsDenyFromMatch1To1
func (t *RelationshipDefinition_Selectors_Deny_From_Match_1_To_Item) MergeRelationshipDefinitionSelectorsDenyFromMatch1To1(v RelationshipDefinitionSelectorsDenyFromMatch1To1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t RelationshipDefinition_Selectors_Deny_From_Match_1_To_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.Id != nil {
		object["id"], err = json.Marshal(t.Id)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'id': %w", err)
		}
	}

	if t.Kind != nil {
		object["kind"], err = json.Marshal(t.Kind)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'kind': %w", err)
		}
	}
	b, err = json.Marshal(object)
	return b, err
}

func (t *RelationshipDefinition_Selectors_Deny_From_Match_1_To_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &t.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
	}

	if raw, found := object["kind"]; found {
		err = json.Unmarshal(raw, &t.Kind)
		if err != nil {
			return fmt.Errorf("error reading 'kind': %w", err)
		}
	}

	return err
}

// AsRelationshipDefinitionSelectorsDenyFromMatch0 returns the union data inside the RelationshipDefinition_Selectors_Deny_From_Match as a RelationshipDefinitionSelectorsDenyFromMatch0
func (t RelationshipDefinition_Selectors_Deny_From_Match) AsRelationshipDefinitionSelectorsDenyFromMatch0() (RelationshipDefinitionSelectorsDenyFromMatch0, error) {
	var body RelationshipDefinitionSelectorsDenyFromMatch0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRelationshipDefinitionSelectorsDenyFromMatch0 overwrites any union data inside the RelationshipDefinition_Selectors_Deny_From_Match as the provided RelationshipDefinitionSelectorsDenyFromMatch0
func (t *RelationshipDefinition_Selectors_Deny_From_Match) FromRelationshipDefinitionSelectorsDenyFromMatch0(v RelationshipDefinitionSelectorsDenyFromMatch0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRelationshipDefinitionSelectorsDenyFromMatch0 performs a merge with any union data inside the RelationshipDefinition_Selectors_Deny_From_Match, using the provided RelationshipDefinitionSelectorsDenyFromMatch0
func (t *RelationshipDefinition_Selectors_Deny_From_Match) MergeRelationshipDefinitionSelectorsDenyFromMatch0(v RelationshipDefinitionSelectorsDenyFromMatch0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRelationshipDefinitionSelectorsDenyFromMatch1 returns the union data inside the RelationshipDefinition_Selectors_Deny_From_Match as a RelationshipDefinitionSelectorsDenyFromMatch1
func (t RelationshipDefinition_Selectors_Deny_From_Match) AsRelationshipDefinitionSelectorsDenyFromMatch1() (RelationshipDefinitionSelectorsDenyFromMatch1, error) {
	var body RelationshipDefinitionSelectorsDenyFromMatch1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRelationshipDefinitionSelectorsDenyFromMatch1 overwrites any union data inside the RelationshipDefinition_Selectors_Deny_From_Match as the provided RelationshipDefinitionSelectorsDenyFromMatch1
func (t *RelationshipDefinition_Selectors_Deny_From_Match) FromRelationshipDefinitionSelectorsDenyFromMatch1(v RelationshipDefinitionSelectorsDenyFromMatch1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRelationshipDefinitionSelectorsDenyFromMatch1 performs a merge with any union data inside the RelationshipDefinition_Selectors_Deny_From_Match, using the provided RelationshipDefinitionSelectorsDenyFromMatch1
func (t *RelationshipDefinition_Selectors_Deny_From_Match) MergeRelationshipDefinitionSelectorsDenyFromMatch1(v RelationshipDefinitionSelectorsDenyFromMatch1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t RelationshipDefinition_Selectors_Deny_From_Match) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *RelationshipDefinition_Selectors_Deny_From_Match) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsRelationshipDefinitionSelectorsDenyFromPatch0 returns the union data inside the RelationshipDefinition_Selectors_Deny_From_Patch as a RelationshipDefinitionSelectorsDenyFromPatch0
func (t RelationshipDefinition_Selectors_Deny_From_Patch) AsRelationshipDefinitionSelectorsDenyFromPatch0() (RelationshipDefinitionSelectorsDenyFromPatch0, error) {
	var body RelationshipDefinitionSelectorsDenyFromPatch0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRelationshipDefinitionSelectorsDenyFromPatch0 overwrites any union data inside the RelationshipDefinition_Selectors_Deny_From_Patch as the provided RelationshipDefinitionSelectorsDenyFromPatch0
func (t *RelationshipDefinition_Selectors_Deny_From_Patch) FromRelationshipDefinitionSelectorsDenyFromPatch0(v RelationshipDefinitionSelectorsDenyFromPatch0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRelationshipDefinitionSelectorsDenyFromPatch0 performs a merge with any union data inside the RelationshipDefinition_Selectors_Deny_From_Patch, using the provided RelationshipDefinitionSelectorsDenyFromPatch0
func (t *RelationshipDefinition_Selectors_Deny_From_Patch) MergeRelationshipDefinitionSelectorsDenyFromPatch0(v RelationshipDefinitionSelectorsDenyFromPatch0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRelationshipDefinitionSelectorsDenyFromPatch1 returns the union data inside the RelationshipDefinition_Selectors_Deny_From_Patch as a RelationshipDefinitionSelectorsDenyFromPatch1
func (t RelationshipDefinition_Selectors_Deny_From_Patch) AsRelationshipDefinitionSelectorsDenyFromPatch1() (RelationshipDefinitionSelectorsDenyFromPatch1, error) {
	var body RelationshipDefinitionSelectorsDenyFromPatch1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRelationshipDefinitionSelectorsDenyFromPatch1 overwrites any union data inside the RelationshipDefinition_Selectors_Deny_From_Patch as the provided RelationshipDefinitionSelectorsDenyFromPatch1
func (t *RelationshipDefinition_Selectors_Deny_From_Patch) FromRelationshipDefinitionSelectorsDenyFromPatch1(v RelationshipDefinitionSelectorsDenyFromPatch1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRelationshipDefinitionSelectorsDenyFromPatch1 performs a merge with any union data inside the RelationshipDefinition_Selectors_Deny_From_Patch, using the provided RelationshipDefinitionSelectorsDenyFromPatch1
func (t *RelationshipDefinition_Selectors_Deny_From_Patch) MergeRelationshipDefinitionSelectorsDenyFromPatch1(v RelationshipDefinitionSelectorsDenyFromPatch1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t RelationshipDefinition_Selectors_Deny_From_Patch) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.PatchStrategy != nil {
		object["patchStrategy"], err = json.Marshal(t.PatchStrategy)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'patchStrategy': %w", err)
		}
	}
	b, err = json.Marshal(object)
	return b, err
}

func (t *RelationshipDefinition_Selectors_Deny_From_Patch) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["patchStrategy"]; found {
		err = json.Unmarshal(raw, &t.PatchStrategy)
		if err != nil {
			return fmt.Errorf("error reading 'patchStrategy': %w", err)
		}
	}

	return err
}

// AsRelationshipDefinitionSelectorsDenyToMatch1From0 returns the union data inside the RelationshipDefinition_Selectors_Deny_To_Match_1_From_Item as a RelationshipDefinitionSelectorsDenyToMatch1From0
func (t RelationshipDefinition_Selectors_Deny_To_Match_1_From_Item) AsRelationshipDefinitionSelectorsDenyToMatch1From0() (RelationshipDefinitionSelectorsDenyToMatch1From0, error) {
	var body RelationshipDefinitionSelectorsDenyToMatch1From0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRelationshipDefinitionSelectorsDenyToMatch1From0 overwrites any union data inside the RelationshipDefinition_Selectors_Deny_To_Match_1_From_Item as the provided RelationshipDefinitionSelectorsDenyToMatch1From0
func (t *RelationshipDefinition_Selectors_Deny_To_Match_1_From_Item) FromRelationshipDefinitionSelectorsDenyToMatch1From0(v RelationshipDefinitionSelectorsDenyToMatch1From0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRelationshipDefinitionSelectorsDenyToMatch1From0 performs a merge with any union data inside the RelationshipDefinition_Selectors_Deny_To_Match_1_From_Item, using the provided RelationshipDefinitionSelectorsDenyToMatch1From0
func (t *RelationshipDefinition_Selectors_Deny_To_Match_1_From_Item) MergeRelationshipDefinitionSelectorsDenyToMatch1From0(v RelationshipDefinitionSelectorsDenyToMatch1From0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRelationshipDefinitionSelectorsDenyToMatch1From1 returns the union data inside the RelationshipDefinition_Selectors_Deny_To_Match_1_From_Item as a RelationshipDefinitionSelectorsDenyToMatch1From1
func (t RelationshipDefinition_Selectors_Deny_To_Match_1_From_Item) AsRelationshipDefinitionSelectorsDenyToMatch1From1() (RelationshipDefinitionSelectorsDenyToMatch1From1, error) {
	var body RelationshipDefinitionSelectorsDenyToMatch1From1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRelationshipDefinitionSelectorsDenyToMatch1From1 overwrites any union data inside the RelationshipDefinition_Selectors_Deny_To_Match_1_From_Item as the provided RelationshipDefinitionSelectorsDenyToMatch1From1
func (t *RelationshipDefinition_Selectors_Deny_To_Match_1_From_Item) FromRelationshipDefinitionSelectorsDenyToMatch1From1(v RelationshipDefinitionSelectorsDenyToMatch1From1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRelationshipDefinitionSelectorsDenyToMatch1From1 performs a merge with any union data inside the RelationshipDefinition_Selectors_Deny_To_Match_1_From_Item, using the provided RelationshipDefinitionSelectorsDenyToMatch1From1
func (t *RelationshipDefinition_Selectors_Deny_To_Match_1_From_Item) MergeRelationshipDefinitionSelectorsDenyToMatch1From1(v RelationshipDefinitionSelectorsDenyToMatch1From1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t RelationshipDefinition_Selectors_Deny_To_Match_1_From_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.Id != nil {
		object["id"], err = json.Marshal(t.Id)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'id': %w", err)
		}
	}

	if t.Kind != nil {
		object["kind"], err = json.Marshal(t.Kind)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'kind': %w", err)
		}
	}
	b, err = json.Marshal(object)
	return b, err
}

func (t *RelationshipDefinition_Selectors_Deny_To_Match_1_From_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &t.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
	}

	if raw, found := object["kind"]; found {
		err = json.Unmarshal(raw, &t.Kind)
		if err != nil {
			return fmt.Errorf("error reading 'kind': %w", err)
		}
	}

	return err
}

// AsRelationshipDefinitionSelectorsDenyToMatch1To0 returns the union data inside the RelationshipDefinition_Selectors_Deny_To_Match_1_To_Item as a RelationshipDefinitionSelectorsDenyToMatch1To0
func (t RelationshipDefinition_Selectors_Deny_To_Match_1_To_Item) AsRelationshipDefinitionSelectorsDenyToMatch1To0() (RelationshipDefinitionSelectorsDenyToMatch1To0, error) {
	var body RelationshipDefinitionSelectorsDenyToMatch1To0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRelationshipDefinitionSelectorsDenyToMatch1To0 overwrites any union data inside the RelationshipDefinition_Selectors_Deny_To_Match_1_To_Item as the provided RelationshipDefinitionSelectorsDenyToMatch1To0
func (t *RelationshipDefinition_Selectors_Deny_To_Match_1_To_Item) FromRelationshipDefinitionSelectorsDenyToMatch1To0(v RelationshipDefinitionSelectorsDenyToMatch1To0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRelationshipDefinitionSelectorsDenyToMatch1To0 performs a merge with any union data inside the RelationshipDefinition_Selectors_Deny_To_Match_1_To_Item, using the provided RelationshipDefinitionSelectorsDenyToMatch1To0
func (t *RelationshipDefinition_Selectors_Deny_To_Match_1_To_Item) MergeRelationshipDefinitionSelectorsDenyToMatch1To0(v RelationshipDefinitionSelectorsDenyToMatch1To0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRelationshipDefinitionSelectorsDenyToMatch1To1 returns the union data inside the RelationshipDefinition_Selectors_Deny_To_Match_1_To_Item as a RelationshipDefinitionSelectorsDenyToMatch1To1
func (t RelationshipDefinition_Selectors_Deny_To_Match_1_To_Item) AsRelationshipDefinitionSelectorsDenyToMatch1To1() (RelationshipDefinitionSelectorsDenyToMatch1To1, error) {
	var body RelationshipDefinitionSelectorsDenyToMatch1To1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRelationshipDefinitionSelectorsDenyToMatch1To1 overwrites any union data inside the RelationshipDefinition_Selectors_Deny_To_Match_1_To_Item as the provided RelationshipDefinitionSelectorsDenyToMatch1To1
func (t *RelationshipDefinition_Selectors_Deny_To_Match_1_To_Item) FromRelationshipDefinitionSelectorsDenyToMatch1To1(v RelationshipDefinitionSelectorsDenyToMatch1To1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRelationshipDefinitionSelectorsDenyToMatch1To1 performs a merge with any union data inside the RelationshipDefinition_Selectors_Deny_To_Match_1_To_Item, using the provided RelationshipDefinitionSelectorsDenyToMatch1To1
func (t *RelationshipDefinition_Selectors_Deny_To_Match_1_To_Item) MergeRelationshipDefinitionSelectorsDenyToMatch1To1(v RelationshipDefinitionSelectorsDenyToMatch1To1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t RelationshipDefinition_Selectors_Deny_To_Match_1_To_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.Id != nil {
		object["id"], err = json.Marshal(t.Id)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'id': %w", err)
		}
	}

	if t.Kind != nil {
		object["kind"], err = json.Marshal(t.Kind)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'kind': %w", err)
		}
	}
	b, err = json.Marshal(object)
	return b, err
}

func (t *RelationshipDefinition_Selectors_Deny_To_Match_1_To_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &t.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
	}

	if raw, found := object["kind"]; found {
		err = json.Unmarshal(raw, &t.Kind)
		if err != nil {
			return fmt.Errorf("error reading 'kind': %w", err)
		}
	}

	return err
}

// AsRelationshipDefinitionSelectorsDenyToMatch0 returns the union data inside the RelationshipDefinition_Selectors_Deny_To_Match as a RelationshipDefinitionSelectorsDenyToMatch0
func (t RelationshipDefinition_Selectors_Deny_To_Match) AsRelationshipDefinitionSelectorsDenyToMatch0() (RelationshipDefinitionSelectorsDenyToMatch0, error) {
	var body RelationshipDefinitionSelectorsDenyToMatch0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRelationshipDefinitionSelectorsDenyToMatch0 overwrites any union data inside the RelationshipDefinition_Selectors_Deny_To_Match as the provided RelationshipDefinitionSelectorsDenyToMatch0
func (t *RelationshipDefinition_Selectors_Deny_To_Match) FromRelationshipDefinitionSelectorsDenyToMatch0(v RelationshipDefinitionSelectorsDenyToMatch0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRelationshipDefinitionSelectorsDenyToMatch0 performs a merge with any union data inside the RelationshipDefinition_Selectors_Deny_To_Match, using the provided RelationshipDefinitionSelectorsDenyToMatch0
func (t *RelationshipDefinition_Selectors_Deny_To_Match) MergeRelationshipDefinitionSelectorsDenyToMatch0(v RelationshipDefinitionSelectorsDenyToMatch0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRelationshipDefinitionSelectorsDenyToMatch1 returns the union data inside the RelationshipDefinition_Selectors_Deny_To_Match as a RelationshipDefinitionSelectorsDenyToMatch1
func (t RelationshipDefinition_Selectors_Deny_To_Match) AsRelationshipDefinitionSelectorsDenyToMatch1() (RelationshipDefinitionSelectorsDenyToMatch1, error) {
	var body RelationshipDefinitionSelectorsDenyToMatch1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRelationshipDefinitionSelectorsDenyToMatch1 overwrites any union data inside the RelationshipDefinition_Selectors_Deny_To_Match as the provided RelationshipDefinitionSelectorsDenyToMatch1
func (t *RelationshipDefinition_Selectors_Deny_To_Match) FromRelationshipDefinitionSelectorsDenyToMatch1(v RelationshipDefinitionSelectorsDenyToMatch1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRelationshipDefinitionSelectorsDenyToMatch1 performs a merge with any union data inside the RelationshipDefinition_Selectors_Deny_To_Match, using the provided RelationshipDefinitionSelectorsDenyToMatch1
func (t *RelationshipDefinition_Selectors_Deny_To_Match) MergeRelationshipDefinitionSelectorsDenyToMatch1(v RelationshipDefinitionSelectorsDenyToMatch1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t RelationshipDefinition_Selectors_Deny_To_Match) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *RelationshipDefinition_Selectors_Deny_To_Match) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsRelationshipDefinitionSelectorsDenyToPatch0 returns the union data inside the RelationshipDefinition_Selectors_Deny_To_Patch as a RelationshipDefinitionSelectorsDenyToPatch0
func (t RelationshipDefinition_Selectors_Deny_To_Patch) AsRelationshipDefinitionSelectorsDenyToPatch0() (RelationshipDefinitionSelectorsDenyToPatch0, error) {
	var body RelationshipDefinitionSelectorsDenyToPatch0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRelationshipDefinitionSelectorsDenyToPatch0 overwrites any union data inside the RelationshipDefinition_Selectors_Deny_To_Patch as the provided RelationshipDefinitionSelectorsDenyToPatch0
func (t *RelationshipDefinition_Selectors_Deny_To_Patch) FromRelationshipDefinitionSelectorsDenyToPatch0(v RelationshipDefinitionSelectorsDenyToPatch0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRelationshipDefinitionSelectorsDenyToPatch0 performs a merge with any union data inside the RelationshipDefinition_Selectors_Deny_To_Patch, using the provided RelationshipDefinitionSelectorsDenyToPatch0
func (t *RelationshipDefinition_Selectors_Deny_To_Patch) MergeRelationshipDefinitionSelectorsDenyToPatch0(v RelationshipDefinitionSelectorsDenyToPatch0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRelationshipDefinitionSelectorsDenyToPatch1 returns the union data inside the RelationshipDefinition_Selectors_Deny_To_Patch as a RelationshipDefinitionSelectorsDenyToPatch1
func (t RelationshipDefinition_Selectors_Deny_To_Patch) AsRelationshipDefinitionSelectorsDenyToPatch1() (RelationshipDefinitionSelectorsDenyToPatch1, error) {
	var body RelationshipDefinitionSelectorsDenyToPatch1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRelationshipDefinitionSelectorsDenyToPatch1 overwrites any union data inside the RelationshipDefinition_Selectors_Deny_To_Patch as the provided RelationshipDefinitionSelectorsDenyToPatch1
func (t *RelationshipDefinition_Selectors_Deny_To_Patch) FromRelationshipDefinitionSelectorsDenyToPatch1(v RelationshipDefinitionSelectorsDenyToPatch1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRelationshipDefinitionSelectorsDenyToPatch1 performs a merge with any union data inside the RelationshipDefinition_Selectors_Deny_To_Patch, using the provided RelationshipDefinitionSelectorsDenyToPatch1
func (t *RelationshipDefinition_Selectors_Deny_To_Patch) MergeRelationshipDefinitionSelectorsDenyToPatch1(v RelationshipDefinitionSelectorsDenyToPatch1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t RelationshipDefinition_Selectors_Deny_To_Patch) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.PatchStrategy != nil {
		object["patchStrategy"], err = json.Marshal(t.PatchStrategy)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'patchStrategy': %w", err)
		}
	}
	b, err = json.Marshal(object)
	return b, err
}

func (t *RelationshipDefinition_Selectors_Deny_To_Patch) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["patchStrategy"]; found {
		err = json.Unmarshal(raw, &t.PatchStrategy)
		if err != nil {
			return fmt.Errorf("error reading 'patchStrategy': %w", err)
		}
	}

	return err
}
