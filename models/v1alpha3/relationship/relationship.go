// Package relationship provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.16.3 DO NOT EDIT.
package relationship

import (
	"encoding/json"
	"fmt"

	"github.com/gofrs/uuid"
	"github.com/meshery/schemas/models/v1alpha1/capability"
	"github.com/meshery/schemas/models/v1alpha1/core"
	"github.com/meshery/schemas/models/v1alpha3/selector"
	"github.com/meshery/schemas/models/v1beta1/model"
	"github.com/oapi-codegen/runtime"
)

// Defines values for RelationshipDefinitionKind.
const (
	Edge         RelationshipDefinitionKind = "edge"
	Hierarchical RelationshipDefinitionKind = "hierarchical"
	Sibling      RelationshipDefinitionKind = "sibling"
)

// Defines values for RelationshipDefinitionStatus.
const (
	Approved RelationshipDefinitionStatus = "approved"
	Deleted  RelationshipDefinitionStatus = "deleted"
	Enabled  RelationshipDefinitionStatus = "enabled"
	Ignored  RelationshipDefinitionStatus = "ignored"
	Pending  RelationshipDefinitionStatus = "pending"
)

// RelationshipDefinition Relationships define the nature of interaction between interconnected components in Meshery. The combination of relationship properties kind, type, and subtype characterize various genealogical relations among and between components. Relationships have selectors, selector sets, metadata, and optional parameters. Learn more at https://docs.meshery.io/concepts/logical/relationships.
type RelationshipDefinition struct {
	// Capabilities Capabilities associated with the relationship.
	Capabilities *[]capability.Capability `gorm:"type:bytes;serializer:json" json:"capabilities,omitempty" yaml:"capabilities,omitempty"`

	// EvaluationQuery Optional. Assigns the policy to be used for the evaluation of the relationship. Deprecation Notice: In the future, this property is either to be removed or to it is to be an array of optional policy $refs.
	EvaluationQuery *string `json:"evaluationQuery" yaml:"evaluationQuery"`

	// Id Uniquely identifies the entity (i.e. component) as defined in a declaration (i.e. design).
	Id *uuid.UUID `json:"id" yaml:"id"`

	// Kind Kind of the Relationship. Learn more about relationships - https://docs.meshery.io/concepts/logical/relationships.
	Kind RelationshipDefinitionKind `json:"kind" yaml:"kind"`

	// Metadata Metadata contains additional information associated with the Relationship.
	Metadata *RelationshipDefinition_Metadata `gorm:"foreignKey:ModelId;references:Id" json:"metadata,omitempty" yaml:"metadata,omitempty"`

	// Model Meshery Models serve as a portable unit of packaging to define managed entities, their relationships, and capabilities.
	Model model.ModelDefinition `json:"model" yaml:"model"`

	// SchemaVersion Specifies the version of the schema used for the relationship definition.
	SchemaVersion string `json:"schemaVersion" yaml:"schemaVersion"`

	// Selectors Selectors are organized as an array, with each item containing a distinct set of selectors that share a common functionality. This structure allows for flexibility in defining relationships, even when different components are involved.
	Selectors *selector.Selectors `gorm:"type:bytes;serializer:json" json:"selectors,omitempty" yaml:"selectors,omitempty"`

	// Status Status of the relationship.
	Status *RelationshipDefinitionStatus `json:"status" yaml:"status"`

	// SubType Most granular unit of relationship classification. The combination of Kind, Type and SubType together uniquely identify a Relationship.
	SubType string `json:"subType" yaml:"subType"`

	// Type Classification of relationships. Used to group relationships similar in nature.
	RelationshipType string `json:"type" yaml:"type"`

	// Version Specifies the version of the relationship definition.
	Version string `json:"version" yaml:"version"`
}

// RelationshipDefinitionKind Kind of the Relationship. Learn more about relationships - https://docs.meshery.io/concepts/logical/relationships.
type RelationshipDefinitionKind string

// RelationshipDefinitionMetadataStyles0 Common styles for all entities
type RelationshipDefinitionMetadataStyles0 = core.Styles

// RelationshipDefinitionMetadataStyles1 defines model for .
type RelationshipDefinitionMetadataStyles1 = core.Styles

// RelationshipDefinition_Metadata_Styles defines model for RelationshipDefinition.Metadata.Styles.
type RelationshipDefinition_Metadata_Styles struct {
	union json.RawMessage
}

// RelationshipDefinition_Metadata Metadata contains additional information associated with the Relationship.
type RelationshipDefinition_Metadata struct {
	// Description Characterization of the meaning of the relationship and its relevance to both Meshery and entities under management.
	Description *string `json:"description" yaml:"description"`

	// IsAnnotation Indicates whether the relationship should be treated as a logical representation only
	IsAnnotation         *bool                                   `json:"isAnnotation" yaml:"isAnnotation"`
	Styles               *RelationshipDefinition_Metadata_Styles `json:"styles" yaml:"styles"`
	AdditionalProperties map[string]interface{}                  `json:"-" yaml:"-"`
}

// RelationshipDefinitionStatus Status of the relationship.
type RelationshipDefinitionStatus string

// Getter for additional properties for RelationshipDefinition_Metadata. Returns the specified
// element and whether it was found
func (a RelationshipDefinition_Metadata) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for RelationshipDefinition_Metadata
func (a *RelationshipDefinition_Metadata) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for RelationshipDefinition_Metadata to handle AdditionalProperties
func (a *RelationshipDefinition_Metadata) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["description"]; found {
		err = json.Unmarshal(raw, &a.Description)
		if err != nil {
			return fmt.Errorf("error reading 'description': %w", err)
		}
		delete(object, "description")
	}

	if raw, found := object["isAnnotation"]; found {
		err = json.Unmarshal(raw, &a.IsAnnotation)
		if err != nil {
			return fmt.Errorf("error reading 'isAnnotation': %w", err)
		}
		delete(object, "isAnnotation")
	}

	if raw, found := object["styles"]; found {
		err = json.Unmarshal(raw, &a.Styles)
		if err != nil {
			return fmt.Errorf("error reading 'styles': %w", err)
		}
		delete(object, "styles")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for RelationshipDefinition_Metadata to handle AdditionalProperties
func (a RelationshipDefinition_Metadata) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Description != nil {
		object["description"], err = json.Marshal(a.Description)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'description': %w", err)
		}
	}

	if a.IsAnnotation != nil {
		object["isAnnotation"], err = json.Marshal(a.IsAnnotation)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'isAnnotation': %w", err)
		}
	}

	if a.Styles != nil {
		object["styles"], err = json.Marshal(a.Styles)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'styles': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// AsRelationshipDefinitionMetadataStyles0 returns the union data inside the RelationshipDefinition_Metadata_Styles as a RelationshipDefinitionMetadataStyles0
func (t RelationshipDefinition_Metadata_Styles) AsRelationshipDefinitionMetadataStyles0() (RelationshipDefinitionMetadataStyles0, error) {
	var body RelationshipDefinitionMetadataStyles0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRelationshipDefinitionMetadataStyles0 overwrites any union data inside the RelationshipDefinition_Metadata_Styles as the provided RelationshipDefinitionMetadataStyles0
func (t *RelationshipDefinition_Metadata_Styles) FromRelationshipDefinitionMetadataStyles0(v RelationshipDefinitionMetadataStyles0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRelationshipDefinitionMetadataStyles0 performs a merge with any union data inside the RelationshipDefinition_Metadata_Styles, using the provided RelationshipDefinitionMetadataStyles0
func (t *RelationshipDefinition_Metadata_Styles) MergeRelationshipDefinitionMetadataStyles0(v RelationshipDefinitionMetadataStyles0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsRelationshipDefinitionMetadataStyles1 returns the union data inside the RelationshipDefinition_Metadata_Styles as a RelationshipDefinitionMetadataStyles1
func (t RelationshipDefinition_Metadata_Styles) AsRelationshipDefinitionMetadataStyles1() (RelationshipDefinitionMetadataStyles1, error) {
	var body RelationshipDefinitionMetadataStyles1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRelationshipDefinitionMetadataStyles1 overwrites any union data inside the RelationshipDefinition_Metadata_Styles as the provided RelationshipDefinitionMetadataStyles1
func (t *RelationshipDefinition_Metadata_Styles) FromRelationshipDefinitionMetadataStyles1(v RelationshipDefinitionMetadataStyles1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRelationshipDefinitionMetadataStyles1 performs a merge with any union data inside the RelationshipDefinition_Metadata_Styles, using the provided RelationshipDefinitionMetadataStyles1
func (t *RelationshipDefinition_Metadata_Styles) MergeRelationshipDefinitionMetadataStyles1(v RelationshipDefinitionMetadataStyles1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t RelationshipDefinition_Metadata_Styles) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *RelationshipDefinition_Metadata_Styles) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}
