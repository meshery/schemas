// Package model provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package model

import (
	"encoding/json"
	"fmt"

	"github.com/gofrs/uuid"
	"github.com/meshery/schemas/models/v1alpha1/capability"
	"github.com/meshery/schemas/models/v1beta1/category"
	"github.com/meshery/schemas/models/v1beta1/connection"
	"github.com/meshery/schemas/models/v1beta1/subcategory"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// Defines values for ImportRequestUploadType.
const (
	Csv       ImportRequestUploadType = "csv"
	File      ImportRequestUploadType = "file"
	Url       ImportRequestUploadType = "url"
	UrlImport ImportRequestUploadType = "urlImport"
)

// Defines values for ModelDefinitionStatus.
const (
	Duplicate ModelDefinitionStatus = "duplicate"
	Enabled   ModelDefinitionStatus = "enabled"
	Ignored   ModelDefinitionStatus = "ignored"
)

// Defines values for ModelDefinitionMetadataShape.
const (
	Barrel               ModelDefinitionMetadataShape = "barrel"
	BottomRoundRectangle ModelDefinitionMetadataShape = "bottom-round-rectangle"
	Circle               ModelDefinitionMetadataShape = "circle"
	ConcaveHexagon       ModelDefinitionMetadataShape = "concave-hexagon"
	CutRectangle         ModelDefinitionMetadataShape = "cut-rectangle"
	Diamond              ModelDefinitionMetadataShape = "diamond"
	Ellipse              ModelDefinitionMetadataShape = "ellipse"
	Heptagon             ModelDefinitionMetadataShape = "heptagon"
	Hexagon              ModelDefinitionMetadataShape = "hexagon"
	Octagon              ModelDefinitionMetadataShape = "octagon"
	Pentagon             ModelDefinitionMetadataShape = "pentagon"
	Polygon              ModelDefinitionMetadataShape = "polygon"
	Rectangle            ModelDefinitionMetadataShape = "rectangle"
	Rhomboid             ModelDefinitionMetadataShape = "rhomboid"
	RoundDiamond         ModelDefinitionMetadataShape = "round-diamond"
	RoundHeptagon        ModelDefinitionMetadataShape = "round-heptagon"
	RoundHexagon         ModelDefinitionMetadataShape = "round-hexagon"
	RoundOctagon         ModelDefinitionMetadataShape = "round-octagon"
	RoundPentagon        ModelDefinitionMetadataShape = "round-pentagon"
	RoundRectangle       ModelDefinitionMetadataShape = "round-rectangle"
	RoundTag             ModelDefinitionMetadataShape = "round-tag"
	RoundTriangle        ModelDefinitionMetadataShape = "round-triangle"
	Star                 ModelDefinitionMetadataShape = "star"
	Tag                  ModelDefinitionMetadataShape = "tag"
	Triangle             ModelDefinitionMetadataShape = "triangle"
	Vee                  ModelDefinitionMetadataShape = "vee"
)

// ImportBody defines model for ImportBody.
type ImportBody struct {
	union json.RawMessage
}

// ImportBody0 defines model for .
type ImportBody0 struct {
	// FileName Name of the file being uploaded.
	FileName string `json:"fileName" yaml:"fileName"`

	// ModelFile Supported model file formats are: .tar, .tar.gz, and .tgz. See [Import Models Documentation](https://docs.meshery.io/guides/configuration-management/importing-models#import-models-using-meshery-ui) for details
	ModelFile string `json:"modelFile" yaml:"modelFile"`
}

// ImportBody1 defines model for .
type ImportBody1 struct {
	// Url A direct URL to a single model file, for example: https://raw.github.com/your-model-file.tar. Supported model file formats are: .tar, .tar.gz, and .tgz. \n\nFor bulk import of your model use the GitHub connection or CSV files. See [Import Models Documentation](https://docs.meshery.io/guides/configuration-management/importing-models#import-models-using-meshery-ui) for details
	Url string `json:"url" yaml:"url"`
}

// ImportBody2 defines model for .
type ImportBody2 struct {
	// ComponentCsv Upload a CSV file containing component definitions
	ComponentCsv openapi_types.File `json:"componentCsv" yaml:"componentCsv"`

	// ModelCsv Upload a CSV file containing model definitions
	ModelCsv openapi_types.File `json:"modelCsv" yaml:"modelCsv"`

	// RelationshipCsv Upload a CSV file containing relationship definitions
	RelationshipCsv openapi_types.File `json:"relationshipCsv" yaml:"relationshipCsv"`
}

// ImportBody3 defines model for .
type ImportBody3 struct {
	// Url URI to the source code or package of the model.
	Url string `json:"url" yaml:"url"`
}

// ImportRequest defines model for ImportRequest.
type ImportRequest struct {
	ImportBody ImportRequest_ImportBody `json:"importBody" yaml:"importBody"`
	Register   bool                     `json:"register" yaml:"register"`

	// UploadType Choose the method you prefer to upload your model file. Select 'File Import' or 'CSV Import' if you have the file on your local system or 'URL Import' if you have the file hosted online.
	UploadType ImportRequestUploadType `json:"uploadType" yaml:"uploadType"`
}

// ImportRequestImportBody0 defines model for .
type ImportRequestImportBody0 struct {
	// FileName Name of the file being uploaded.
	FileName string `json:"fileName" yaml:"fileName"`

	// ModelFile Supported model file formats are: .tar, .tar.gz, and .tgz. See [Import Models Documentation](https://docs.meshery.io/guides/configuration-management/importing-models#import-models-using-meshery-ui) for details
	ModelFile string `json:"modelFile" yaml:"modelFile"`
}

// ImportRequestImportBody1 defines model for .
type ImportRequestImportBody1 struct {
	// Url A direct URL to a single model file, for example: https://raw.github.com/your-model-file.tar. Supported model file formats are: .tar, .tar.gz, and .tgz. \n\nFor bulk import of your model use the GitHub connection or CSV files. See [Import Models Documentation](https://docs.meshery.io/guides/configuration-management/importing-models#import-models-using-meshery-ui) for details
	Url string `json:"url" yaml:"url"`
}

// ImportRequestImportBody2 defines model for .
type ImportRequestImportBody2 struct {
	// ComponentCsv Upload a CSV file containing component definitions
	ComponentCsv openapi_types.File `json:"componentCsv" yaml:"componentCsv"`

	// ModelCsv Upload a CSV file containing model definitions
	ModelCsv openapi_types.File `json:"modelCsv" yaml:"modelCsv"`

	// RelationshipCsv Upload a CSV file containing relationship definitions
	RelationshipCsv openapi_types.File `json:"relationshipCsv" yaml:"relationshipCsv"`
}

// ImportRequestImportBody3 defines model for .
type ImportRequestImportBody3 struct {
	// Url URI to the source code or package of the model.
	Url string `json:"url" yaml:"url"`
}

// ImportRequest_ImportBody defines model for ImportRequest.ImportBody.
type ImportRequest_ImportBody struct {
	union json.RawMessage
}

// ImportRequestUploadType Choose the method you prefer to upload your model file. Select 'File Import' or 'CSV Import' if you have the file on your local system or 'URL Import' if you have the file hosted online.
type ImportRequestUploadType string

// Model Registrant-defined data associated with the model. Properties pertain to the software being managed (e.g. Kubernetes v1.31).
type Model struct {
	// Version Version of the model as defined by the registrant.
	Version string `json:"version" yaml:"version"`
}

// ModelDefinition Meshery Models serve as a portable unit of packaging to define managed entities, their relationships, and capabilities.
type ModelDefinition struct {
	// Id Uniquely identifies the entity (i.e. component) as defined in a declaration (i.e. design).
	Id uuid.UUID `json:"id" yaml:"id"`

	// SchemaVersion Specifies the version of the schema used for the definition.
	SchemaVersion string `json:"schemaVersion" yaml:"schemaVersion"`

	// Version A valid semantic version string between 5 and 256 characters. The pattern allows for a major.minor.patch version followed by an optional pre-release tag like '-alpha' or '-beta.2' and an optional build metadata tag like '+build.1.
	Version string `json:"version" yaml:"version"`

	// Name The unique name for the model within the scope of a registrant.
	Name string `json:"name" yaml:"name"`

	// DisplayName Human-readable name for the model.
	DisplayName string `json:"displayName" yaml:"displayName"`

	// Description Description of the model.
	Description string `json:"description,omitempty" yaml:"description,omitempty"`

	// Status Status of model, including:
	// - duplicate: this component is a duplicate of another. The component that is to be the canonical reference and that is duplicated by other components should not be assigned the 'duplicate' status.
	// - maintenance: model is unavailable for a period of time.
	// - enabled: model is available for use for all users of this Meshery Server.
	// - ignored: model is unavailable for use for all users of this Meshery Server.
	Status ModelDefinitionStatus `json:"status" yaml:"status"`

	// CategoryId ID of the category.
	CategoryId uuid.UUID `gorm:"categoryID" json:"-" yaml:"-"`

	// Registrant Meshery Connections are managed and unmanaged resources that either through discovery or manual entry are tracked by Meshery. Learn more at https://docs.meshery.io/concepts/logical/connections
	Registrant connection.Connection `gorm:"foreignKey:RegistrantId;references:ID" json:"registrant" yaml:"registrant"`

	// RegistrantId ID of the registrant.
	RegistrantId uuid.UUID `gorm:"column:connection_id" json:"connection_id" yaml:"connection_id"`

	// Category Category of the model.
	Category category.CategoryDefinition `gorm:"foreignKey:CategoryId;references:Id" json:"category" yaml:"category"`

	// SubCategory Sub category of the model determines the secondary grouping.
	SubCategory subcategory.SubCategoryDefinition `json:"subCategory" yaml:"subCategory"`

	// Metadata Metadata containing additional information associated with the model.
	Metadata *ModelDefinition_Metadata `gorm:"type:bytes;serializer:json" json:"metadata" yaml:"metadata"`

	// Model Registrant-defined data associated with the model. Properties pertain to the software being managed (e.g. Kubernetes v1.31).
	Model struct {
		// Version Version of the model as defined by the registrant.
		Version string `json:"version" yaml:"version"`
	} `gorm:"type:bytes;serializer:json" json:"model" yaml:"model"`

	// ComponentsCount Number of components associated with the model.
	ComponentsCount int `gorm:"-" json:"components_count" yaml:"components_count"`

	// RelationshipsCount Number of relationships associated with the model.
	RelationshipsCount int         `gorm:"-" json:"relationships_count" yaml:"relationships_count"`
	Components         interface{} `gorm:"-" json:"components" yaml:"components"`
	Relationships      interface{} `gorm:"-" json:"relationships" yaml:"relationships"`
}

// ModelDefinitionStatus Status of model, including:
// - duplicate: this component is a duplicate of another. The component that is to be the canonical reference and that is duplicated by other components should not be assigned the 'duplicate' status.
// - maintenance: model is unavailable for a period of time.
// - enabled: model is available for use for all users of this Meshery Server.
// - ignored: model is unavailable for use for all users of this Meshery Server.
type ModelDefinitionStatus string

// ModelDefinitionMetadataShape The shape of the node’s body. Note that each shape fits within the specified width and height, and so you may have to adjust width and height if you desire an equilateral shape (i.e. width !== height for several equilateral shapes)
type ModelDefinitionMetadataShape string

// ModelDefinition_Metadata Metadata containing additional information associated with the model.
type ModelDefinition_Metadata struct {
	// Capabilities Capabilities associated with the model
	Capabilities *[]capability.Capability `json:"capabilities,omitempty" yaml:"capabilities,omitempty"`

	// IsAnnotation Indicates whether the model and its entities should be treated as deployable entities or as logical representations.
	IsAnnotation *bool `json:"isAnnotation" yaml:"isAnnotation"`

	// PrimaryColor Primary color associated with the model.
	PrimaryColor *string `json:"primaryColor" yaml:"primaryColor"`

	// SecondaryColor Secondary color associated with the model.
	SecondaryColor *string `json:"secondaryColor" yaml:"secondaryColor"`

	// SvgWhite SVG representation of the model in white color.
	SvgWhite string `json:"svgWhite" yaml:"svgWhite"`

	// SvgColor SVG representation of the model in colored format.
	SvgColor string `json:"svgColor" yaml:"svgColor"`

	// SvgComplete SVG representation of the complete model.
	SvgComplete *string `json:"svgComplete" yaml:"svgComplete"`

	// Shape The shape of the node’s body. Note that each shape fits within the specified width and height, and so you may have to adjust width and height if you desire an equilateral shape (i.e. width !== height for several equilateral shapes)
	Shape                *ModelDefinitionMetadataShape `json:"shape,omitempty" yaml:"shape,omitempty"`
	AdditionalProperties map[string]interface{}        `json:"-" yaml:"-"`
}

// Getter for additional properties for ModelDefinition_Metadata. Returns the specified
// element and whether it was found
func (a ModelDefinition_Metadata) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ModelDefinition_Metadata
func (a *ModelDefinition_Metadata) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ModelDefinition_Metadata to handle AdditionalProperties
func (a *ModelDefinition_Metadata) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["capabilities"]; found {
		err = json.Unmarshal(raw, &a.Capabilities)
		if err != nil {
			return fmt.Errorf("error reading 'capabilities': %w", err)
		}
		delete(object, "capabilities")
	}

	if raw, found := object["isAnnotation"]; found {
		err = json.Unmarshal(raw, &a.IsAnnotation)
		if err != nil {
			return fmt.Errorf("error reading 'isAnnotation': %w", err)
		}
		delete(object, "isAnnotation")
	}

	if raw, found := object["primaryColor"]; found {
		err = json.Unmarshal(raw, &a.PrimaryColor)
		if err != nil {
			return fmt.Errorf("error reading 'primaryColor': %w", err)
		}
		delete(object, "primaryColor")
	}

	if raw, found := object["secondaryColor"]; found {
		err = json.Unmarshal(raw, &a.SecondaryColor)
		if err != nil {
			return fmt.Errorf("error reading 'secondaryColor': %w", err)
		}
		delete(object, "secondaryColor")
	}

	if raw, found := object["svgWhite"]; found {
		err = json.Unmarshal(raw, &a.SvgWhite)
		if err != nil {
			return fmt.Errorf("error reading 'svgWhite': %w", err)
		}
		delete(object, "svgWhite")
	}

	if raw, found := object["svgColor"]; found {
		err = json.Unmarshal(raw, &a.SvgColor)
		if err != nil {
			return fmt.Errorf("error reading 'svgColor': %w", err)
		}
		delete(object, "svgColor")
	}

	if raw, found := object["svgComplete"]; found {
		err = json.Unmarshal(raw, &a.SvgComplete)
		if err != nil {
			return fmt.Errorf("error reading 'svgComplete': %w", err)
		}
		delete(object, "svgComplete")
	}

	if raw, found := object["shape"]; found {
		err = json.Unmarshal(raw, &a.Shape)
		if err != nil {
			return fmt.Errorf("error reading 'shape': %w", err)
		}
		delete(object, "shape")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ModelDefinition_Metadata to handle AdditionalProperties
func (a ModelDefinition_Metadata) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Capabilities != nil {
		object["capabilities"], err = json.Marshal(a.Capabilities)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'capabilities': %w", err)
		}
	}

	if a.IsAnnotation != nil {
		object["isAnnotation"], err = json.Marshal(a.IsAnnotation)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'isAnnotation': %w", err)
		}
	}

	if a.PrimaryColor != nil {
		object["primaryColor"], err = json.Marshal(a.PrimaryColor)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'primaryColor': %w", err)
		}
	}

	if a.SecondaryColor != nil {
		object["secondaryColor"], err = json.Marshal(a.SecondaryColor)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'secondaryColor': %w", err)
		}
	}

	object["svgWhite"], err = json.Marshal(a.SvgWhite)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'svgWhite': %w", err)
	}

	object["svgColor"], err = json.Marshal(a.SvgColor)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'svgColor': %w", err)
	}

	if a.SvgComplete != nil {
		object["svgComplete"], err = json.Marshal(a.SvgComplete)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'svgComplete': %w", err)
		}
	}

	if a.Shape != nil {
		object["shape"], err = json.Marshal(a.Shape)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'shape': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// AsImportBody0 returns the union data inside the ImportBody as a ImportBody0
func (t ImportBody) AsImportBody0() (ImportBody0, error) {
	var body ImportBody0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromImportBody0 overwrites any union data inside the ImportBody as the provided ImportBody0
func (t *ImportBody) FromImportBody0(v ImportBody0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeImportBody0 performs a merge with any union data inside the ImportBody, using the provided ImportBody0
func (t *ImportBody) MergeImportBody0(v ImportBody0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsImportBody1 returns the union data inside the ImportBody as a ImportBody1
func (t ImportBody) AsImportBody1() (ImportBody1, error) {
	var body ImportBody1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromImportBody1 overwrites any union data inside the ImportBody as the provided ImportBody1
func (t *ImportBody) FromImportBody1(v ImportBody1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeImportBody1 performs a merge with any union data inside the ImportBody, using the provided ImportBody1
func (t *ImportBody) MergeImportBody1(v ImportBody1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsImportBody2 returns the union data inside the ImportBody as a ImportBody2
func (t ImportBody) AsImportBody2() (ImportBody2, error) {
	var body ImportBody2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromImportBody2 overwrites any union data inside the ImportBody as the provided ImportBody2
func (t *ImportBody) FromImportBody2(v ImportBody2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeImportBody2 performs a merge with any union data inside the ImportBody, using the provided ImportBody2
func (t *ImportBody) MergeImportBody2(v ImportBody2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsImportBody3 returns the union data inside the ImportBody as a ImportBody3
func (t ImportBody) AsImportBody3() (ImportBody3, error) {
	var body ImportBody3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromImportBody3 overwrites any union data inside the ImportBody as the provided ImportBody3
func (t *ImportBody) FromImportBody3(v ImportBody3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeImportBody3 performs a merge with any union data inside the ImportBody, using the provided ImportBody3
func (t *ImportBody) MergeImportBody3(v ImportBody3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ImportBody) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ImportBody) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsImportRequestImportBody0 returns the union data inside the ImportRequest_ImportBody as a ImportRequestImportBody0
func (t ImportRequest_ImportBody) AsImportRequestImportBody0() (ImportRequestImportBody0, error) {
	var body ImportRequestImportBody0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromImportRequestImportBody0 overwrites any union data inside the ImportRequest_ImportBody as the provided ImportRequestImportBody0
func (t *ImportRequest_ImportBody) FromImportRequestImportBody0(v ImportRequestImportBody0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeImportRequestImportBody0 performs a merge with any union data inside the ImportRequest_ImportBody, using the provided ImportRequestImportBody0
func (t *ImportRequest_ImportBody) MergeImportRequestImportBody0(v ImportRequestImportBody0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsImportRequestImportBody1 returns the union data inside the ImportRequest_ImportBody as a ImportRequestImportBody1
func (t ImportRequest_ImportBody) AsImportRequestImportBody1() (ImportRequestImportBody1, error) {
	var body ImportRequestImportBody1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromImportRequestImportBody1 overwrites any union data inside the ImportRequest_ImportBody as the provided ImportRequestImportBody1
func (t *ImportRequest_ImportBody) FromImportRequestImportBody1(v ImportRequestImportBody1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeImportRequestImportBody1 performs a merge with any union data inside the ImportRequest_ImportBody, using the provided ImportRequestImportBody1
func (t *ImportRequest_ImportBody) MergeImportRequestImportBody1(v ImportRequestImportBody1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsImportRequestImportBody2 returns the union data inside the ImportRequest_ImportBody as a ImportRequestImportBody2
func (t ImportRequest_ImportBody) AsImportRequestImportBody2() (ImportRequestImportBody2, error) {
	var body ImportRequestImportBody2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromImportRequestImportBody2 overwrites any union data inside the ImportRequest_ImportBody as the provided ImportRequestImportBody2
func (t *ImportRequest_ImportBody) FromImportRequestImportBody2(v ImportRequestImportBody2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeImportRequestImportBody2 performs a merge with any union data inside the ImportRequest_ImportBody, using the provided ImportRequestImportBody2
func (t *ImportRequest_ImportBody) MergeImportRequestImportBody2(v ImportRequestImportBody2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsImportRequestImportBody3 returns the union data inside the ImportRequest_ImportBody as a ImportRequestImportBody3
func (t ImportRequest_ImportBody) AsImportRequestImportBody3() (ImportRequestImportBody3, error) {
	var body ImportRequestImportBody3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromImportRequestImportBody3 overwrites any union data inside the ImportRequest_ImportBody as the provided ImportRequestImportBody3
func (t *ImportRequest_ImportBody) FromImportRequestImportBody3(v ImportRequestImportBody3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeImportRequestImportBody3 performs a merge with any union data inside the ImportRequest_ImportBody, using the provided ImportRequestImportBody3
func (t *ImportRequest_ImportBody) MergeImportRequestImportBody3(v ImportRequestImportBody3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ImportRequest_ImportBody) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ImportRequest_ImportBody) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}
