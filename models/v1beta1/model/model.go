// Package model provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package model

import (
	"encoding/json"
	"fmt"

	"github.com/gofrs/uuid"
	"github.com/meshery/schemas/models/v1alpha1/capability"
	"github.com/meshery/schemas/models/v1beta1/category"
	"github.com/meshery/schemas/models/v1beta1/connection"
	"github.com/meshery/schemas/models/v1beta1/subcategory"
)

// Defines values for ModelDefinitionStatus.
const (
	Duplicate ModelDefinitionStatus = "duplicate"
	Enabled   ModelDefinitionStatus = "enabled"
	Ignored   ModelDefinitionStatus = "ignored"
)

// Defines values for ModelDefinitionMetadataShape.
const (
	Barrel               ModelDefinitionMetadataShape = "barrel"
	BottomRoundRectangle ModelDefinitionMetadataShape = "bottom-round-rectangle"
	Circle               ModelDefinitionMetadataShape = "circle"
	ConcaveHexagon       ModelDefinitionMetadataShape = "concave-hexagon"
	CutRectangle         ModelDefinitionMetadataShape = "cut-rectangle"
	Diamond              ModelDefinitionMetadataShape = "diamond"
	Ellipse              ModelDefinitionMetadataShape = "ellipse"
	Heptagon             ModelDefinitionMetadataShape = "heptagon"
	Hexagon              ModelDefinitionMetadataShape = "hexagon"
	Octagon              ModelDefinitionMetadataShape = "octagon"
	Pentagon             ModelDefinitionMetadataShape = "pentagon"
	Polygon              ModelDefinitionMetadataShape = "polygon"
	Rectangle            ModelDefinitionMetadataShape = "rectangle"
	Rhomboid             ModelDefinitionMetadataShape = "rhomboid"
	RoundDiamond         ModelDefinitionMetadataShape = "round-diamond"
	RoundHeptagon        ModelDefinitionMetadataShape = "round-heptagon"
	RoundHexagon         ModelDefinitionMetadataShape = "round-hexagon"
	RoundOctagon         ModelDefinitionMetadataShape = "round-octagon"
	RoundPentagon        ModelDefinitionMetadataShape = "round-pentagon"
	RoundRectangle       ModelDefinitionMetadataShape = "round-rectangle"
	RoundTag             ModelDefinitionMetadataShape = "round-tag"
	RoundTriangle        ModelDefinitionMetadataShape = "round-triangle"
	Star                 ModelDefinitionMetadataShape = "star"
	Tag                  ModelDefinitionMetadataShape = "tag"
	Triangle             ModelDefinitionMetadataShape = "triangle"
	Vee                  ModelDefinitionMetadataShape = "vee"
)

// Model Registrant-defined data associated with the model. Properties pertain to the software being managed (e.g. Kubernetes v1.31).
type Model struct {
	// Version Version of the model as defined by the registrant.
	Version string `json:"version" yaml:"version"`
}

// ModelDefinition Meshery Models serve as a portable unit of packaging to define managed entities, their relationships, and capabilities.
type ModelDefinition struct {
	// Id Uniquely identifies the entity (i.e. component) as defined in a declaration (i.e. design).
	Id uuid.UUID `json:"id" yaml:"id"`

	// SchemaVersion Specifies the version of the schema used for the definition.
	SchemaVersion string `json:"schemaVersion" yaml:"schemaVersion"`

	// Version A valid semantic version string between 5 and 256 characters. The pattern allows for a major.minor.patch version followed by an optional pre-release tag like '-alpha' or '-beta.2' and an optional build metadata tag like '+build.1.
	Version string `json:"version" yaml:"version"`

	// Name The unique name for the model within the scope of a registrant.
	Name string `json:"name" yaml:"name"`

	// DisplayName Human-readable name for the model.
	DisplayName string `json:"displayName" yaml:"displayName"`

	// Description Description of the model.
	Description string `json:"description,omitempty" yaml:"description,omitempty"`

	// Status Status of model, including:
	// - duplicate: this component is a duplicate of another. The component that is to be the canonical reference and that is duplicated by other components should not be assigned the 'duplicate' status.
	// - maintenance: model is unavailable for a period of time.
	// - enabled: model is available for use for all users of this Meshery Server.
	// - ignored: model is unavailable for use for all users of this Meshery Server.
	Status ModelDefinitionStatus `json:"status" yaml:"status"`

	// CategoryId ID of the category.
	CategoryId uuid.UUID `gorm:"categoryID" json:"-" yaml:"-"`

	// Registrant Meshery Connections are managed and unmanaged resources that either through discovery or manual entry are tracked by Meshery. Learn more at https://docs.meshery.io/concepts/logical/connections
	Registrant connection.Connection `gorm:"foreignKey:RegistrantId;references:Id" json:"registrant" yaml:"registrant"`

	// RegistrantId ID of the registrant.
	RegistrantId uuid.UUID `gorm:"column:connection_id" json:"connection_id" yaml:"connection_id"`

	// Category Category of the model.
	Category category.CategoryDefinition `gorm:"foreignKey:CategoryId;references:Id" json:"category" yaml:"category"`

	// SubCategory Sub category of the model determines the secondary grouping.
	SubCategory subcategory.SubCategoryDefinition `json:"subCategory" yaml:"subCategory"`

	// Metadata Metadata containing additional information associated with the model.
	Metadata *ModelDefinition_Metadata `gorm:"type:bytes;serializer:json" json:"metadata" yaml:"metadata"`

	// Model Registrant-defined data associated with the model. Properties pertain to the software being managed (e.g. Kubernetes v1.31).
	Model struct {
		// Version Version of the model as defined by the registrant.
		Version string `json:"version" yaml:"version"`
	} `gorm:"type:bytes;serializer:json" json:"model" yaml:"model"`

	// ComponentsCount Number of components associated with the model.
	ComponentsCount int `gorm:"-" json:"components_count" yaml:"components_count"`

	// RelationshipsCount Number of relationships associated with the model.
	RelationshipsCount int         `gorm:"-" json:"relationships_count" yaml:"relationships_count"`
	Components         interface{} `gorm:"-" json:"components" yaml:"components"`
	Relationships      interface{} `gorm:"-" json:"relationships" yaml:"relationships"`
}

// ModelDefinitionStatus Status of model, including:
// - duplicate: this component is a duplicate of another. The component that is to be the canonical reference and that is duplicated by other components should not be assigned the 'duplicate' status.
// - maintenance: model is unavailable for a period of time.
// - enabled: model is available for use for all users of this Meshery Server.
// - ignored: model is unavailable for use for all users of this Meshery Server.
type ModelDefinitionStatus string

// ModelDefinitionMetadataShape The shape of the node’s body. Note that each shape fits within the specified width and height, and so you may have to adjust width and height if you desire an equilateral shape (i.e. width !== height for several equilateral shapes)
type ModelDefinitionMetadataShape string

// ModelDefinition_Metadata Metadata containing additional information associated with the model.
type ModelDefinition_Metadata struct {
	// Capabilities Capabilities associated with the model
	Capabilities *[]capability.Capability `json:"capabilities,omitempty" yaml:"capabilities,omitempty"`

	// IsAnnotation Indicates whether the model and its entities should be treated as deployable entities or as logical representations.
	IsAnnotation *bool `json:"isAnnotation" yaml:"isAnnotation"`

	// PrimaryColor Primary color associated with the model.
	PrimaryColor *string `json:"primaryColor" yaml:"primaryColor"`

	// SecondaryColor Secondary color associated with the model.
	SecondaryColor *string `json:"secondaryColor" yaml:"secondaryColor"`

	// SvgWhite SVG representation of the model in white color.
	SvgWhite string `json:"svgWhite" yaml:"svgWhite"`

	// SvgColor SVG representation of the model in colored format.
	SvgColor string `json:"svgColor" yaml:"svgColor"`

	// SvgComplete SVG representation of the complete model.
	SvgComplete *string `json:"svgComplete" yaml:"svgComplete"`

	// Shape The shape of the node’s body. Note that each shape fits within the specified width and height, and so you may have to adjust width and height if you desire an equilateral shape (i.e. width !== height for several equilateral shapes)
	Shape                *ModelDefinitionMetadataShape `json:"shape,omitempty"`
	AdditionalProperties map[string]interface{}        `json:"-" yaml:"-"`
}

// Getter for additional properties for ModelDefinition_Metadata. Returns the specified
// element and whether it was found
func (a ModelDefinition_Metadata) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ModelDefinition_Metadata
func (a *ModelDefinition_Metadata) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ModelDefinition_Metadata to handle AdditionalProperties
func (a *ModelDefinition_Metadata) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["capabilities"]; found {
		err = json.Unmarshal(raw, &a.Capabilities)
		if err != nil {
			return fmt.Errorf("error reading 'capabilities': %w", err)
		}
		delete(object, "capabilities")
	}

	if raw, found := object["isAnnotation"]; found {
		err = json.Unmarshal(raw, &a.IsAnnotation)
		if err != nil {
			return fmt.Errorf("error reading 'isAnnotation': %w", err)
		}
		delete(object, "isAnnotation")
	}

	if raw, found := object["primaryColor"]; found {
		err = json.Unmarshal(raw, &a.PrimaryColor)
		if err != nil {
			return fmt.Errorf("error reading 'primaryColor': %w", err)
		}
		delete(object, "primaryColor")
	}

	if raw, found := object["secondaryColor"]; found {
		err = json.Unmarshal(raw, &a.SecondaryColor)
		if err != nil {
			return fmt.Errorf("error reading 'secondaryColor': %w", err)
		}
		delete(object, "secondaryColor")
	}

	if raw, found := object["svgWhite"]; found {
		err = json.Unmarshal(raw, &a.SvgWhite)
		if err != nil {
			return fmt.Errorf("error reading 'svgWhite': %w", err)
		}
		delete(object, "svgWhite")
	}

	if raw, found := object["svgColor"]; found {
		err = json.Unmarshal(raw, &a.SvgColor)
		if err != nil {
			return fmt.Errorf("error reading 'svgColor': %w", err)
		}
		delete(object, "svgColor")
	}

	if raw, found := object["svgComplete"]; found {
		err = json.Unmarshal(raw, &a.SvgComplete)
		if err != nil {
			return fmt.Errorf("error reading 'svgComplete': %w", err)
		}
		delete(object, "svgComplete")
	}

	if raw, found := object["shape"]; found {
		err = json.Unmarshal(raw, &a.Shape)
		if err != nil {
			return fmt.Errorf("error reading 'shape': %w", err)
		}
		delete(object, "shape")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ModelDefinition_Metadata to handle AdditionalProperties
func (a ModelDefinition_Metadata) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Capabilities != nil {
		object["capabilities"], err = json.Marshal(a.Capabilities)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'capabilities': %w", err)
		}
	}

	if a.IsAnnotation != nil {
		object["isAnnotation"], err = json.Marshal(a.IsAnnotation)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'isAnnotation': %w", err)
		}
	}

	if a.PrimaryColor != nil {
		object["primaryColor"], err = json.Marshal(a.PrimaryColor)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'primaryColor': %w", err)
		}
	}

	if a.SecondaryColor != nil {
		object["secondaryColor"], err = json.Marshal(a.SecondaryColor)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'secondaryColor': %w", err)
		}
	}

	object["svgWhite"], err = json.Marshal(a.SvgWhite)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'svgWhite': %w", err)
	}

	object["svgColor"], err = json.Marshal(a.SvgColor)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'svgColor': %w", err)
	}

	if a.SvgComplete != nil {
		object["svgComplete"], err = json.Marshal(a.SvgComplete)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'svgComplete': %w", err)
		}
	}

	if a.Shape != nil {
		object["shape"], err = json.Marshal(a.Shape)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'shape': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}
