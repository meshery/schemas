// Package model provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.3.0 DO NOT EDIT.
package model

import (
	"encoding/json"
	"fmt"

	"github.com/gofrs/uuid"
	"github.com/meshery/schemas/models/v1alpha1/capability"
	"github.com/meshery/schemas/models/v1beta1/category"
	"github.com/meshery/schemas/models/v1beta1/connection"
)

// Defines values for ModelDefinitionMetadataCapabilitiesEntityState.
const (
	Declaration ModelDefinitionMetadataCapabilitiesEntityState = "declaration"
	Instance    ModelDefinitionMetadataCapabilitiesEntityState = "instance"
)

// Defines values for ModelDefinitionMetadataCapabilitiesStatus.
const (
	ModelDefinitionMetadataCapabilitiesStatusDisabled ModelDefinitionMetadataCapabilitiesStatus = "disabled"
	ModelDefinitionMetadataCapabilitiesStatusEnabled  ModelDefinitionMetadataCapabilitiesStatus = "enabled"
)

// Defines values for ModelDefinitionRegistrantStatus.
const (
	Connected    ModelDefinitionRegistrantStatus = "connected"
	Deleted      ModelDefinitionRegistrantStatus = "deleted"
	Disconnected ModelDefinitionRegistrantStatus = "disconnected"
	Discovered   ModelDefinitionRegistrantStatus = "discovered"
	Ignored      ModelDefinitionRegistrantStatus = "ignored"
	Maintenance  ModelDefinitionRegistrantStatus = "maintenance"
	NotFound     ModelDefinitionRegistrantStatus = "not found"
	Registered   ModelDefinitionRegistrantStatus = "registered"
)

// Defines values for ModelDefinitionStatus.
const (
	ModelDefinitionStatusDuplicate ModelDefinitionStatus = "duplicate"
	ModelDefinitionStatusEnabled   ModelDefinitionStatus = "enabled"
	ModelDefinitionStatusIgnored   ModelDefinitionStatus = "ignored"
)

type Model struct {
	// Version Version of the model as defined by the registrant.
	Version string `json:"version" yaml:"version"`
}

// ModelDefinition Meshery Models serve as a portable unit of packaging to define managed entities, their relationships, and capabilities.
// ModelDefinition Meshery Models serve as a portable unit of packaging to define managed entities, their relationships, and capabilities.
type ModelDefinition struct {
	// Id Uniquely identifies the entity (i.e. component) as defined in a declaration (i.e. design).
	Id uuid.UUID `json:"id" yaml:"id"`

	// SchemaVersion Specifies the version of the schema used for the definition.
	SchemaVersion string `json:"schemaVersion" yaml:"schemaVersion"`

	// Version Version of the model definition.
	Version string `json:"version" yaml:"version"`

	// Name The unique name for the model within the scope of a registrant.
	Name string `json:"name" yaml:"name"`

	// DisplayName Human-readable name for the model.
	DisplayName string `json:"displayName" yaml:"displayName"`

	// Description Description of the model.
	Description string `json:"description,omitempty" yaml:"description,omitempty"`

	// Status Status of model, including:
	// - duplicate: this component is a duplicate of another. The component that is to be the canonical reference and that is duplicated by other components should not be assigned the 'duplicate' status.
	// - maintenance: model is unavailable for a period of time.
	// - enabled: model is available for use for all users of this Meshery Server.
	// - ignored: model is unavailable for use for all users of this Meshery Server.
	Status ModelDefinitionStatus `json:"status" yaml:"status"`

	// Registrant Meshery Connections are managed and unmanaged resources that either through discovery or manual entry are tracked by Meshery. Learn more at https://docs.meshery.io/concepts/logical/connections
	Registrant connection.Connection `gorm:"foreignKey:RegistrantId;references:Id" json:"registrant" yaml:"registrant"`

	RegistrantId uuid.UUID `json:"connection_id" gorm:"column:connection_id" yaml:"connection_id"`

	// Category Category of the model.
	Category category.CategoryDefinition `json:"category" yaml:"category" gorm:"foreignKey:CategoryId;references:Id"`

	CategoryId uuid.UUID `json:"-" yaml:"-" gorm:"categoryID"`

	// SubCategory Sub-category of the model.
	SubCategory string `json:"subCategory,omitempty" yaml:"subCategory,omitempty"`

	// Metadata Metadata containing additional information associated with the model.
	Metadata *ModelDefinition_Metadata `gorm:"type:bytes;serializer:json" json:"metadata,omitempty" yaml:"metadata"`

	// Model Registrant-defined data associated with the model. Properties pertain to the software being managed (e.g. Kubernetes v1.31)
	Model Model `gorm:"type:bytes;serializer:json" json:"model,omitempty" yaml:"model"`

	Components interface{} `json:"components" gorm:"-" yaml:"components"`

	// To prevent cyclic error, the type is changed to interface, it doesn't affect registration
	// Edited on purpose
	Relationships interface{} `json:"relationships" gorm:"-" yaml:"relationships"`

	// Total number of components in a model
	// Edited on purpose
	ComponentsCount int `json:"components_count" gorm:"-" yaml:"components_count"`

	// Total number of relationships in a model
	// Edited on purpose
	RelationshipsCount int `json:"relationships_count" gorm:"-" yaml:"relationships_count"`
}

// ModelDefinitionMetadataCapabilitiesEntityState defines model for ModelDefinition.Metadata.Capabilities.EntityState.
type ModelDefinitionMetadataCapabilitiesEntityState string

// ModelDefinitionMetadataCapabilitiesStatus Status of the capability
type ModelDefinitionMetadataCapabilitiesStatus string

// ModelDefinition_Metadata Metadata containing additional information associated with the model.
type ModelDefinition_Metadata struct {
	// Capabilities Meshery manages entities in accordance with their specific capabilities. This field explicitly identifies those capabilities largely by what actions a given component supports; e.g. metric-scrape, sub-interface, and so on. This field is extensible. Entities may define a broad array of capabilities, which are in-turn dynamically interpretted by Meshery for full lifecycle management.
	Capabilities *[]capability.Capability `json:"capabilities,omitempty" yaml:"capabilities"`

	// IsAnnotation Indicates whether the model and its entities should be treated as deployable entities or as logical representations.
	IsAnnotation *bool `json:"isAnnotation" yaml:"isAnnotation"`

	// PrimaryColor Primary color associated with the model.
	PrimaryColor *string `json:"primaryColor" yaml:"primaryColor"`

	// SecondaryColor Secondary color associated with the model.
	SecondaryColor *string `json:"secondaryColor" yaml:"secondaryColor"`

	// SvgColor SVG representation of the model in colored format.
	SvgColor string `json:"svgColor" yaml:"svgColor"`

	// SvgComplete SVG representation of the complete model.
	SvgComplete *string `json:"svgComplete,omitempty" yaml:"svgComplete,omitempty"`

	// SvgWhite SVG representation of the model in white color.
	SvgWhite             string                 `json:"svgWhite" yaml:"svgWhite"`
	AdditionalProperties map[string]interface{} `json:"-" yaml:"-"`
}

// ModelDefinitionRegistrantStatus Connection Status
type ModelDefinitionRegistrantStatus string

// ModelDefinitionStatus Status of model, including:
// - duplicate: this component is a duplicate of another. The component that is to be the canonical reference and that is duplicated by other components should not be assigned the 'duplicate' status.
// - maintenance: model is unavailable for a period of time.
// - enabled: model is available for use for all users of this Meshery Server.
// - ignored: model is unavailable for use for all users of this Meshery Server.
type ModelDefinitionStatus string

// Getter for additional properties for ModelDefinition_Metadata. Returns the specified
// element and whether it was found
func (a ModelDefinition_Metadata) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ModelDefinition_Metadata
func (a *ModelDefinition_Metadata) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ModelDefinition_Metadata to handle AdditionalProperties
func (a *ModelDefinition_Metadata) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["capabilities"]; found {
		err = json.Unmarshal(raw, &a.Capabilities)
		if err != nil {
			return fmt.Errorf("error reading 'capabilities': %w", err)
		}
		delete(object, "capabilities")
	}

	if raw, found := object["isAnnotation"]; found {
		err = json.Unmarshal(raw, &a.IsAnnotation)
		if err != nil {
			return fmt.Errorf("error reading 'isAnnotation': %w", err)
		}
		delete(object, "isAnnotation")
	}

	if raw, found := object["primaryColor"]; found {
		err = json.Unmarshal(raw, &a.PrimaryColor)
		if err != nil {
			return fmt.Errorf("error reading 'primaryColor': %w", err)
		}
		delete(object, "primaryColor")
	}

	if raw, found := object["secondaryColor"]; found {
		err = json.Unmarshal(raw, &a.SecondaryColor)
		if err != nil {
			return fmt.Errorf("error reading 'secondaryColor': %w", err)
		}
		delete(object, "secondaryColor")
	}

	if raw, found := object["svgColor"]; found {
		err = json.Unmarshal(raw, &a.SvgColor)
		if err != nil {
			return fmt.Errorf("error reading 'svgColor': %w", err)
		}
		delete(object, "svgColor")
	}

	if raw, found := object["svgComplete"]; found {
		err = json.Unmarshal(raw, &a.SvgComplete)
		if err != nil {
			return fmt.Errorf("error reading 'svgComplete': %w", err)
		}
		delete(object, "svgComplete")
	}

	if raw, found := object["svgWhite"]; found {
		err = json.Unmarshal(raw, &a.SvgWhite)
		if err != nil {
			return fmt.Errorf("error reading 'svgWhite': %w", err)
		}
		delete(object, "svgWhite")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ModelDefinition_Metadata to handle AdditionalProperties
func (a ModelDefinition_Metadata) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Capabilities != nil {
		object["capabilities"], err = json.Marshal(a.Capabilities)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'capabilities': %w", err)
		}
	}

	if a.IsAnnotation != nil {
		object["isAnnotation"], err = json.Marshal(a.IsAnnotation)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'isAnnotation': %w", err)
		}
	}

	if a.PrimaryColor != nil {
		object["primaryColor"], err = json.Marshal(a.PrimaryColor)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'primaryColor': %w", err)
		}
	}

	if a.SecondaryColor != nil {
		object["secondaryColor"], err = json.Marshal(a.SecondaryColor)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'secondaryColor': %w", err)
		}
	}

	object["svgColor"], err = json.Marshal(a.SvgColor)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'svgColor': %w", err)
	}

	if a.SvgComplete != nil {
		object["svgComplete"], err = json.Marshal(a.SvgComplete)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'svgComplete': %w", err)
		}
	}

	object["svgWhite"], err = json.Marshal(a.SvgWhite)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'svgWhite': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}
