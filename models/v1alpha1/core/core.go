// Package core provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package core

import (
	"encoding/json"
	"fmt"
	"time"

	"database/sql"

	"github.com/gofrs/uuid"
	"github.com/meshery/schemas/models/v1alpha1/core"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// Defines values for IaCFileTypes.
const (
	DockerCompose IaCFileTypes = "docker-compose"
	HelmChart     IaCFileTypes = "helm-chart"
	K8sKustomize  IaCFileTypes = "k8s-kustomize"
	K8sManifest   IaCFileTypes = "k8s-manifest"
	MesheryDesign IaCFileTypes = "meshery-design"
)

// Defines values for ComponentStylesBorderStyle.
const (
	Dashed ComponentStylesBorderStyle = "dashed"
	Dotted ComponentStylesBorderStyle = "dotted"
	Double ComponentStylesBorderStyle = "double"
	Solid  ComponentStylesBorderStyle = "solid"
)

// Defines values for ComponentStylesGhost.
const (
	No  ComponentStylesGhost = "no"
	Yes ComponentStylesGhost = "yes"
)

// Defines values for ComponentStylesShape.
const (
	ComponentStylesShapeBarrel               ComponentStylesShape = "barrel"
	ComponentStylesShapeBottomRoundRectangle ComponentStylesShape = "bottom-round-rectangle"
	ComponentStylesShapeConcaveHexagon       ComponentStylesShape = "concave-hexagon"
	ComponentStylesShapeCutRectangle         ComponentStylesShape = "cut-rectangle"
	ComponentStylesShapeDiamond              ComponentStylesShape = "diamond"
	ComponentStylesShapeEllipse              ComponentStylesShape = "ellipse"
	ComponentStylesShapeHeptagon             ComponentStylesShape = "heptagon"
	ComponentStylesShapeHexagon              ComponentStylesShape = "hexagon"
	ComponentStylesShapeOctagon              ComponentStylesShape = "octagon"
	ComponentStylesShapePentagon             ComponentStylesShape = "pentagon"
	ComponentStylesShapePolygon              ComponentStylesShape = "polygon"
	ComponentStylesShapeRectangle            ComponentStylesShape = "rectangle"
	ComponentStylesShapeRhomboid             ComponentStylesShape = "rhomboid"
	ComponentStylesShapeRoundDiamond         ComponentStylesShape = "round-diamond"
	ComponentStylesShapeRoundHeptagon        ComponentStylesShape = "round-heptagon"
	ComponentStylesShapeRoundHexagon         ComponentStylesShape = "round-hexagon"
	ComponentStylesShapeRoundOctagon         ComponentStylesShape = "round-octagon"
	ComponentStylesShapeRoundPentagon        ComponentStylesShape = "round-pentagon"
	ComponentStylesShapeRoundRectangle       ComponentStylesShape = "round-rectangle"
	ComponentStylesShapeRoundTag             ComponentStylesShape = "round-tag"
	ComponentStylesShapeRoundTriangle        ComponentStylesShape = "round-triangle"
	ComponentStylesShapeStar                 ComponentStylesShape = "star"
	ComponentStylesShapeTag                  ComponentStylesShape = "tag"
	ComponentStylesShapeTriangle             ComponentStylesShape = "triangle"
	ComponentStylesShapeVee                  ComponentStylesShape = "vee"
)

// Defines values for ComponentStylesTextHalign.
const (
	ComponentStylesTextHalignCenter ComponentStylesTextHalign = "center"
	ComponentStylesTextHalignLeft   ComponentStylesTextHalign = "left"
	ComponentStylesTextHalignRight  ComponentStylesTextHalign = "right"
)

// Defines values for ComponentStylesTextTransform.
const (
	ComponentStylesTextTransformLowercase ComponentStylesTextTransform = "lowercase"
	ComponentStylesTextTransformNone      ComponentStylesTextTransform = "none"
	ComponentStylesTextTransformUppercase ComponentStylesTextTransform = "uppercase"
)

// Defines values for ComponentStylesTextValign.
const (
	ComponentStylesTextValignBottom ComponentStylesTextValign = "bottom"
	ComponentStylesTextValignCenter ComponentStylesTextValign = "center"
	ComponentStylesTextValignTop    ComponentStylesTextValign = "top"
)

// Defines values for RelationshipStyles1TextTransform.
const (
	RelationshipStyles1TextTransformLowercase RelationshipStyles1TextTransform = "lowercase"
	RelationshipStyles1TextTransformNone      RelationshipStyles1TextTransform = "none"
	RelationshipStyles1TextTransformUppercase RelationshipStyles1TextTransform = "uppercase"
)

// Defines values for Shape.
const (
	ShapeBarrel               Shape = "barrel"
	ShapeBottomRoundRectangle Shape = "bottom-round-rectangle"
	ShapeConcaveHexagon       Shape = "concave-hexagon"
	ShapeCutRectangle         Shape = "cut-rectangle"
	ShapeDiamond              Shape = "diamond"
	ShapeEllipse              Shape = "ellipse"
	ShapeHeptagon             Shape = "heptagon"
	ShapeHexagon              Shape = "hexagon"
	ShapeOctagon              Shape = "octagon"
	ShapePentagon             Shape = "pentagon"
	ShapePolygon              Shape = "polygon"
	ShapeRectangle            Shape = "rectangle"
	ShapeRhomboid             Shape = "rhomboid"
	ShapeRoundDiamond         Shape = "round-diamond"
	ShapeRoundHeptagon        Shape = "round-heptagon"
	ShapeRoundHexagon         Shape = "round-hexagon"
	ShapeRoundOctagon         Shape = "round-octagon"
	ShapeRoundPentagon        Shape = "round-pentagon"
	ShapeRoundRectangle       Shape = "round-rectangle"
	ShapeRoundTag             Shape = "round-tag"
	ShapeRoundTriangle        Shape = "round-triangle"
	ShapeStar                 Shape = "star"
	ShapeTag                  Shape = "tag"
	ShapeTriangle             Shape = "triangle"
	ShapeVee                  Shape = "vee"
)

// Defines values for StylesTextTransform.
const (
	Lowercase StylesTextTransform = "lowercase"
	None      StylesTextTransform = "none"
	Uppercase StylesTextTransform = "uppercase"
)

// Endpoint endpoint
type Endpoint = string

// IaCFileTypes The type of the IaC file
type IaCFileTypes string

// Id defines model for Id.
type Id = uuid.UUID

// MapObject defines model for MapObject.
type MapObject map[string]string

// NonResolvedAlias An alias is an component that acts as an ref/pointer to a field in another component, nonResolvedAlias are not aware of there immediate parents
type NonResolvedAlias struct {
	// AliasComponentId A Universally Unique Identifier used to uniquely identify entities in Meshery. The UUID core definition is used across different schemas.
	AliasComponentId uuid.UUID `json:"alias_component_id" yaml:"alias_component_id"`

	// ImmediateParentId A Universally Unique Identifier used to uniquely identify entities in Meshery. The UUID core definition is used across different schemas.
	ImmediateParentId     uuid.UUID `json:"immediate_parent_id" yaml:"immediate_parent_id"`
	ImmediateRefFieldPath []string  `json:"immediate_ref_field_path" yaml:"immediate_ref_field_path"`

	// RelationshipId A Universally Unique Identifier used to uniquely identify entities in Meshery. The UUID core definition is used across different schemas.
	RelationshipId uuid.UUID `json:"relationship_id" yaml:"relationship_id"`
}

// ResolvedAlias defines model for ResolvedAlias.
type ResolvedAlias struct {
	// AliasComponentId A Universally Unique Identifier used to uniquely identify entities in Meshery. The UUID core definition is used across different schemas.
	AliasComponentId uuid.UUID `json:"alias_component_id" yaml:"alias_component_id"`

	// ImmediateParentId A Universally Unique Identifier used to uniquely identify entities in Meshery. The UUID core definition is used across different schemas.
	ImmediateParentId     uuid.UUID `json:"immediate_parent_id" yaml:"immediate_parent_id"`
	ImmediateRefFieldPath []string  `json:"immediate_ref_field_path" yaml:"immediate_ref_field_path"`

	// RelationshipId A Universally Unique Identifier used to uniquely identify entities in Meshery. The UUID core definition is used across different schemas.
	RelationshipId uuid.UUID `json:"relationship_id" yaml:"relationship_id"`

	// ResolvedParentId A Universally Unique Identifier used to uniquely identify entities in Meshery. The UUID core definition is used across different schemas.
	ResolvedParentId     uuid.UUID `json:"resolved_parent_id" yaml:"resolved_parent_id"`
	ResolvedRefFieldPath []string  `json:"resolved_ref_field_path" yaml:"resolved_ref_field_path"`
}

// SqlNullTime defines model for SqlNullTime.
type SqlNullTime = sql.NullTime

// Text defines model for Text.
type Text = string

// Time defines model for Time.
type Time = time.Time

// AcceptedTermsAt defines model for accepted_terms_at.
type AcceptedTermsAt = string

// AvatarUrl Link for profile picture
type AvatarUrl = string

// Bio defines model for bio.
type Bio = string

// ComponentStyles defines model for componentStyles.
type ComponentStyles struct {
	// ActiveBgColor The colour of the indicator shown when the background is grabbed by the user. Selector needs to be *core*. Colours may be specified by name (e.g. red), hex (e.g.
	ActiveBgColor *string `json:"active-bg-color,omitempty" yaml:"active-bg-color,omitempty"`

	// ActiveBgOpacity The opacity of the active background indicator. Selector needs to be *core*.
	ActiveBgOpacity *string `json:"active-bg-opacity,omitempty" yaml:"active-bg-opacity,omitempty"`

	// ActiveBgSize The opacity of the active background indicator. Selector needs to be *core*.
	ActiveBgSize *string `json:"active-bg-size,omitempty" yaml:"active-bg-size,omitempty"`

	// Animation The animation to apply to the element. example ripple,bounce,etc
	Animation *map[string]interface{} `json:"animation,omitempty" yaml:"animation,omitempty"`

	// BackgroundBlacken Blackens the node's body for values from 0 to 1; whitens the node's body for values from 0 to -1.
	BackgroundBlacken *float32 `json:"background-blacken,omitempty" yaml:"background-blacken,omitempty"`

	// BackgroundClip How the background image is clipped to the node. Can be 'none', 'node', or 'node-border'.
	BackgroundClip *string `json:"background-clip,omitempty" yaml:"background-clip,omitempty"`

	// BackgroundColor The colour of the node's body. Colours may be specified by name (e.g. red), hex (e.g.
	BackgroundColor *string `json:"background-color,omitempty" yaml:"background-color,omitempty"`

	// BackgroundFit How the background image is fit to the node. Can be 'none', 'contain', or 'cover'.
	BackgroundFit *string `json:"background-fit,omitempty" yaml:"background-fit,omitempty"`

	// BackgroundHeightRelativeTo How the background image's height is determined. Can be 'none', 'inner', or 'outer'.
	BackgroundHeightRelativeTo *string `json:"background-height-relative-to,omitempty" yaml:"background-height-relative-to,omitempty"`

	// BackgroundImage The URL that points to the image to show in the node.
	BackgroundImage *string `json:"background-image,omitempty" yaml:"background-image,omitempty"`

	// BackgroundOffsetX The x offset of the background image, measured in percent (e.g. 50%) or pixels (e.g. 10px)
	BackgroundOffsetX *string `json:"background-offset-x,omitempty" yaml:"background-offset-x,omitempty"`

	// BackgroundOffsetY The y offset of the background image, measured in percent (e.g. 50%) or pixels (e.g. 10px)
	BackgroundOffsetY *string `json:"background-offset-y,omitempty" yaml:"background-offset-y,omitempty"`

	// BackgroundOpacity The opacity level of the node's background colour
	BackgroundOpacity *float32 `json:"background-opacity,omitempty" yaml:"background-opacity,omitempty"`

	// BackgroundPositionX The x position of the background image, measured in percent (e.g. 50%) or pixels (e.g. 10px)
	BackgroundPositionX *string `json:"background-position-x,omitempty" yaml:"background-position-x,omitempty"`

	// BackgroundPositionY The y position of the background image, measured in percent (e.g. 50%) or pixels (e.g. 10px)
	BackgroundPositionY *string `json:"background-position-y,omitempty" yaml:"background-position-y,omitempty"`

	// BackgroundWidthRelativeTo How the background image's width is determined. Can be 'none', 'inner', or 'outer'.
	BackgroundWidthRelativeTo *string `json:"background-width-relative-to,omitempty" yaml:"background-width-relative-to,omitempty"`

	// BodyText The text to display for an element's body. Can give a path, e.g. data(id) will label with the elements id
	BodyText *string `json:"body-text,omitempty" yaml:"body-text,omitempty"`

	// BodyTextBackgroundColor The colour of the node's body text background. Colours may be specified by name (e.g. red), hex (e.g.
	BodyTextBackgroundColor *string `json:"body-text-background-color,omitempty" yaml:"body-text-background-color,omitempty"`

	// BodyTextColor The colour of the node's body text. Colours may be specified by name (e.g. red), hex (e.g.
	BodyTextColor *string `json:"body-text-color,omitempty" yaml:"body-text-color,omitempty"`

	// BodyTextDecoration A CSS text decoration to be applied to the node's body text.
	BodyTextDecoration *string `json:"body-text-decoration,omitempty" yaml:"body-text-decoration,omitempty"`

	// BodyTextFontSize The size of the node's body text.
	BodyTextFontSize *float32 `json:"body-text-font-size,omitempty" yaml:"body-text-font-size,omitempty"`

	// BodyTextFontWeight A CSS font weight to be applied to the node's body text.
	BodyTextFontWeight *string `json:"body-text-font-weight,omitempty" yaml:"body-text-font-weight,omitempty"`

	// BodyTextHorizontalAlign A CSS horizontal alignment to be applied to the node's body text.
	BodyTextHorizontalAlign *string `json:"body-text-horizontal-align,omitempty" yaml:"body-text-horizontal-align,omitempty"`

	// BodyTextMaxWidth The maximum width for wrapping text in the node.
	BodyTextMaxWidth *string `json:"body-text-max-width,omitempty" yaml:"body-text-max-width,omitempty"`

	// BodyTextOpacity The opacity of the node's body text, including its outline.
	BodyTextOpacity *float32 `json:"body-text-opacity,omitempty" yaml:"body-text-opacity,omitempty"`

	// BodyTextVerticalAlign A CSS vertical alignment to be applied to the node's body text.
	BodyTextVerticalAlign *string `json:"body-text-vertical-align,omitempty" yaml:"body-text-vertical-align,omitempty"`

	// BodyTextWrap How to wrap the text in the node. Can be 'none', 'wrap', or 'ellipsis'.
	BodyTextWrap *string `json:"body-text-wrap,omitempty" yaml:"body-text-wrap,omitempty"`

	// BorderColor The colour of the node's border. Colours may be specified by name (e.g. red), hex (e.g.
	BorderColor *string `json:"border-color,omitempty" yaml:"border-color,omitempty"`

	// BorderOpacity The opacity of the node's border
	BorderOpacity *float32 `json:"border-opacity,omitempty" yaml:"border-opacity,omitempty"`

	// BorderStyle The style of the node's border
	BorderStyle *ComponentStylesBorderStyle `json:"border-style,omitempty" yaml:"border-style,omitempty"`

	// BorderWidth The size of the node's border.
	BorderWidth *float32 `json:"border-width,omitempty" yaml:"border-width,omitempty"`

	// Color The color of the element's label. Colours may be specified by name (e.g. red), hex (e.g.
	Color *string `json:"color,omitempty" yaml:"color,omitempty"`

	// FontFamily A comma-separated list of font names to use on the label text.
	FontFamily *string `json:"font-family,omitempty" yaml:"font-family,omitempty"`

	// FontSize The size of the label text.
	FontSize *string `json:"font-size,omitempty" yaml:"font-size,omitempty"`

	// FontStyle A CSS font style to be applied to the label text.
	FontStyle *string `json:"font-style,omitempty" yaml:"font-style,omitempty"`

	// FontWeight A CSS font weight to be applied to the label text.
	FontWeight *string `json:"font-weight,omitempty" yaml:"font-weight,omitempty"`

	// Ghost Whether to use the ghost effect, a semitransparent duplicate of the element drawn at an offset.
	Ghost *ComponentStylesGhost `json:"ghost,omitempty" yaml:"ghost,omitempty"`

	// Height The height of the node's body
	Height *float32 `json:"height,omitempty" yaml:"height,omitempty"`

	// Label The text to display for an element's label. Can give a path, e.g. data(id) will label with the elements id
	Label *string `json:"label,omitempty" yaml:"label,omitempty"`

	// MenuBackgroundColor The colour of the background of the component menu. Colours may be specified by name (e.g. red), hex (e.g.
	MenuBackgroundColor *string `json:"menu-background-color,omitempty" yaml:"menu-background-color,omitempty"`

	// MenuBackgroundOpacity The opacity of the background of the component menu.
	MenuBackgroundOpacity *float32 `json:"menu-background-opacity,omitempty" yaml:"menu-background-opacity,omitempty"`

	// MenuForgroundColor The colour of the text or icons in the component menu. Colours may be specified by name (e.g. red), hex (e.g.
	MenuForgroundColor *string `json:"menu-forground-color,omitempty" yaml:"menu-forground-color,omitempty"`

	// Opacity The opacity of the element, ranging from 0 to 1. Note that the opacity of a compound node parent affects the effective opacity of its children.
	Opacity *float32 `json:"opacity,omitempty" yaml:"opacity,omitempty"`

	// OutsideTextureBgColor The colour of the area outside the viewport texture when initOptions.textureOnViewport === true. Selector needs to be *core*. Colours may be specified by name (e.g. red), hex (e.g.
	OutsideTextureBgColor *string `json:"outside-texture-bg-color,omitempty" yaml:"outside-texture-bg-color,omitempty"`

	// OutsideTextureBgOpacity The opacity of the area outside the viewport texture. Selector needs to be *core*
	OutsideTextureBgOpacity *float32 `json:"outside-texture-bg-opacity,omitempty" yaml:"outside-texture-bg-opacity,omitempty"`

	// Padding The amount of padding around all sides of the node.
	Padding *float32 `json:"padding,omitempty" yaml:"padding,omitempty"`

	// Position The position of the node. If the position is set, the node is drawn at that position in the given dimensions. If the position is not set, the node is drawn at a random position.
	Position *struct {
		// X The x-coordinate of the node.
		X float64 `json:"x" yaml:"x"`

		// Y The y-coordinate of the node.
		Y float64 `json:"y" yaml:"y"`
	} `json:"position,omitempty" yaml:"position,omitempty"`

	// PrimaryColor Primary color of the component used for UI representation.
	PrimaryColor string `json:"primaryColor" yaml:"primaryColor"`

	// SecondaryColor Secondary color of the entity used for UI representation.
	SecondaryColor *string `json:"secondaryColor,omitempty" yaml:"secondaryColor,omitempty"`

	// SelectionBoxBorderWidth The size of the border on the selection box. Selector needs to be *core*
	SelectionBoxBorderWidth *float32 `json:"selection-box-border-width,omitempty" yaml:"selection-box-border-width,omitempty"`

	// SelectionBoxColor The background colour of the selection box used for drag selection. Selector needs to be *core*. Colours may be specified by name (e.g. red), hex (e.g.
	SelectionBoxColor *string `json:"selection-box-color,omitempty" yaml:"selection-box-color,omitempty"`

	// SelectionBoxOpacity The opacity of the selection box. Selector needs to be *core*
	SelectionBoxOpacity *float32 `json:"selection-box-opacity,omitempty" yaml:"selection-box-opacity,omitempty"`

	// Shape The shape of the node's body. Note that each shape fits within the specified width and height, and so you may have to adjust width and height if you desire an equilateral shape (i.e. width !== height for several equilateral shapes)
	Shape *ComponentStylesShape `json:"shape,omitempty" yaml:"shape,omitempty"`

	// ShapePolygonPoints An array (or a space-separated string) of numbers ranging on [-1, 1], representing alternating x and y values (i.e. x1 y1 x2 y2, x3 y3 ...). This represents the points in the polygon for the node's shape. The bounding box of the node is given by (-1, -1), (1, -1), (1, 1), (-1, 1). The node's position is the origin (0, 0 )
	ShapePolygonPoints *string `json:"shape-polygon-points,omitempty" yaml:"shape-polygon-points,omitempty"`

	// SvgColor Colored SVG of the entity used for UI representation on light background.
	SvgColor string `json:"svgColor" yaml:"svgColor"`

	// SvgComplete Complete SVG of the entity used for UI representation, often inclusive of background.
	SvgComplete string `json:"svgComplete" yaml:"svgComplete"`

	// SvgWhite White SVG of the entity used for UI representation on dark background.
	SvgWhite string `json:"svgWhite" yaml:"svgWhite"`

	// TextHalign The horizontal alignment of a node's label
	TextHalign *ComponentStylesTextHalign `json:"text-halign,omitempty" yaml:"text-halign,omitempty"`

	// TextOpacity The opacity of the label text, including its outline.
	TextOpacity *float32 `json:"text-opacity,omitempty" yaml:"text-opacity,omitempty"`

	// TextTransform A transformation to apply to the label text
	TextTransform *ComponentStylesTextTransform `json:"text-transform,omitempty" yaml:"text-transform,omitempty"`

	// TextValign The vertical alignment of a node's label
	TextValign *ComponentStylesTextValign `json:"text-valign,omitempty" yaml:"text-valign,omitempty"`

	// Width The width of the node's body or the width of an edge's line.
	Width *float32 `json:"width,omitempty" yaml:"width,omitempty"`

	// ZIndex An integer value that affects the relative draw order of elements. In general, an element with a higher z-index will be drawn on top of an element with a lower z-index. Note that edges are under nodes despite z-index.
	ZIndex               *int                   `json:"z-index,omitempty" yaml:"z-index,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-" yaml:"-"`
}

// ComponentStylesBorderStyle The style of the node's border
type ComponentStylesBorderStyle string

// ComponentStylesGhost Whether to use the ghost effect, a semitransparent duplicate of the element drawn at an offset.
type ComponentStylesGhost string

// ComponentStylesShape The shape of the node's body. Note that each shape fits within the specified width and height, and so you may have to adjust width and height if you desire an equilateral shape (i.e. width !== height for several equilateral shapes)
type ComponentStylesShape string

// ComponentStylesTextHalign The horizontal alignment of a node's label
type ComponentStylesTextHalign string

// ComponentStylesTextTransform A transformation to apply to the label text
type ComponentStylesTextTransform string

// ComponentStylesTextValign The vertical alignment of a node's label
type ComponentStylesTextValign string

// CreatedAt Timestamp when the resource was created.
type CreatedAt = time.Time

// CredentialID defines model for credential_uuid.
type CredentialID = uuid.UUID

// DeletedAt Timestamp when the resource was deleted.
type DeletedAt = time.Time

// DesignId defines model for design_id.
type DesignId = uuid.UUID

// EdgeStyles defines model for edgeStyles.
type EdgeStyles = core.Styles

// Email email
type Email = openapi_types.Email

// EmailPreference defines model for email_preference.
type EmailPreference struct {
	NotifyRoleChange bool `json:"notify_role_change,omitempty" yaml:"notify_role_change,omitempty"`
	WelcomeEmail     bool `json:"welcome_email,omitempty" yaml:"welcome_email,omitempty"`
}

// Emails defines model for emails.
type Emails = []openapi_types.Email

// Empty Body for empty request
type Empty = map[string]interface{}

// EnvironmentId defines model for environment_id.
type EnvironmentId = uuid.UUID

// GeneralId defines model for general_id.
type GeneralId = uuid.UUID

// InputString A string starting with an alphanumeric character. Spaces and hyphens allowed.
type InputString = string

// KubernetesServerID defines model for kubernetes_server_uuid.
type KubernetesServerID = uuid.UUID

// MesheryInstanceID defines model for meshery_instance_uuid.
type MesheryInstanceID = uuid.UUID

// NullTime SQL null Timestamp to handle null values of time.
type NullTime = sql.NullTime

// Number defines model for number.
type Number = int

// OperationID defines model for operation_id.
type OperationID = uuid.UUID

// OrganizationId defines model for organization_id.
type OrganizationId = uuid.UUID

// Price defines model for price.
type Price = int32

// Provider One of (x-oapi-codegen-extra-tags-cloud, github, google)
type Provider = string

// RecordsPage defines model for recordsPage.
type RecordsPage struct {
	Page         int    `json:"page,omitempty" yaml:"page,omitempty"`
	PageSize     int    `json:"page_size,omitempty" yaml:"page_size,omitempty"`
	RecordType   string `json:"recordType,omitempty" yaml:"recordType,omitempty"`
	RecordsTotal int    `json:"records_total,omitempty" yaml:"records_total,omitempty"`
}

// RelationshipStyles defines model for relationshipStyles.
type RelationshipStyles struct {
	union json.RawMessage
}

// RelationshipStyles0 defines model for .
type RelationshipStyles0 = core.Styles

// RelationshipStyles1 defines model for .
type RelationshipStyles1 struct {
	// Animation The animation to apply to the element. example ripple,bounce,etc
	Animation *map[string]interface{} `json:"animation,omitempty" yaml:"animation,omitempty"`

	// Color The color of the element's label. Colours may be specified by name (e.g. red), hex (e.g.
	Color *string `json:"color,omitempty" yaml:"color,omitempty"`

	// FontFamily A comma-separated list of font names to use on the label text.
	FontFamily *string `json:"font-family,omitempty" yaml:"font-family,omitempty"`

	// FontSize The size of the label text.
	FontSize *string `json:"font-size,omitempty" yaml:"font-size,omitempty"`

	// FontStyle A CSS font style to be applied to the label text.
	FontStyle *string `json:"font-style,omitempty" yaml:"font-style,omitempty"`

	// FontWeight A CSS font weight to be applied to the label text.
	FontWeight *string `json:"font-weight,omitempty" yaml:"font-weight,omitempty"`

	// Label The text to display for an element's label. Can give a path, e.g. data(id) will label with the elements id
	Label *string `json:"label,omitempty" yaml:"label,omitempty"`

	// Opacity The opacity of the element, ranging from 0 to 1. Note that the opacity of a compound node parent affects the effective opacity of its children.
	Opacity *float32 `json:"opacity,omitempty" yaml:"opacity,omitempty"`

	// PrimaryColor Primary color of the component used for UI representation.
	PrimaryColor string `json:"primaryColor" yaml:"primaryColor"`

	// SecondaryColor Secondary color of the entity used for UI representation.
	SecondaryColor *string `json:"secondaryColor,omitempty" yaml:"secondaryColor,omitempty"`

	// SvgColor Colored SVG of the entity used for UI representation on light background.
	SvgColor string `json:"svgColor" yaml:"svgColor"`

	// SvgComplete Complete SVG of the entity used for UI representation, often inclusive of background.
	SvgComplete string `json:"svgComplete" yaml:"svgComplete"`

	// SvgWhite White SVG of the entity used for UI representation on dark background.
	SvgWhite string `json:"svgWhite" yaml:"svgWhite"`

	// TextOpacity The opacity of the label text, including its outline.
	TextOpacity *float32 `json:"text-opacity,omitempty" yaml:"text-opacity,omitempty"`

	// TextTransform A transformation to apply to the label text
	TextTransform *RelationshipStyles1TextTransform `json:"text-transform,omitempty" yaml:"text-transform,omitempty"`

	// ZIndex An integer value that affects the relative draw order of elements. In general, an element with a higher z-index will be drawn on top of an element with a lower z-index. Note that edges are under nodes despite z-index.
	ZIndex               *int                   `json:"z-index,omitempty" yaml:"z-index,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-" yaml:"-"`
}

// RelationshipStyles1TextTransform A transformation to apply to the label text
type RelationshipStyles1TextTransform string

// ResultsPage defines model for resultsPage.
type ResultsPage struct {
	Page       int    `json:"page,omitempty" yaml:"page,omitempty"`
	PageSize   int    `json:"page_size,omitempty" yaml:"page_size,omitempty"`
	ResultType string `json:"resultType,omitempty" yaml:"resultType,omitempty"`
	TotalCount int    `json:"total_count,omitempty" yaml:"total_count,omitempty"`
}

// RoleNames defines model for roleNames.
type RoleNames = []string

// SemverString A valid semantic version string between 5 and 256 characters. The pattern allows for a major.minor.patch version followed by an optional pre-release tag like '-alpha' or '-beta.2' and an optional build metadata tag like '+build.1.
type SemverString = string

// Shape The shape of the node's body. Note that each shape fits within the specified width and height, and so you may have to adjust width and height if you desire an equilateral shape (i.e. width !== height for several equilateral shapes)
type Shape string

// Status defines model for status.
type Status = string

// Styles Common styles for all entities
type Styles struct {
	// Animation The animation to apply to the element. example ripple,bounce,etc
	Animation *map[string]interface{} `json:"animation,omitempty" yaml:"animation,omitempty"`

	// Color The color of the element's label. Colours may be specified by name (e.g. red), hex (e.g.
	Color *string `json:"color,omitempty" yaml:"color,omitempty"`

	// FontFamily A comma-separated list of font names to use on the label text.
	FontFamily *string `json:"font-family,omitempty" yaml:"font-family,omitempty"`

	// FontSize The size of the label text.
	FontSize *string `json:"font-size,omitempty" yaml:"font-size,omitempty"`

	// FontStyle A CSS font style to be applied to the label text.
	FontStyle *string `json:"font-style,omitempty" yaml:"font-style,omitempty"`

	// FontWeight A CSS font weight to be applied to the label text.
	FontWeight *string `json:"font-weight,omitempty" yaml:"font-weight,omitempty"`

	// Label The text to display for an element's label. Can give a path, e.g. data(id) will label with the elements id
	Label *string `json:"label,omitempty" yaml:"label,omitempty"`

	// Opacity The opacity of the element, ranging from 0 to 1. Note that the opacity of a compound node parent affects the effective opacity of its children.
	Opacity *float32 `json:"opacity,omitempty" yaml:"opacity,omitempty"`

	// PrimaryColor Primary color of the component used for UI representation.
	PrimaryColor string `json:"primaryColor" yaml:"primaryColor"`

	// SecondaryColor Secondary color of the entity used for UI representation.
	SecondaryColor *string `json:"secondaryColor,omitempty" yaml:"secondaryColor,omitempty"`

	// SvgColor Colored SVG of the entity used for UI representation on light background.
	SvgColor string `json:"svgColor" yaml:"svgColor"`

	// SvgComplete Complete SVG of the entity used for UI representation, often inclusive of background.
	SvgComplete string `json:"svgComplete" yaml:"svgComplete"`

	// SvgWhite White SVG of the entity used for UI representation on dark background.
	SvgWhite string `json:"svgWhite" yaml:"svgWhite"`

	// TextOpacity The opacity of the label text, including its outline.
	TextOpacity *float32 `json:"text-opacity,omitempty" yaml:"text-opacity,omitempty"`

	// TextTransform A transformation to apply to the label text
	TextTransform *StylesTextTransform `json:"text-transform,omitempty" yaml:"text-transform,omitempty"`

	// ZIndex An integer value that affects the relative draw order of elements. In general, an element with a higher z-index will be drawn on top of an element with a lower z-index. Note that edges are under nodes despite z-index.
	ZIndex               *int                   `json:"z-index,omitempty" yaml:"z-index,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-" yaml:"-"`
}

// StylesTextTransform A transformation to apply to the label text
type StylesTextTransform string

// SystemID defines model for system_id.
type SystemID = uuid.UUID

// TeamId defines model for team_id.
type TeamId = uuid.UUID

// UpdatedAt Timestamp when the resource was updated.
type UpdatedAt = time.Time

// UserId user's email or username
type UserId = string

// UserIds defines model for user_ids.
type UserIds = []uuid.UUID

// UserID defines model for user_uuid.
type UserID = uuid.UUID

// Username defines model for username.
type Username = string

// Uuid A Universally Unique Identifier used to uniquely identify entities in Meshery. The UUID core definition is used across different schemas.
type Uuid = uuid.UUID

// VersionString API version of the object
type VersionString = string

// ViewId defines model for view_id.
type ViewId = uuid.UUID

// WorkspaceId defines model for workspace_id.
type WorkspaceId = uuid.UUID

// ActorType defines model for actorType.
type ActorType = string

// All defines model for all.
type All = bool

// Class defines model for class.
type Class = string

// ContentTechnology defines model for contentTechnology.
type ContentTechnology = string

// ContentType defines model for contentType.
type ContentType = string

// Cumulative defines model for cumulative.
type Cumulative = string

// Filter defines model for filter.
type Filter = string

// IsOAuth defines model for isOAuth.
type IsOAuth = string

// MesheryVersion defines model for mesheryVersion.
type MesheryVersion = string

// Metrics defines model for metrics.
type Metrics = string

// Name defines model for name.
type Name = string

// Namespace defines model for namespace.
type Namespace = string

// Order defines model for order.
type Order = string

// Os defines model for os.
type Os = string

// Page defines model for page.
type Page = string

// Pagesize defines model for pagesize.
type Pagesize = string

// PagesizeWithAll defines model for pagesizeWithAll.
type PagesizeWithAll = string

// Playground defines model for playground.
type Playground = string

// Populate defines model for populate.
type Populate = string

// Purpose defines model for purpose.
type Purpose = string

// ResourceType defines model for resourceType.
type ResourceType = string

// Search defines model for search.
type Search = string

// Type defines model for type.
type Type = string

// Userid defines model for userid.
type Userid = string

// Visibility defines model for visibility.
type Visibility = string

// Getter for additional properties for ComponentStyles. Returns the specified
// element and whether it was found
func (a ComponentStyles) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ComponentStyles
func (a *ComponentStyles) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ComponentStyles to handle AdditionalProperties
func (a *ComponentStyles) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["active-bg-color"]; found {
		err = json.Unmarshal(raw, &a.ActiveBgColor)
		if err != nil {
			return fmt.Errorf("error reading 'active-bg-color': %w", err)
		}
		delete(object, "active-bg-color")
	}

	if raw, found := object["active-bg-opacity"]; found {
		err = json.Unmarshal(raw, &a.ActiveBgOpacity)
		if err != nil {
			return fmt.Errorf("error reading 'active-bg-opacity': %w", err)
		}
		delete(object, "active-bg-opacity")
	}

	if raw, found := object["active-bg-size"]; found {
		err = json.Unmarshal(raw, &a.ActiveBgSize)
		if err != nil {
			return fmt.Errorf("error reading 'active-bg-size': %w", err)
		}
		delete(object, "active-bg-size")
	}

	if raw, found := object["animation"]; found {
		err = json.Unmarshal(raw, &a.Animation)
		if err != nil {
			return fmt.Errorf("error reading 'animation': %w", err)
		}
		delete(object, "animation")
	}

	if raw, found := object["background-blacken"]; found {
		err = json.Unmarshal(raw, &a.BackgroundBlacken)
		if err != nil {
			return fmt.Errorf("error reading 'background-blacken': %w", err)
		}
		delete(object, "background-blacken")
	}

	if raw, found := object["background-clip"]; found {
		err = json.Unmarshal(raw, &a.BackgroundClip)
		if err != nil {
			return fmt.Errorf("error reading 'background-clip': %w", err)
		}
		delete(object, "background-clip")
	}

	if raw, found := object["background-color"]; found {
		err = json.Unmarshal(raw, &a.BackgroundColor)
		if err != nil {
			return fmt.Errorf("error reading 'background-color': %w", err)
		}
		delete(object, "background-color")
	}

	if raw, found := object["background-fit"]; found {
		err = json.Unmarshal(raw, &a.BackgroundFit)
		if err != nil {
			return fmt.Errorf("error reading 'background-fit': %w", err)
		}
		delete(object, "background-fit")
	}

	if raw, found := object["background-height-relative-to"]; found {
		err = json.Unmarshal(raw, &a.BackgroundHeightRelativeTo)
		if err != nil {
			return fmt.Errorf("error reading 'background-height-relative-to': %w", err)
		}
		delete(object, "background-height-relative-to")
	}

	if raw, found := object["background-image"]; found {
		err = json.Unmarshal(raw, &a.BackgroundImage)
		if err != nil {
			return fmt.Errorf("error reading 'background-image': %w", err)
		}
		delete(object, "background-image")
	}

	if raw, found := object["background-offset-x"]; found {
		err = json.Unmarshal(raw, &a.BackgroundOffsetX)
		if err != nil {
			return fmt.Errorf("error reading 'background-offset-x': %w", err)
		}
		delete(object, "background-offset-x")
	}

	if raw, found := object["background-offset-y"]; found {
		err = json.Unmarshal(raw, &a.BackgroundOffsetY)
		if err != nil {
			return fmt.Errorf("error reading 'background-offset-y': %w", err)
		}
		delete(object, "background-offset-y")
	}

	if raw, found := object["background-opacity"]; found {
		err = json.Unmarshal(raw, &a.BackgroundOpacity)
		if err != nil {
			return fmt.Errorf("error reading 'background-opacity': %w", err)
		}
		delete(object, "background-opacity")
	}

	if raw, found := object["background-position-x"]; found {
		err = json.Unmarshal(raw, &a.BackgroundPositionX)
		if err != nil {
			return fmt.Errorf("error reading 'background-position-x': %w", err)
		}
		delete(object, "background-position-x")
	}

	if raw, found := object["background-position-y"]; found {
		err = json.Unmarshal(raw, &a.BackgroundPositionY)
		if err != nil {
			return fmt.Errorf("error reading 'background-position-y': %w", err)
		}
		delete(object, "background-position-y")
	}

	if raw, found := object["background-width-relative-to"]; found {
		err = json.Unmarshal(raw, &a.BackgroundWidthRelativeTo)
		if err != nil {
			return fmt.Errorf("error reading 'background-width-relative-to': %w", err)
		}
		delete(object, "background-width-relative-to")
	}

	if raw, found := object["body-text"]; found {
		err = json.Unmarshal(raw, &a.BodyText)
		if err != nil {
			return fmt.Errorf("error reading 'body-text': %w", err)
		}
		delete(object, "body-text")
	}

	if raw, found := object["body-text-background-color"]; found {
		err = json.Unmarshal(raw, &a.BodyTextBackgroundColor)
		if err != nil {
			return fmt.Errorf("error reading 'body-text-background-color': %w", err)
		}
		delete(object, "body-text-background-color")
	}

	if raw, found := object["body-text-color"]; found {
		err = json.Unmarshal(raw, &a.BodyTextColor)
		if err != nil {
			return fmt.Errorf("error reading 'body-text-color': %w", err)
		}
		delete(object, "body-text-color")
	}

	if raw, found := object["body-text-decoration"]; found {
		err = json.Unmarshal(raw, &a.BodyTextDecoration)
		if err != nil {
			return fmt.Errorf("error reading 'body-text-decoration': %w", err)
		}
		delete(object, "body-text-decoration")
	}

	if raw, found := object["body-text-font-size"]; found {
		err = json.Unmarshal(raw, &a.BodyTextFontSize)
		if err != nil {
			return fmt.Errorf("error reading 'body-text-font-size': %w", err)
		}
		delete(object, "body-text-font-size")
	}

	if raw, found := object["body-text-font-weight"]; found {
		err = json.Unmarshal(raw, &a.BodyTextFontWeight)
		if err != nil {
			return fmt.Errorf("error reading 'body-text-font-weight': %w", err)
		}
		delete(object, "body-text-font-weight")
	}

	if raw, found := object["body-text-horizontal-align"]; found {
		err = json.Unmarshal(raw, &a.BodyTextHorizontalAlign)
		if err != nil {
			return fmt.Errorf("error reading 'body-text-horizontal-align': %w", err)
		}
		delete(object, "body-text-horizontal-align")
	}

	if raw, found := object["body-text-max-width"]; found {
		err = json.Unmarshal(raw, &a.BodyTextMaxWidth)
		if err != nil {
			return fmt.Errorf("error reading 'body-text-max-width': %w", err)
		}
		delete(object, "body-text-max-width")
	}

	if raw, found := object["body-text-opacity"]; found {
		err = json.Unmarshal(raw, &a.BodyTextOpacity)
		if err != nil {
			return fmt.Errorf("error reading 'body-text-opacity': %w", err)
		}
		delete(object, "body-text-opacity")
	}

	if raw, found := object["body-text-vertical-align"]; found {
		err = json.Unmarshal(raw, &a.BodyTextVerticalAlign)
		if err != nil {
			return fmt.Errorf("error reading 'body-text-vertical-align': %w", err)
		}
		delete(object, "body-text-vertical-align")
	}

	if raw, found := object["body-text-wrap"]; found {
		err = json.Unmarshal(raw, &a.BodyTextWrap)
		if err != nil {
			return fmt.Errorf("error reading 'body-text-wrap': %w", err)
		}
		delete(object, "body-text-wrap")
	}

	if raw, found := object["border-color"]; found {
		err = json.Unmarshal(raw, &a.BorderColor)
		if err != nil {
			return fmt.Errorf("error reading 'border-color': %w", err)
		}
		delete(object, "border-color")
	}

	if raw, found := object["border-opacity"]; found {
		err = json.Unmarshal(raw, &a.BorderOpacity)
		if err != nil {
			return fmt.Errorf("error reading 'border-opacity': %w", err)
		}
		delete(object, "border-opacity")
	}

	if raw, found := object["border-style"]; found {
		err = json.Unmarshal(raw, &a.BorderStyle)
		if err != nil {
			return fmt.Errorf("error reading 'border-style': %w", err)
		}
		delete(object, "border-style")
	}

	if raw, found := object["border-width"]; found {
		err = json.Unmarshal(raw, &a.BorderWidth)
		if err != nil {
			return fmt.Errorf("error reading 'border-width': %w", err)
		}
		delete(object, "border-width")
	}

	if raw, found := object["color"]; found {
		err = json.Unmarshal(raw, &a.Color)
		if err != nil {
			return fmt.Errorf("error reading 'color': %w", err)
		}
		delete(object, "color")
	}

	if raw, found := object["font-family"]; found {
		err = json.Unmarshal(raw, &a.FontFamily)
		if err != nil {
			return fmt.Errorf("error reading 'font-family': %w", err)
		}
		delete(object, "font-family")
	}

	if raw, found := object["font-size"]; found {
		err = json.Unmarshal(raw, &a.FontSize)
		if err != nil {
			return fmt.Errorf("error reading 'font-size': %w", err)
		}
		delete(object, "font-size")
	}

	if raw, found := object["font-style"]; found {
		err = json.Unmarshal(raw, &a.FontStyle)
		if err != nil {
			return fmt.Errorf("error reading 'font-style': %w", err)
		}
		delete(object, "font-style")
	}

	if raw, found := object["font-weight"]; found {
		err = json.Unmarshal(raw, &a.FontWeight)
		if err != nil {
			return fmt.Errorf("error reading 'font-weight': %w", err)
		}
		delete(object, "font-weight")
	}

	if raw, found := object["ghost"]; found {
		err = json.Unmarshal(raw, &a.Ghost)
		if err != nil {
			return fmt.Errorf("error reading 'ghost': %w", err)
		}
		delete(object, "ghost")
	}

	if raw, found := object["height"]; found {
		err = json.Unmarshal(raw, &a.Height)
		if err != nil {
			return fmt.Errorf("error reading 'height': %w", err)
		}
		delete(object, "height")
	}

	if raw, found := object["label"]; found {
		err = json.Unmarshal(raw, &a.Label)
		if err != nil {
			return fmt.Errorf("error reading 'label': %w", err)
		}
		delete(object, "label")
	}

	if raw, found := object["menu-background-color"]; found {
		err = json.Unmarshal(raw, &a.MenuBackgroundColor)
		if err != nil {
			return fmt.Errorf("error reading 'menu-background-color': %w", err)
		}
		delete(object, "menu-background-color")
	}

	if raw, found := object["menu-background-opacity"]; found {
		err = json.Unmarshal(raw, &a.MenuBackgroundOpacity)
		if err != nil {
			return fmt.Errorf("error reading 'menu-background-opacity': %w", err)
		}
		delete(object, "menu-background-opacity")
	}

	if raw, found := object["menu-forground-color"]; found {
		err = json.Unmarshal(raw, &a.MenuForgroundColor)
		if err != nil {
			return fmt.Errorf("error reading 'menu-forground-color': %w", err)
		}
		delete(object, "menu-forground-color")
	}

	if raw, found := object["opacity"]; found {
		err = json.Unmarshal(raw, &a.Opacity)
		if err != nil {
			return fmt.Errorf("error reading 'opacity': %w", err)
		}
		delete(object, "opacity")
	}

	if raw, found := object["outside-texture-bg-color"]; found {
		err = json.Unmarshal(raw, &a.OutsideTextureBgColor)
		if err != nil {
			return fmt.Errorf("error reading 'outside-texture-bg-color': %w", err)
		}
		delete(object, "outside-texture-bg-color")
	}

	if raw, found := object["outside-texture-bg-opacity"]; found {
		err = json.Unmarshal(raw, &a.OutsideTextureBgOpacity)
		if err != nil {
			return fmt.Errorf("error reading 'outside-texture-bg-opacity': %w", err)
		}
		delete(object, "outside-texture-bg-opacity")
	}

	if raw, found := object["padding"]; found {
		err = json.Unmarshal(raw, &a.Padding)
		if err != nil {
			return fmt.Errorf("error reading 'padding': %w", err)
		}
		delete(object, "padding")
	}

	if raw, found := object["position"]; found {
		err = json.Unmarshal(raw, &a.Position)
		if err != nil {
			return fmt.Errorf("error reading 'position': %w", err)
		}
		delete(object, "position")
	}

	if raw, found := object["primaryColor"]; found {
		err = json.Unmarshal(raw, &a.PrimaryColor)
		if err != nil {
			return fmt.Errorf("error reading 'primaryColor': %w", err)
		}
		delete(object, "primaryColor")
	}

	if raw, found := object["secondaryColor"]; found {
		err = json.Unmarshal(raw, &a.SecondaryColor)
		if err != nil {
			return fmt.Errorf("error reading 'secondaryColor': %w", err)
		}
		delete(object, "secondaryColor")
	}

	if raw, found := object["selection-box-border-width"]; found {
		err = json.Unmarshal(raw, &a.SelectionBoxBorderWidth)
		if err != nil {
			return fmt.Errorf("error reading 'selection-box-border-width': %w", err)
		}
		delete(object, "selection-box-border-width")
	}

	if raw, found := object["selection-box-color"]; found {
		err = json.Unmarshal(raw, &a.SelectionBoxColor)
		if err != nil {
			return fmt.Errorf("error reading 'selection-box-color': %w", err)
		}
		delete(object, "selection-box-color")
	}

	if raw, found := object["selection-box-opacity"]; found {
		err = json.Unmarshal(raw, &a.SelectionBoxOpacity)
		if err != nil {
			return fmt.Errorf("error reading 'selection-box-opacity': %w", err)
		}
		delete(object, "selection-box-opacity")
	}

	if raw, found := object["shape"]; found {
		err = json.Unmarshal(raw, &a.Shape)
		if err != nil {
			return fmt.Errorf("error reading 'shape': %w", err)
		}
		delete(object, "shape")
	}

	if raw, found := object["shape-polygon-points"]; found {
		err = json.Unmarshal(raw, &a.ShapePolygonPoints)
		if err != nil {
			return fmt.Errorf("error reading 'shape-polygon-points': %w", err)
		}
		delete(object, "shape-polygon-points")
	}

	if raw, found := object["svgColor"]; found {
		err = json.Unmarshal(raw, &a.SvgColor)
		if err != nil {
			return fmt.Errorf("error reading 'svgColor': %w", err)
		}
		delete(object, "svgColor")
	}

	if raw, found := object["svgComplete"]; found {
		err = json.Unmarshal(raw, &a.SvgComplete)
		if err != nil {
			return fmt.Errorf("error reading 'svgComplete': %w", err)
		}
		delete(object, "svgComplete")
	}

	if raw, found := object["svgWhite"]; found {
		err = json.Unmarshal(raw, &a.SvgWhite)
		if err != nil {
			return fmt.Errorf("error reading 'svgWhite': %w", err)
		}
		delete(object, "svgWhite")
	}

	if raw, found := object["text-halign"]; found {
		err = json.Unmarshal(raw, &a.TextHalign)
		if err != nil {
			return fmt.Errorf("error reading 'text-halign': %w", err)
		}
		delete(object, "text-halign")
	}

	if raw, found := object["text-opacity"]; found {
		err = json.Unmarshal(raw, &a.TextOpacity)
		if err != nil {
			return fmt.Errorf("error reading 'text-opacity': %w", err)
		}
		delete(object, "text-opacity")
	}

	if raw, found := object["text-transform"]; found {
		err = json.Unmarshal(raw, &a.TextTransform)
		if err != nil {
			return fmt.Errorf("error reading 'text-transform': %w", err)
		}
		delete(object, "text-transform")
	}

	if raw, found := object["text-valign"]; found {
		err = json.Unmarshal(raw, &a.TextValign)
		if err != nil {
			return fmt.Errorf("error reading 'text-valign': %w", err)
		}
		delete(object, "text-valign")
	}

	if raw, found := object["width"]; found {
		err = json.Unmarshal(raw, &a.Width)
		if err != nil {
			return fmt.Errorf("error reading 'width': %w", err)
		}
		delete(object, "width")
	}

	if raw, found := object["z-index"]; found {
		err = json.Unmarshal(raw, &a.ZIndex)
		if err != nil {
			return fmt.Errorf("error reading 'z-index': %w", err)
		}
		delete(object, "z-index")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ComponentStyles to handle AdditionalProperties
func (a ComponentStyles) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.ActiveBgColor != nil {
		object["active-bg-color"], err = json.Marshal(a.ActiveBgColor)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'active-bg-color': %w", err)
		}
	}

	if a.ActiveBgOpacity != nil {
		object["active-bg-opacity"], err = json.Marshal(a.ActiveBgOpacity)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'active-bg-opacity': %w", err)
		}
	}

	if a.ActiveBgSize != nil {
		object["active-bg-size"], err = json.Marshal(a.ActiveBgSize)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'active-bg-size': %w", err)
		}
	}

	if a.Animation != nil {
		object["animation"], err = json.Marshal(a.Animation)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'animation': %w", err)
		}
	}

	if a.BackgroundBlacken != nil {
		object["background-blacken"], err = json.Marshal(a.BackgroundBlacken)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'background-blacken': %w", err)
		}
	}

	if a.BackgroundClip != nil {
		object["background-clip"], err = json.Marshal(a.BackgroundClip)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'background-clip': %w", err)
		}
	}

	if a.BackgroundColor != nil {
		object["background-color"], err = json.Marshal(a.BackgroundColor)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'background-color': %w", err)
		}
	}

	if a.BackgroundFit != nil {
		object["background-fit"], err = json.Marshal(a.BackgroundFit)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'background-fit': %w", err)
		}
	}

	if a.BackgroundHeightRelativeTo != nil {
		object["background-height-relative-to"], err = json.Marshal(a.BackgroundHeightRelativeTo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'background-height-relative-to': %w", err)
		}
	}

	if a.BackgroundImage != nil {
		object["background-image"], err = json.Marshal(a.BackgroundImage)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'background-image': %w", err)
		}
	}

	if a.BackgroundOffsetX != nil {
		object["background-offset-x"], err = json.Marshal(a.BackgroundOffsetX)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'background-offset-x': %w", err)
		}
	}

	if a.BackgroundOffsetY != nil {
		object["background-offset-y"], err = json.Marshal(a.BackgroundOffsetY)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'background-offset-y': %w", err)
		}
	}

	if a.BackgroundOpacity != nil {
		object["background-opacity"], err = json.Marshal(a.BackgroundOpacity)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'background-opacity': %w", err)
		}
	}

	if a.BackgroundPositionX != nil {
		object["background-position-x"], err = json.Marshal(a.BackgroundPositionX)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'background-position-x': %w", err)
		}
	}

	if a.BackgroundPositionY != nil {
		object["background-position-y"], err = json.Marshal(a.BackgroundPositionY)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'background-position-y': %w", err)
		}
	}

	if a.BackgroundWidthRelativeTo != nil {
		object["background-width-relative-to"], err = json.Marshal(a.BackgroundWidthRelativeTo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'background-width-relative-to': %w", err)
		}
	}

	if a.BodyText != nil {
		object["body-text"], err = json.Marshal(a.BodyText)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'body-text': %w", err)
		}
	}

	if a.BodyTextBackgroundColor != nil {
		object["body-text-background-color"], err = json.Marshal(a.BodyTextBackgroundColor)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'body-text-background-color': %w", err)
		}
	}

	if a.BodyTextColor != nil {
		object["body-text-color"], err = json.Marshal(a.BodyTextColor)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'body-text-color': %w", err)
		}
	}

	if a.BodyTextDecoration != nil {
		object["body-text-decoration"], err = json.Marshal(a.BodyTextDecoration)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'body-text-decoration': %w", err)
		}
	}

	if a.BodyTextFontSize != nil {
		object["body-text-font-size"], err = json.Marshal(a.BodyTextFontSize)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'body-text-font-size': %w", err)
		}
	}

	if a.BodyTextFontWeight != nil {
		object["body-text-font-weight"], err = json.Marshal(a.BodyTextFontWeight)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'body-text-font-weight': %w", err)
		}
	}

	if a.BodyTextHorizontalAlign != nil {
		object["body-text-horizontal-align"], err = json.Marshal(a.BodyTextHorizontalAlign)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'body-text-horizontal-align': %w", err)
		}
	}

	if a.BodyTextMaxWidth != nil {
		object["body-text-max-width"], err = json.Marshal(a.BodyTextMaxWidth)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'body-text-max-width': %w", err)
		}
	}

	if a.BodyTextOpacity != nil {
		object["body-text-opacity"], err = json.Marshal(a.BodyTextOpacity)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'body-text-opacity': %w", err)
		}
	}

	if a.BodyTextVerticalAlign != nil {
		object["body-text-vertical-align"], err = json.Marshal(a.BodyTextVerticalAlign)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'body-text-vertical-align': %w", err)
		}
	}

	if a.BodyTextWrap != nil {
		object["body-text-wrap"], err = json.Marshal(a.BodyTextWrap)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'body-text-wrap': %w", err)
		}
	}

	if a.BorderColor != nil {
		object["border-color"], err = json.Marshal(a.BorderColor)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'border-color': %w", err)
		}
	}

	if a.BorderOpacity != nil {
		object["border-opacity"], err = json.Marshal(a.BorderOpacity)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'border-opacity': %w", err)
		}
	}

	if a.BorderStyle != nil {
		object["border-style"], err = json.Marshal(a.BorderStyle)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'border-style': %w", err)
		}
	}

	if a.BorderWidth != nil {
		object["border-width"], err = json.Marshal(a.BorderWidth)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'border-width': %w", err)
		}
	}

	if a.Color != nil {
		object["color"], err = json.Marshal(a.Color)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'color': %w", err)
		}
	}

	if a.FontFamily != nil {
		object["font-family"], err = json.Marshal(a.FontFamily)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'font-family': %w", err)
		}
	}

	if a.FontSize != nil {
		object["font-size"], err = json.Marshal(a.FontSize)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'font-size': %w", err)
		}
	}

	if a.FontStyle != nil {
		object["font-style"], err = json.Marshal(a.FontStyle)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'font-style': %w", err)
		}
	}

	if a.FontWeight != nil {
		object["font-weight"], err = json.Marshal(a.FontWeight)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'font-weight': %w", err)
		}
	}

	if a.Ghost != nil {
		object["ghost"], err = json.Marshal(a.Ghost)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ghost': %w", err)
		}
	}

	if a.Height != nil {
		object["height"], err = json.Marshal(a.Height)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'height': %w", err)
		}
	}

	if a.Label != nil {
		object["label"], err = json.Marshal(a.Label)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'label': %w", err)
		}
	}

	if a.MenuBackgroundColor != nil {
		object["menu-background-color"], err = json.Marshal(a.MenuBackgroundColor)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'menu-background-color': %w", err)
		}
	}

	if a.MenuBackgroundOpacity != nil {
		object["menu-background-opacity"], err = json.Marshal(a.MenuBackgroundOpacity)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'menu-background-opacity': %w", err)
		}
	}

	if a.MenuForgroundColor != nil {
		object["menu-forground-color"], err = json.Marshal(a.MenuForgroundColor)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'menu-forground-color': %w", err)
		}
	}

	if a.Opacity != nil {
		object["opacity"], err = json.Marshal(a.Opacity)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'opacity': %w", err)
		}
	}

	if a.OutsideTextureBgColor != nil {
		object["outside-texture-bg-color"], err = json.Marshal(a.OutsideTextureBgColor)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'outside-texture-bg-color': %w", err)
		}
	}

	if a.OutsideTextureBgOpacity != nil {
		object["outside-texture-bg-opacity"], err = json.Marshal(a.OutsideTextureBgOpacity)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'outside-texture-bg-opacity': %w", err)
		}
	}

	if a.Padding != nil {
		object["padding"], err = json.Marshal(a.Padding)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'padding': %w", err)
		}
	}

	if a.Position != nil {
		object["position"], err = json.Marshal(a.Position)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'position': %w", err)
		}
	}

	object["primaryColor"], err = json.Marshal(a.PrimaryColor)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'primaryColor': %w", err)
	}

	if a.SecondaryColor != nil {
		object["secondaryColor"], err = json.Marshal(a.SecondaryColor)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'secondaryColor': %w", err)
		}
	}

	if a.SelectionBoxBorderWidth != nil {
		object["selection-box-border-width"], err = json.Marshal(a.SelectionBoxBorderWidth)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'selection-box-border-width': %w", err)
		}
	}

	if a.SelectionBoxColor != nil {
		object["selection-box-color"], err = json.Marshal(a.SelectionBoxColor)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'selection-box-color': %w", err)
		}
	}

	if a.SelectionBoxOpacity != nil {
		object["selection-box-opacity"], err = json.Marshal(a.SelectionBoxOpacity)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'selection-box-opacity': %w", err)
		}
	}

	if a.Shape != nil {
		object["shape"], err = json.Marshal(a.Shape)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'shape': %w", err)
		}
	}

	if a.ShapePolygonPoints != nil {
		object["shape-polygon-points"], err = json.Marshal(a.ShapePolygonPoints)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'shape-polygon-points': %w", err)
		}
	}

	object["svgColor"], err = json.Marshal(a.SvgColor)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'svgColor': %w", err)
	}

	object["svgComplete"], err = json.Marshal(a.SvgComplete)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'svgComplete': %w", err)
	}

	object["svgWhite"], err = json.Marshal(a.SvgWhite)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'svgWhite': %w", err)
	}

	if a.TextHalign != nil {
		object["text-halign"], err = json.Marshal(a.TextHalign)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'text-halign': %w", err)
		}
	}

	if a.TextOpacity != nil {
		object["text-opacity"], err = json.Marshal(a.TextOpacity)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'text-opacity': %w", err)
		}
	}

	if a.TextTransform != nil {
		object["text-transform"], err = json.Marshal(a.TextTransform)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'text-transform': %w", err)
		}
	}

	if a.TextValign != nil {
		object["text-valign"], err = json.Marshal(a.TextValign)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'text-valign': %w", err)
		}
	}

	if a.Width != nil {
		object["width"], err = json.Marshal(a.Width)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'width': %w", err)
		}
	}

	if a.ZIndex != nil {
		object["z-index"], err = json.Marshal(a.ZIndex)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'z-index': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for RelationshipStyles1. Returns the specified
// element and whether it was found
func (a RelationshipStyles1) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for RelationshipStyles1
func (a *RelationshipStyles1) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for RelationshipStyles1 to handle AdditionalProperties
func (a *RelationshipStyles1) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["animation"]; found {
		err = json.Unmarshal(raw, &a.Animation)
		if err != nil {
			return fmt.Errorf("error reading 'animation': %w", err)
		}
		delete(object, "animation")
	}

	if raw, found := object["color"]; found {
		err = json.Unmarshal(raw, &a.Color)
		if err != nil {
			return fmt.Errorf("error reading 'color': %w", err)
		}
		delete(object, "color")
	}

	if raw, found := object["font-family"]; found {
		err = json.Unmarshal(raw, &a.FontFamily)
		if err != nil {
			return fmt.Errorf("error reading 'font-family': %w", err)
		}
		delete(object, "font-family")
	}

	if raw, found := object["font-size"]; found {
		err = json.Unmarshal(raw, &a.FontSize)
		if err != nil {
			return fmt.Errorf("error reading 'font-size': %w", err)
		}
		delete(object, "font-size")
	}

	if raw, found := object["font-style"]; found {
		err = json.Unmarshal(raw, &a.FontStyle)
		if err != nil {
			return fmt.Errorf("error reading 'font-style': %w", err)
		}
		delete(object, "font-style")
	}

	if raw, found := object["font-weight"]; found {
		err = json.Unmarshal(raw, &a.FontWeight)
		if err != nil {
			return fmt.Errorf("error reading 'font-weight': %w", err)
		}
		delete(object, "font-weight")
	}

	if raw, found := object["label"]; found {
		err = json.Unmarshal(raw, &a.Label)
		if err != nil {
			return fmt.Errorf("error reading 'label': %w", err)
		}
		delete(object, "label")
	}

	if raw, found := object["opacity"]; found {
		err = json.Unmarshal(raw, &a.Opacity)
		if err != nil {
			return fmt.Errorf("error reading 'opacity': %w", err)
		}
		delete(object, "opacity")
	}

	if raw, found := object["primaryColor"]; found {
		err = json.Unmarshal(raw, &a.PrimaryColor)
		if err != nil {
			return fmt.Errorf("error reading 'primaryColor': %w", err)
		}
		delete(object, "primaryColor")
	}

	if raw, found := object["secondaryColor"]; found {
		err = json.Unmarshal(raw, &a.SecondaryColor)
		if err != nil {
			return fmt.Errorf("error reading 'secondaryColor': %w", err)
		}
		delete(object, "secondaryColor")
	}

	if raw, found := object["svgColor"]; found {
		err = json.Unmarshal(raw, &a.SvgColor)
		if err != nil {
			return fmt.Errorf("error reading 'svgColor': %w", err)
		}
		delete(object, "svgColor")
	}

	if raw, found := object["svgComplete"]; found {
		err = json.Unmarshal(raw, &a.SvgComplete)
		if err != nil {
			return fmt.Errorf("error reading 'svgComplete': %w", err)
		}
		delete(object, "svgComplete")
	}

	if raw, found := object["svgWhite"]; found {
		err = json.Unmarshal(raw, &a.SvgWhite)
		if err != nil {
			return fmt.Errorf("error reading 'svgWhite': %w", err)
		}
		delete(object, "svgWhite")
	}

	if raw, found := object["text-opacity"]; found {
		err = json.Unmarshal(raw, &a.TextOpacity)
		if err != nil {
			return fmt.Errorf("error reading 'text-opacity': %w", err)
		}
		delete(object, "text-opacity")
	}

	if raw, found := object["text-transform"]; found {
		err = json.Unmarshal(raw, &a.TextTransform)
		if err != nil {
			return fmt.Errorf("error reading 'text-transform': %w", err)
		}
		delete(object, "text-transform")
	}

	if raw, found := object["z-index"]; found {
		err = json.Unmarshal(raw, &a.ZIndex)
		if err != nil {
			return fmt.Errorf("error reading 'z-index': %w", err)
		}
		delete(object, "z-index")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for RelationshipStyles1 to handle AdditionalProperties
func (a RelationshipStyles1) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Animation != nil {
		object["animation"], err = json.Marshal(a.Animation)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'animation': %w", err)
		}
	}

	if a.Color != nil {
		object["color"], err = json.Marshal(a.Color)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'color': %w", err)
		}
	}

	if a.FontFamily != nil {
		object["font-family"], err = json.Marshal(a.FontFamily)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'font-family': %w", err)
		}
	}

	if a.FontSize != nil {
		object["font-size"], err = json.Marshal(a.FontSize)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'font-size': %w", err)
		}
	}

	if a.FontStyle != nil {
		object["font-style"], err = json.Marshal(a.FontStyle)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'font-style': %w", err)
		}
	}

	if a.FontWeight != nil {
		object["font-weight"], err = json.Marshal(a.FontWeight)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'font-weight': %w", err)
		}
	}

	if a.Label != nil {
		object["label"], err = json.Marshal(a.Label)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'label': %w", err)
		}
	}

	if a.Opacity != nil {
		object["opacity"], err = json.Marshal(a.Opacity)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'opacity': %w", err)
		}
	}

	object["primaryColor"], err = json.Marshal(a.PrimaryColor)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'primaryColor': %w", err)
	}

	if a.SecondaryColor != nil {
		object["secondaryColor"], err = json.Marshal(a.SecondaryColor)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'secondaryColor': %w", err)
		}
	}

	object["svgColor"], err = json.Marshal(a.SvgColor)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'svgColor': %w", err)
	}

	object["svgComplete"], err = json.Marshal(a.SvgComplete)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'svgComplete': %w", err)
	}

	object["svgWhite"], err = json.Marshal(a.SvgWhite)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'svgWhite': %w", err)
	}

	if a.TextOpacity != nil {
		object["text-opacity"], err = json.Marshal(a.TextOpacity)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'text-opacity': %w", err)
		}
	}

	if a.TextTransform != nil {
		object["text-transform"], err = json.Marshal(a.TextTransform)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'text-transform': %w", err)
		}
	}

	if a.ZIndex != nil {
		object["z-index"], err = json.Marshal(a.ZIndex)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'z-index': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Styles. Returns the specified
// element and whether it was found
func (a Styles) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Styles
func (a *Styles) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Styles to handle AdditionalProperties
func (a *Styles) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["animation"]; found {
		err = json.Unmarshal(raw, &a.Animation)
		if err != nil {
			return fmt.Errorf("error reading 'animation': %w", err)
		}
		delete(object, "animation")
	}

	if raw, found := object["color"]; found {
		err = json.Unmarshal(raw, &a.Color)
		if err != nil {
			return fmt.Errorf("error reading 'color': %w", err)
		}
		delete(object, "color")
	}

	if raw, found := object["font-family"]; found {
		err = json.Unmarshal(raw, &a.FontFamily)
		if err != nil {
			return fmt.Errorf("error reading 'font-family': %w", err)
		}
		delete(object, "font-family")
	}

	if raw, found := object["font-size"]; found {
		err = json.Unmarshal(raw, &a.FontSize)
		if err != nil {
			return fmt.Errorf("error reading 'font-size': %w", err)
		}
		delete(object, "font-size")
	}

	if raw, found := object["font-style"]; found {
		err = json.Unmarshal(raw, &a.FontStyle)
		if err != nil {
			return fmt.Errorf("error reading 'font-style': %w", err)
		}
		delete(object, "font-style")
	}

	if raw, found := object["font-weight"]; found {
		err = json.Unmarshal(raw, &a.FontWeight)
		if err != nil {
			return fmt.Errorf("error reading 'font-weight': %w", err)
		}
		delete(object, "font-weight")
	}

	if raw, found := object["label"]; found {
		err = json.Unmarshal(raw, &a.Label)
		if err != nil {
			return fmt.Errorf("error reading 'label': %w", err)
		}
		delete(object, "label")
	}

	if raw, found := object["opacity"]; found {
		err = json.Unmarshal(raw, &a.Opacity)
		if err != nil {
			return fmt.Errorf("error reading 'opacity': %w", err)
		}
		delete(object, "opacity")
	}

	if raw, found := object["primaryColor"]; found {
		err = json.Unmarshal(raw, &a.PrimaryColor)
		if err != nil {
			return fmt.Errorf("error reading 'primaryColor': %w", err)
		}
		delete(object, "primaryColor")
	}

	if raw, found := object["secondaryColor"]; found {
		err = json.Unmarshal(raw, &a.SecondaryColor)
		if err != nil {
			return fmt.Errorf("error reading 'secondaryColor': %w", err)
		}
		delete(object, "secondaryColor")
	}

	if raw, found := object["svgColor"]; found {
		err = json.Unmarshal(raw, &a.SvgColor)
		if err != nil {
			return fmt.Errorf("error reading 'svgColor': %w", err)
		}
		delete(object, "svgColor")
	}

	if raw, found := object["svgComplete"]; found {
		err = json.Unmarshal(raw, &a.SvgComplete)
		if err != nil {
			return fmt.Errorf("error reading 'svgComplete': %w", err)
		}
		delete(object, "svgComplete")
	}

	if raw, found := object["svgWhite"]; found {
		err = json.Unmarshal(raw, &a.SvgWhite)
		if err != nil {
			return fmt.Errorf("error reading 'svgWhite': %w", err)
		}
		delete(object, "svgWhite")
	}

	if raw, found := object["text-opacity"]; found {
		err = json.Unmarshal(raw, &a.TextOpacity)
		if err != nil {
			return fmt.Errorf("error reading 'text-opacity': %w", err)
		}
		delete(object, "text-opacity")
	}

	if raw, found := object["text-transform"]; found {
		err = json.Unmarshal(raw, &a.TextTransform)
		if err != nil {
			return fmt.Errorf("error reading 'text-transform': %w", err)
		}
		delete(object, "text-transform")
	}

	if raw, found := object["z-index"]; found {
		err = json.Unmarshal(raw, &a.ZIndex)
		if err != nil {
			return fmt.Errorf("error reading 'z-index': %w", err)
		}
		delete(object, "z-index")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Styles to handle AdditionalProperties
func (a Styles) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Animation != nil {
		object["animation"], err = json.Marshal(a.Animation)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'animation': %w", err)
		}
	}

	if a.Color != nil {
		object["color"], err = json.Marshal(a.Color)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'color': %w", err)
		}
	}

	if a.FontFamily != nil {
		object["font-family"], err = json.Marshal(a.FontFamily)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'font-family': %w", err)
		}
	}

	if a.FontSize != nil {
		object["font-size"], err = json.Marshal(a.FontSize)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'font-size': %w", err)
		}
	}

	if a.FontStyle != nil {
		object["font-style"], err = json.Marshal(a.FontStyle)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'font-style': %w", err)
		}
	}

	if a.FontWeight != nil {
		object["font-weight"], err = json.Marshal(a.FontWeight)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'font-weight': %w", err)
		}
	}

	if a.Label != nil {
		object["label"], err = json.Marshal(a.Label)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'label': %w", err)
		}
	}

	if a.Opacity != nil {
		object["opacity"], err = json.Marshal(a.Opacity)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'opacity': %w", err)
		}
	}

	object["primaryColor"], err = json.Marshal(a.PrimaryColor)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'primaryColor': %w", err)
	}

	if a.SecondaryColor != nil {
		object["secondaryColor"], err = json.Marshal(a.SecondaryColor)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'secondaryColor': %w", err)
		}
	}

	object["svgColor"], err = json.Marshal(a.SvgColor)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'svgColor': %w", err)
	}

	object["svgComplete"], err = json.Marshal(a.SvgComplete)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'svgComplete': %w", err)
	}

	object["svgWhite"], err = json.Marshal(a.SvgWhite)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'svgWhite': %w", err)
	}

	if a.TextOpacity != nil {
		object["text-opacity"], err = json.Marshal(a.TextOpacity)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'text-opacity': %w", err)
		}
	}

	if a.TextTransform != nil {
		object["text-transform"], err = json.Marshal(a.TextTransform)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'text-transform': %w", err)
		}
	}

	if a.ZIndex != nil {
		object["z-index"], err = json.Marshal(a.ZIndex)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'z-index': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// AsRelationshipStyles0 returns the union data inside the RelationshipStyles as a RelationshipStyles0
func (t RelationshipStyles) AsRelationshipStyles0() (RelationshipStyles0, error) {
	var body RelationshipStyles0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRelationshipStyles0 overwrites any union data inside the RelationshipStyles as the provided RelationshipStyles0
func (t *RelationshipStyles) FromRelationshipStyles0(v RelationshipStyles0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRelationshipStyles0 performs a merge with any union data inside the RelationshipStyles, using the provided RelationshipStyles0
func (t *RelationshipStyles) MergeRelationshipStyles0(v RelationshipStyles0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRelationshipStyles1 returns the union data inside the RelationshipStyles as a RelationshipStyles1
func (t RelationshipStyles) AsRelationshipStyles1() (RelationshipStyles1, error) {
	var body RelationshipStyles1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRelationshipStyles1 overwrites any union data inside the RelationshipStyles as the provided RelationshipStyles1
func (t *RelationshipStyles) FromRelationshipStyles1(v RelationshipStyles1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRelationshipStyles1 performs a merge with any union data inside the RelationshipStyles, using the provided RelationshipStyles1
func (t *RelationshipStyles) MergeRelationshipStyles1(v RelationshipStyles1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t RelationshipStyles) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *RelationshipStyles) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}
