// Package core provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package core

import (
	"encoding/json"
	"fmt"
	"time"

	"database/sql"

	"github.com/gofrs/uuid"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// Defines values for IaCFileTypes.
const (
	DockerCompose IaCFileTypes = "docker-compose"
	HelmChart     IaCFileTypes = "helm-chart"
	K8sKustomize  IaCFileTypes = "k8s-kustomize"
	K8sManifest   IaCFileTypes = "k8s-manifest"
	MesheryDesign IaCFileTypes = "meshery-design"
)

// Defines values for ComponentStylesBorderStyle.
const (
	ComponentStylesBorderStyleDashed ComponentStylesBorderStyle = "dashed"
	ComponentStylesBorderStyleDotted ComponentStylesBorderStyle = "dotted"
	ComponentStylesBorderStyleDouble ComponentStylesBorderStyle = "double"
	ComponentStylesBorderStyleSolid  ComponentStylesBorderStyle = "solid"
)

// Defines values for ComponentStylesGhost.
const (
	No  ComponentStylesGhost = "no"
	Yes ComponentStylesGhost = "yes"
)

// Defines values for ComponentStylesShape.
const (
	ComponentStylesShapeBarrel               ComponentStylesShape = "barrel"
	ComponentStylesShapeBottomRoundRectangle ComponentStylesShape = "bottom-round-rectangle"
	ComponentStylesShapeConcaveHexagon       ComponentStylesShape = "concave-hexagon"
	ComponentStylesShapeCutRectangle         ComponentStylesShape = "cut-rectangle"
	ComponentStylesShapeDiamond              ComponentStylesShape = "diamond"
	ComponentStylesShapeEllipse              ComponentStylesShape = "ellipse"
	ComponentStylesShapeHeptagon             ComponentStylesShape = "heptagon"
	ComponentStylesShapeHexagon              ComponentStylesShape = "hexagon"
	ComponentStylesShapeOctagon              ComponentStylesShape = "octagon"
	ComponentStylesShapePentagon             ComponentStylesShape = "pentagon"
	ComponentStylesShapePolygon              ComponentStylesShape = "polygon"
	ComponentStylesShapeRectangle            ComponentStylesShape = "rectangle"
	ComponentStylesShapeRhomboid             ComponentStylesShape = "rhomboid"
	ComponentStylesShapeRoundDiamond         ComponentStylesShape = "round-diamond"
	ComponentStylesShapeRoundHeptagon        ComponentStylesShape = "round-heptagon"
	ComponentStylesShapeRoundHexagon         ComponentStylesShape = "round-hexagon"
	ComponentStylesShapeRoundOctagon         ComponentStylesShape = "round-octagon"
	ComponentStylesShapeRoundPentagon        ComponentStylesShape = "round-pentagon"
	ComponentStylesShapeRoundRectangle       ComponentStylesShape = "round-rectangle"
	ComponentStylesShapeRoundTag             ComponentStylesShape = "round-tag"
	ComponentStylesShapeRoundTriangle        ComponentStylesShape = "round-triangle"
	ComponentStylesShapeStar                 ComponentStylesShape = "star"
	ComponentStylesShapeTag                  ComponentStylesShape = "tag"
	ComponentStylesShapeTriangle             ComponentStylesShape = "triangle"
	ComponentStylesShapeVee                  ComponentStylesShape = "vee"
)

// Defines values for ComponentStylesTextHalign.
const (
	ComponentStylesTextHalignCenter ComponentStylesTextHalign = "center"
	ComponentStylesTextHalignLeft   ComponentStylesTextHalign = "left"
	ComponentStylesTextHalignRight  ComponentStylesTextHalign = "right"
)

// Defines values for ComponentStylesTextTransform.
const (
	ComponentStylesTextTransformLowercase ComponentStylesTextTransform = "lowercase"
	ComponentStylesTextTransformNone      ComponentStylesTextTransform = "none"
	ComponentStylesTextTransformUppercase ComponentStylesTextTransform = "uppercase"
)

// Defines values for ComponentStylesTextValign.
const (
	ComponentStylesTextValignBottom ComponentStylesTextValign = "bottom"
	ComponentStylesTextValignCenter ComponentStylesTextValign = "center"
	ComponentStylesTextValignTop    ComponentStylesTextValign = "top"
)

// Defines values for EdgeStylesCurveStyle.
const (
	EdgeStylesCurveStyleBezier          EdgeStylesCurveStyle = "bezier"
	EdgeStylesCurveStyleHaystack        EdgeStylesCurveStyle = "haystack"
	EdgeStylesCurveStyleSegments        EdgeStylesCurveStyle = "segments"
	EdgeStylesCurveStyleStraight        EdgeStylesCurveStyle = "straight"
	EdgeStylesCurveStyleTaxi            EdgeStylesCurveStyle = "taxi"
	EdgeStylesCurveStyleUnbundledBezier EdgeStylesCurveStyle = "unbundled-bezier"
)

// Defines values for EdgeStylesLineCap.
const (
	EdgeStylesLineCapButt   EdgeStylesLineCap = "butt"
	EdgeStylesLineCapRound  EdgeStylesLineCap = "round"
	EdgeStylesLineCapSquare EdgeStylesLineCap = "square"
)

// Defines values for EdgeStylesLineStyle.
const (
	EdgeStylesLineStyleDashed EdgeStylesLineStyle = "dashed"
	EdgeStylesLineStyleDotted EdgeStylesLineStyle = "dotted"
	EdgeStylesLineStyleSolid  EdgeStylesLineStyle = "solid"
)

// Defines values for EdgeStylesMidTargetArrowFill.
const (
	EdgeStylesMidTargetArrowFillFilled EdgeStylesMidTargetArrowFill = "filled"
	EdgeStylesMidTargetArrowFillHollow EdgeStylesMidTargetArrowFill = "hollow"
)

// Defines values for EdgeStylesMidTargetArrowShape.
const (
	EdgeStylesMidTargetArrowShapeChevron           EdgeStylesMidTargetArrowShape = "chevron"
	EdgeStylesMidTargetArrowShapeCircle            EdgeStylesMidTargetArrowShape = "circle"
	EdgeStylesMidTargetArrowShapeCircleTriangle    EdgeStylesMidTargetArrowShape = "circle-triangle"
	EdgeStylesMidTargetArrowShapeDiamond           EdgeStylesMidTargetArrowShape = "diamond"
	EdgeStylesMidTargetArrowShapeNone              EdgeStylesMidTargetArrowShape = "none"
	EdgeStylesMidTargetArrowShapeSquare            EdgeStylesMidTargetArrowShape = "square"
	EdgeStylesMidTargetArrowShapeTee               EdgeStylesMidTargetArrowShape = "tee"
	EdgeStylesMidTargetArrowShapeTriangle          EdgeStylesMidTargetArrowShape = "triangle"
	EdgeStylesMidTargetArrowShapeTriangleBackcurve EdgeStylesMidTargetArrowShape = "triangle-backcurve"
	EdgeStylesMidTargetArrowShapeTriangleCross     EdgeStylesMidTargetArrowShape = "triangle-cross"
	EdgeStylesMidTargetArrowShapeTriangleTee       EdgeStylesMidTargetArrowShape = "triangle-tee"
	EdgeStylesMidTargetArrowShapeVee               EdgeStylesMidTargetArrowShape = "vee"
)

// Defines values for EdgeStylesTargetArrowFill.
const (
	EdgeStylesTargetArrowFillFilled EdgeStylesTargetArrowFill = "filled"
	EdgeStylesTargetArrowFillHollow EdgeStylesTargetArrowFill = "hollow"
)

// Defines values for EdgeStylesTargetArrowShape.
const (
	EdgeStylesTargetArrowShapeChevron           EdgeStylesTargetArrowShape = "chevron"
	EdgeStylesTargetArrowShapeCircle            EdgeStylesTargetArrowShape = "circle"
	EdgeStylesTargetArrowShapeCircleTriangle    EdgeStylesTargetArrowShape = "circle-triangle"
	EdgeStylesTargetArrowShapeDiamond           EdgeStylesTargetArrowShape = "diamond"
	EdgeStylesTargetArrowShapeNone              EdgeStylesTargetArrowShape = "none"
	EdgeStylesTargetArrowShapeSquare            EdgeStylesTargetArrowShape = "square"
	EdgeStylesTargetArrowShapeTee               EdgeStylesTargetArrowShape = "tee"
	EdgeStylesTargetArrowShapeTriangle          EdgeStylesTargetArrowShape = "triangle"
	EdgeStylesTargetArrowShapeTriangleBackcurve EdgeStylesTargetArrowShape = "triangle-backcurve"
	EdgeStylesTargetArrowShapeTriangleCross     EdgeStylesTargetArrowShape = "triangle-cross"
	EdgeStylesTargetArrowShapeTriangleTee       EdgeStylesTargetArrowShape = "triangle-tee"
	EdgeStylesTargetArrowShapeVee               EdgeStylesTargetArrowShape = "vee"
)

// Defines values for EdgeStylesTextTransform.
const (
	EdgeStylesTextTransformLowercase EdgeStylesTextTransform = "lowercase"
	EdgeStylesTextTransformNone      EdgeStylesTextTransform = "none"
	EdgeStylesTextTransformUppercase EdgeStylesTextTransform = "uppercase"
)

// Defines values for RelationshipStyles0CurveStyle.
const (
	RelationshipStyles0CurveStyleBezier          RelationshipStyles0CurveStyle = "bezier"
	RelationshipStyles0CurveStyleHaystack        RelationshipStyles0CurveStyle = "haystack"
	RelationshipStyles0CurveStyleSegments        RelationshipStyles0CurveStyle = "segments"
	RelationshipStyles0CurveStyleStraight        RelationshipStyles0CurveStyle = "straight"
	RelationshipStyles0CurveStyleTaxi            RelationshipStyles0CurveStyle = "taxi"
	RelationshipStyles0CurveStyleUnbundledBezier RelationshipStyles0CurveStyle = "unbundled-bezier"
)

// Defines values for RelationshipStyles0LineCap.
const (
	RelationshipStyles0LineCapButt   RelationshipStyles0LineCap = "butt"
	RelationshipStyles0LineCapRound  RelationshipStyles0LineCap = "round"
	RelationshipStyles0LineCapSquare RelationshipStyles0LineCap = "square"
)

// Defines values for RelationshipStyles0LineStyle.
const (
	Dashed RelationshipStyles0LineStyle = "dashed"
	Dotted RelationshipStyles0LineStyle = "dotted"
	Solid  RelationshipStyles0LineStyle = "solid"
)

// Defines values for RelationshipStyles0MidTargetArrowFill.
const (
	RelationshipStyles0MidTargetArrowFillFilled RelationshipStyles0MidTargetArrowFill = "filled"
	RelationshipStyles0MidTargetArrowFillHollow RelationshipStyles0MidTargetArrowFill = "hollow"
)

// Defines values for RelationshipStyles0MidTargetArrowShape.
const (
	RelationshipStyles0MidTargetArrowShapeChevron           RelationshipStyles0MidTargetArrowShape = "chevron"
	RelationshipStyles0MidTargetArrowShapeCircle            RelationshipStyles0MidTargetArrowShape = "circle"
	RelationshipStyles0MidTargetArrowShapeCircleTriangle    RelationshipStyles0MidTargetArrowShape = "circle-triangle"
	RelationshipStyles0MidTargetArrowShapeDiamond           RelationshipStyles0MidTargetArrowShape = "diamond"
	RelationshipStyles0MidTargetArrowShapeNone              RelationshipStyles0MidTargetArrowShape = "none"
	RelationshipStyles0MidTargetArrowShapeSquare            RelationshipStyles0MidTargetArrowShape = "square"
	RelationshipStyles0MidTargetArrowShapeTee               RelationshipStyles0MidTargetArrowShape = "tee"
	RelationshipStyles0MidTargetArrowShapeTriangle          RelationshipStyles0MidTargetArrowShape = "triangle"
	RelationshipStyles0MidTargetArrowShapeTriangleBackcurve RelationshipStyles0MidTargetArrowShape = "triangle-backcurve"
	RelationshipStyles0MidTargetArrowShapeTriangleCross     RelationshipStyles0MidTargetArrowShape = "triangle-cross"
	RelationshipStyles0MidTargetArrowShapeTriangleTee       RelationshipStyles0MidTargetArrowShape = "triangle-tee"
	RelationshipStyles0MidTargetArrowShapeVee               RelationshipStyles0MidTargetArrowShape = "vee"
)

// Defines values for RelationshipStyles0TargetArrowFill.
const (
	RelationshipStyles0TargetArrowFillFilled RelationshipStyles0TargetArrowFill = "filled"
	RelationshipStyles0TargetArrowFillHollow RelationshipStyles0TargetArrowFill = "hollow"
)

// Defines values for RelationshipStyles0TargetArrowShape.
const (
	RelationshipStyles0TargetArrowShapeChevron           RelationshipStyles0TargetArrowShape = "chevron"
	RelationshipStyles0TargetArrowShapeCircle            RelationshipStyles0TargetArrowShape = "circle"
	RelationshipStyles0TargetArrowShapeCircleTriangle    RelationshipStyles0TargetArrowShape = "circle-triangle"
	RelationshipStyles0TargetArrowShapeDiamond           RelationshipStyles0TargetArrowShape = "diamond"
	RelationshipStyles0TargetArrowShapeNone              RelationshipStyles0TargetArrowShape = "none"
	RelationshipStyles0TargetArrowShapeSquare            RelationshipStyles0TargetArrowShape = "square"
	RelationshipStyles0TargetArrowShapeTee               RelationshipStyles0TargetArrowShape = "tee"
	RelationshipStyles0TargetArrowShapeTriangle          RelationshipStyles0TargetArrowShape = "triangle"
	RelationshipStyles0TargetArrowShapeTriangleBackcurve RelationshipStyles0TargetArrowShape = "triangle-backcurve"
	RelationshipStyles0TargetArrowShapeTriangleCross     RelationshipStyles0TargetArrowShape = "triangle-cross"
	RelationshipStyles0TargetArrowShapeTriangleTee       RelationshipStyles0TargetArrowShape = "triangle-tee"
	RelationshipStyles0TargetArrowShapeVee               RelationshipStyles0TargetArrowShape = "vee"
)

// Defines values for RelationshipStyles0TextTransform.
const (
	RelationshipStyles0TextTransformLowercase RelationshipStyles0TextTransform = "lowercase"
	RelationshipStyles0TextTransformNone      RelationshipStyles0TextTransform = "none"
	RelationshipStyles0TextTransformUppercase RelationshipStyles0TextTransform = "uppercase"
)

// Defines values for RelationshipStyles1TextTransform.
const (
	RelationshipStyles1TextTransformLowercase RelationshipStyles1TextTransform = "lowercase"
	RelationshipStyles1TextTransformNone      RelationshipStyles1TextTransform = "none"
	RelationshipStyles1TextTransformUppercase RelationshipStyles1TextTransform = "uppercase"
)

// Defines values for Shape.
const (
	Barrel               Shape = "barrel"
	BottomRoundRectangle Shape = "bottom-round-rectangle"
	ConcaveHexagon       Shape = "concave-hexagon"
	CutRectangle         Shape = "cut-rectangle"
	Diamond              Shape = "diamond"
	Ellipse              Shape = "ellipse"
	Heptagon             Shape = "heptagon"
	Hexagon              Shape = "hexagon"
	Octagon              Shape = "octagon"
	Pentagon             Shape = "pentagon"
	Polygon              Shape = "polygon"
	Rectangle            Shape = "rectangle"
	Rhomboid             Shape = "rhomboid"
	RoundDiamond         Shape = "round-diamond"
	RoundHeptagon        Shape = "round-heptagon"
	RoundHexagon         Shape = "round-hexagon"
	RoundOctagon         Shape = "round-octagon"
	RoundPentagon        Shape = "round-pentagon"
	RoundRectangle       Shape = "round-rectangle"
	RoundTag             Shape = "round-tag"
	RoundTriangle        Shape = "round-triangle"
	Star                 Shape = "star"
	Tag                  Shape = "tag"
	Triangle             Shape = "triangle"
	Vee                  Shape = "vee"
)

// Defines values for StylesTextTransform.
const (
	StylesTextTransformLowercase StylesTextTransform = "lowercase"
	StylesTextTransformNone      StylesTextTransform = "none"
	StylesTextTransformUppercase StylesTextTransform = "uppercase"
)

// Endpoint endpoint
type Endpoint = string

// IaCFileTypes The type of the IaC file
type IaCFileTypes string

// Id defines model for Id.
type Id = uuid.UUID

// MapObject defines model for MapObject.
type MapObject map[string]string

// NonResolvedAlias An alias is an component that acts as an ref/pointer to a field in another component, nonResolvedAlias are not aware of there immediate parents
type NonResolvedAlias struct {
	// AliasComponentId A Universally Unique Identifier used to uniquely identify entities in Meshery. The UUID core definition is used across different schemas.
	AliasComponentId uuid.UUID `json:"alias_component_id"`

	// ImmediateParentId A Universally Unique Identifier used to uniquely identify entities in Meshery. The UUID core definition is used across different schemas.
	ImmediateParentId     uuid.UUID `json:"immediate_parent_id"`
	ImmediateRefFieldPath []string  `json:"immediate_ref_field_path"`

	// RelationshipId A Universally Unique Identifier used to uniquely identify entities in Meshery. The UUID core definition is used across different schemas.
	RelationshipId uuid.UUID `json:"relationship_id"`
}

// ResolvedAlias defines model for ResolvedAlias.
type ResolvedAlias struct {
	// AliasComponentId A Universally Unique Identifier used to uniquely identify entities in Meshery. The UUID core definition is used across different schemas.
	AliasComponentId uuid.UUID `json:"alias_component_id"`

	// ImmediateParentId A Universally Unique Identifier used to uniquely identify entities in Meshery. The UUID core definition is used across different schemas.
	ImmediateParentId     uuid.UUID `json:"immediate_parent_id"`
	ImmediateRefFieldPath []string  `json:"immediate_ref_field_path"`

	// RelationshipId A Universally Unique Identifier used to uniquely identify entities in Meshery. The UUID core definition is used across different schemas.
	RelationshipId uuid.UUID `json:"relationship_id"`

	// ResolvedParentId A Universally Unique Identifier used to uniquely identify entities in Meshery. The UUID core definition is used across different schemas.
	ResolvedParentId     uuid.UUID `json:"resolved_parent_id"`
	ResolvedRefFieldPath []string  `json:"resolved_ref_field_path"`
}

// SqlNullTime defines model for SqlNullTime.
type SqlNullTime = sql.NullTime

// Text defines model for Text.
type Text = string

// Time defines model for Time.
type Time = time.Time

// AcceptedTermsAt defines model for accepted_terms_at.
type AcceptedTermsAt = string

// AvatarUrl Link for profile picture
type AvatarUrl = string

// Bio defines model for bio.
type Bio = string

// ComponentStyles defines model for componentStyles.
type ComponentStyles struct {
	// ActiveBgColor The colour of the indicator shown when the background is grabbed by the user. Selector needs to be *core*. Colours may be specified by name (e.g. red), hex (e.g.
	ActiveBgColor *string `json:"active-bg-color,omitempty"`

	// ActiveBgOpacity The opacity of the active background indicator. Selector needs to be *core*.
	ActiveBgOpacity *string `json:"active-bg-opacity,omitempty"`

	// ActiveBgSize The opacity of the active background indicator. Selector needs to be *core*.
	ActiveBgSize *string `json:"active-bg-size,omitempty"`

	// Animation The animation to apply to the element. example ripple,bounce,etc
	Animation *map[string]interface{} `json:"animation,omitempty"`

	// BackgroundBlacken Blackens the node's body for values from 0 to 1; whitens the node's body for values from 0 to -1.
	BackgroundBlacken *float32 `json:"background-blacken,omitempty"`

	// BackgroundClip How the background image is clipped to the node. Can be 'none', 'node', or 'node-border'.
	BackgroundClip *string `json:"background-clip,omitempty"`

	// BackgroundColor The colour of the node's body. Colours may be specified by name (e.g. red), hex (e.g.
	BackgroundColor *string `json:"background-color,omitempty"`

	// BackgroundFit How the background image is fit to the node. Can be 'none', 'contain', or 'cover'.
	BackgroundFit *string `json:"background-fit,omitempty"`

	// BackgroundHeightRelativeTo How the background image's height is determined. Can be 'none', 'inner', or 'outer'.
	BackgroundHeightRelativeTo *string `json:"background-height-relative-to,omitempty"`

	// BackgroundImage The URL that points to the image to show in the node.
	BackgroundImage *string `json:"background-image,omitempty"`

	// BackgroundOffsetX The x offset of the background image, measured in percent (e.g. 50%) or pixels (e.g. 10px)
	BackgroundOffsetX *string `json:"background-offset-x,omitempty"`

	// BackgroundOffsetY The y offset of the background image, measured in percent (e.g. 50%) or pixels (e.g. 10px)
	BackgroundOffsetY *string `json:"background-offset-y,omitempty"`

	// BackgroundOpacity The opacity level of the node's background colour
	BackgroundOpacity *float32 `json:"background-opacity,omitempty"`

	// BackgroundPositionX The x position of the background image, measured in percent (e.g. 50%) or pixels (e.g. 10px)
	BackgroundPositionX *string `json:"background-position-x,omitempty"`

	// BackgroundPositionY The y position of the background image, measured in percent (e.g. 50%) or pixels (e.g. 10px)
	BackgroundPositionY *string `json:"background-position-y,omitempty"`

	// BackgroundWidthRelativeTo How the background image's width is determined. Can be 'none', 'inner', or 'outer'.
	BackgroundWidthRelativeTo *string `json:"background-width-relative-to,omitempty"`

	// BodyText The text to display for an element's body. Can give a path, e.g. data(id) will label with the elements id
	BodyText *string `json:"body-text,omitempty"`

	// BodyTextBackgroundColor The colour of the node's body text background. Colours may be specified by name (e.g. red), hex (e.g.
	BodyTextBackgroundColor *string `json:"body-text-background-color,omitempty"`

	// BodyTextColor The colour of the node's body text. Colours may be specified by name (e.g. red), hex (e.g.
	BodyTextColor *string `json:"body-text-color,omitempty"`

	// BodyTextDecoration A CSS text decoration to be applied to the node's body text.
	BodyTextDecoration *string `json:"body-text-decoration,omitempty"`

	// BodyTextFontSize The size of the node's body text.
	BodyTextFontSize *float32 `json:"body-text-font-size,omitempty"`

	// BodyTextFontWeight A CSS font weight to be applied to the node's body text.
	BodyTextFontWeight *string `json:"body-text-font-weight,omitempty"`

	// BodyTextHorizontalAlign A CSS horizontal alignment to be applied to the node's body text.
	BodyTextHorizontalAlign *string `json:"body-text-horizontal-align,omitempty"`

	// BodyTextMaxWidth The maximum width for wrapping text in the node.
	BodyTextMaxWidth *string `json:"body-text-max-width,omitempty"`

	// BodyTextOpacity The opacity of the node's body text, including its outline.
	BodyTextOpacity *float32 `json:"body-text-opacity,omitempty"`

	// BodyTextVerticalAlign A CSS vertical alignment to be applied to the node's body text.
	BodyTextVerticalAlign *string `json:"body-text-vertical-align,omitempty"`

	// BodyTextWrap How to wrap the text in the node. Can be 'none', 'wrap', or 'ellipsis'.
	BodyTextWrap *string `json:"body-text-wrap,omitempty"`

	// BorderColor The colour of the node's border. Colours may be specified by name (e.g. red), hex (e.g.
	BorderColor *string `json:"border-color,omitempty"`

	// BorderOpacity The opacity of the node's border
	BorderOpacity *float32 `json:"border-opacity,omitempty"`

	// BorderStyle The style of the node's border
	BorderStyle *ComponentStylesBorderStyle `json:"border-style,omitempty"`

	// BorderWidth The size of the node's border.
	BorderWidth *float32 `json:"border-width,omitempty"`

	// Color The color of the element's label. Colours may be specified by name (e.g. red), hex (e.g.
	Color *string `json:"color,omitempty"`

	// FontFamily A comma-separated list of font names to use on the label text.
	FontFamily *string `json:"font-family,omitempty"`

	// FontSize The size of the label text.
	FontSize *string `json:"font-size,omitempty"`

	// FontStyle A CSS font style to be applied to the label text.
	FontStyle *string `json:"font-style,omitempty"`

	// FontWeight A CSS font weight to be applied to the label text.
	FontWeight *string `json:"font-weight,omitempty"`

	// Ghost Whether to use the ghost effect, a semitransparent duplicate of the element drawn at an offset.
	Ghost *ComponentStylesGhost `json:"ghost,omitempty"`

	// Height The height of the node's body
	Height *float32 `json:"height,omitempty"`

	// Label The text to display for an element's label. Can give a path, e.g. data(id) will label with the elements id
	Label *string `json:"label,omitempty"`

	// MenuBackgroundColor The colour of the background of the component menu. Colours may be specified by name (e.g. red), hex (e.g.
	MenuBackgroundColor *string `json:"menu-background-color,omitempty"`

	// MenuBackgroundOpacity The opacity of the background of the component menu.
	MenuBackgroundOpacity *float32 `json:"menu-background-opacity,omitempty"`

	// MenuForgroundColor The colour of the text or icons in the component menu. Colours may be specified by name (e.g. red), hex (e.g.
	MenuForgroundColor *string `json:"menu-forground-color,omitempty"`

	// Opacity The opacity of the element, ranging from 0 to 1. Note that the opacity of a compound node parent affects the effective opacity of its children.
	Opacity *float32 `json:"opacity,omitempty"`

	// OutsideTextureBgColor The colour of the area outside the viewport texture when initOptions.textureOnViewport === true. Selector needs to be *core*. Colours may be specified by name (e.g. red), hex (e.g.
	OutsideTextureBgColor *string `json:"outside-texture-bg-color,omitempty"`

	// OutsideTextureBgOpacity The opacity of the area outside the viewport texture. Selector needs to be *core*
	OutsideTextureBgOpacity *float32 `json:"outside-texture-bg-opacity,omitempty"`

	// Padding The amount of padding around all sides of the node.
	Padding *float32 `json:"padding,omitempty"`

	// Position The position of the node. If the position is set, the node is drawn at that position in the given dimensions. If the position is not set, the node is drawn at a random position.
	Position *struct {
		// X The x-coordinate of the node.
		X float64 `json:"x"`

		// Y The y-coordinate of the node.
		Y float64 `json:"y"`
	} `json:"position,omitempty"`

	// PrimaryColor Primary color of the component used for UI representation.
	PrimaryColor string `json:"primaryColor"`

	// SecondaryColor Secondary color of the entity used for UI representation.
	SecondaryColor *string `json:"secondaryColor,omitempty"`

	// SelectionBoxBorderWidth The size of the border on the selection box. Selector needs to be *core*
	SelectionBoxBorderWidth *float32 `json:"selection-box-border-width,omitempty"`

	// SelectionBoxColor The background colour of the selection box used for drag selection. Selector needs to be *core*. Colours may be specified by name (e.g. red), hex (e.g.
	SelectionBoxColor *string `json:"selection-box-color,omitempty"`

	// SelectionBoxOpacity The opacity of the selection box. Selector needs to be *core*
	SelectionBoxOpacity *float32 `json:"selection-box-opacity,omitempty"`

	// Shape The shape of the node's body. Note that each shape fits within the specified width and height, and so you may have to adjust width and height if you desire an equilateral shape (i.e. width !== height for several equilateral shapes)
	Shape *ComponentStylesShape `json:"shape,omitempty"`

	// ShapePolygonPoints An array (or a space-separated string) of numbers ranging on [-1, 1], representing alternating x and y values (i.e. x1 y1 x2 y2, x3 y3 ...). This represents the points in the polygon for the node's shape. The bounding box of the node is given by (-1, -1), (1, -1), (1, 1), (-1, 1). The node's position is the origin (0, 0 )
	ShapePolygonPoints *string `json:"shape-polygon-points,omitempty"`

	// SvgColor Colored SVG of the entity used for UI representation on light background.
	SvgColor string `json:"svgColor"`

	// SvgComplete Complete SVG of the entity used for UI representation, often inclusive of background.
	SvgComplete string `json:"svgComplete"`

	// SvgWhite White SVG of the entity used for UI representation on dark background.
	SvgWhite string `json:"svgWhite"`

	// TextHalign The horizontal alignment of a node's label
	TextHalign *ComponentStylesTextHalign `json:"text-halign,omitempty"`

	// TextOpacity The opacity of the label text, including its outline.
	TextOpacity *float32 `json:"text-opacity,omitempty"`

	// TextTransform A transformation to apply to the label text
	TextTransform *ComponentStylesTextTransform `json:"text-transform,omitempty"`

	// TextValign The vertical alignment of a node's label
	TextValign *ComponentStylesTextValign `json:"text-valign,omitempty"`

	// Width The width of the node's body or the width of an edge's line.
	Width *float32 `json:"width,omitempty"`

	// ZIndex An integer value that affects the relative draw order of elements. In general, an element with a higher z-index will be drawn on top of an element with a lower z-index. Note that edges are under nodes despite z-index.
	ZIndex               *int                   `json:"z-index,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// ComponentStylesBorderStyle The style of the node's border
type ComponentStylesBorderStyle string

// ComponentStylesGhost Whether to use the ghost effect, a semitransparent duplicate of the element drawn at an offset.
type ComponentStylesGhost string

// ComponentStylesShape The shape of the node's body. Note that each shape fits within the specified width and height, and so you may have to adjust width and height if you desire an equilateral shape (i.e. width !== height for several equilateral shapes)
type ComponentStylesShape string

// ComponentStylesTextHalign The horizontal alignment of a node's label
type ComponentStylesTextHalign string

// ComponentStylesTextTransform A transformation to apply to the label text
type ComponentStylesTextTransform string

// ComponentStylesTextValign The vertical alignment of a node's label
type ComponentStylesTextValign string

// CreatedAt Timestamp when the resource was created.
type CreatedAt = time.Time

// CredentialID defines model for credential_uuid.
type CredentialID = uuid.UUID

// DeletedAt Timestamp when the resource was deleted.
type DeletedAt = time.Time

// DesignId defines model for design_id.
type DesignId = uuid.UUID

// EdgeStyles defines model for edgeStyles.
type EdgeStyles struct {
	// Animation The animation to apply to the element. example ripple,bounce,etc
	Animation *map[string]interface{} `json:"animation,omitempty"`

	// ArrowScale Scaling for the arrow size.
	ArrowScale *float32 `json:"arrow-scale,omitempty"`

	// Color The color of the element's label. Colours may be specified by name (e.g. red), hex (e.g.
	Color *string `json:"color,omitempty"`

	// CurveStyle The curving method used to separate two or more edges between two nodes; may be haystack (very fast, bundled straight edges for which loops and compounds are unsupported), straight (straight edges with all arrows supported), bezier (bundled curved edges), unbundled-bezier (curved edges for use with manual control points), segments (a series of straight lines), taxi (right-angled lines, hierarchically bundled). Note that haystack edges work best with ellipse, rectangle, or similar nodes. Smaller node shapes, like triangle, will not be as aesthetically pleasing. Also note that edge endpoint arrows are unsupported for haystack edges.
	CurveStyle *EdgeStylesCurveStyle `json:"curve-style,omitempty"`

	// EdgeAnimation The animation to use for the edge. Can be like 'marching-ants' , 'blink' , 'moving-gradient',etc .
	EdgeAnimation *string `json:"edge-animation,omitempty"`

	// FontFamily A comma-separated list of font names to use on the label text.
	FontFamily *string `json:"font-family,omitempty"`

	// FontSize The size of the label text.
	FontSize *string `json:"font-size,omitempty"`

	// FontStyle A CSS font style to be applied to the label text.
	FontStyle *string `json:"font-style,omitempty"`

	// FontWeight A CSS font weight to be applied to the label text.
	FontWeight *string `json:"font-weight,omitempty"`

	// Label The text to display for an element's label. Can give a path, e.g. data(id) will label with the elements id
	Label *string `json:"label,omitempty"`

	// LineCap The cap style of the edge's line; may be butt (default), round, or square. The cap may or may not be visible, depending on the shape of the node and the relative size of the node and edge. Caps other than butt extend beyond the specified endpoint of the edge.
	LineCap *EdgeStylesLineCap `json:"line-cap,omitempty"`

	// LineColor The colour of the edge's line. Colours may be specified by name (e.g. red), hex (e.g.
	LineColor *string `json:"line-color,omitempty"`

	// LineOpacity The opacity of the edge's line and arrow. Useful if you wish to have a separate opacity for the edge label versus the edge line. Note that the opacity value of the edge element affects the effective opacity of its line and label subcomponents.
	LineOpacity *float32 `json:"line-opacity,omitempty"`

	// LineStyle The style of the edge's line.
	LineStyle *EdgeStylesLineStyle `json:"line-style,omitempty"`

	// MidTargetArrowColor The colour of the edge's source arrow. Colours may be specified by name (e.g. red), hex (e.g.
	MidTargetArrowColor *string `json:"mid-target-arrow-color,omitempty"`

	// MidTargetArrowFill The fill state of the edge's source arrow
	MidTargetArrowFill *EdgeStylesMidTargetArrowFill `json:"mid-target-arrow-fill,omitempty"`

	// MidTargetArrowShape The shape of the edge's source arrow
	MidTargetArrowShape *EdgeStylesMidTargetArrowShape `json:"mid-target-arrow-shape,omitempty"`

	// Opacity The opacity of the element, ranging from 0 to 1. Note that the opacity of a compound node parent affects the effective opacity of its children.
	Opacity *float32 `json:"opacity,omitempty"`

	// PrimaryColor Primary color of the component used for UI representation.
	PrimaryColor string `json:"primaryColor"`

	// SecondaryColor Secondary color of the entity used for UI representation.
	SecondaryColor *string `json:"secondaryColor,omitempty"`

	// SourceLabel The text to display for an edge's source label. Can give a path, e.g. data(id) will label with the elements id
	SourceLabel *string `json:"source-label,omitempty"`

	// SvgColor Colored SVG of the entity used for UI representation on light background.
	SvgColor string `json:"svgColor"`

	// SvgComplete Complete SVG of the entity used for UI representation, often inclusive of background.
	SvgComplete string `json:"svgComplete"`

	// SvgWhite White SVG of the entity used for UI representation on dark background.
	SvgWhite string `json:"svgWhite"`

	// TargetArrowColor The colour of the edge's source arrow. Colours may be specified by name (e.g. red), hex (e.g.
	TargetArrowColor *string `json:"target-arrow-color,omitempty"`

	// TargetArrowFill The fill state of the edge's source arrow
	TargetArrowFill *EdgeStylesTargetArrowFill `json:"target-arrow-fill,omitempty"`

	// TargetArrowShape The shape of the edge's source arrow
	TargetArrowShape *EdgeStylesTargetArrowShape `json:"target-arrow-shape,omitempty"`

	// TargetLabel The text to display for an edge's target label. Can give a path, e.g. data(id) will label with the elements id
	TargetLabel *string `json:"target-label,omitempty"`

	// TextOpacity The opacity of the label text, including its outline.
	TextOpacity *float32 `json:"text-opacity,omitempty"`

	// TextTransform A transformation to apply to the label text
	TextTransform *EdgeStylesTextTransform `json:"text-transform,omitempty"`

	// ZIndex An integer value that affects the relative draw order of elements. In general, an element with a higher z-index will be drawn on top of an element with a lower z-index. Note that edges are under nodes despite z-index.
	ZIndex               *int                   `json:"z-index,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// EdgeStylesCurveStyle The curving method used to separate two or more edges between two nodes; may be haystack (very fast, bundled straight edges for which loops and compounds are unsupported), straight (straight edges with all arrows supported), bezier (bundled curved edges), unbundled-bezier (curved edges for use with manual control points), segments (a series of straight lines), taxi (right-angled lines, hierarchically bundled). Note that haystack edges work best with ellipse, rectangle, or similar nodes. Smaller node shapes, like triangle, will not be as aesthetically pleasing. Also note that edge endpoint arrows are unsupported for haystack edges.
type EdgeStylesCurveStyle string

// EdgeStylesLineCap The cap style of the edge's line; may be butt (default), round, or square. The cap may or may not be visible, depending on the shape of the node and the relative size of the node and edge. Caps other than butt extend beyond the specified endpoint of the edge.
type EdgeStylesLineCap string

// EdgeStylesLineStyle The style of the edge's line.
type EdgeStylesLineStyle string

// EdgeStylesMidTargetArrowFill The fill state of the edge's source arrow
type EdgeStylesMidTargetArrowFill string

// EdgeStylesMidTargetArrowShape The shape of the edge's source arrow
type EdgeStylesMidTargetArrowShape string

// EdgeStylesTargetArrowFill The fill state of the edge's source arrow
type EdgeStylesTargetArrowFill string

// EdgeStylesTargetArrowShape The shape of the edge's source arrow
type EdgeStylesTargetArrowShape string

// EdgeStylesTextTransform A transformation to apply to the label text
type EdgeStylesTextTransform string

// Email email
type Email = openapi_types.Email

// EmailPreference defines model for email_preference.
type EmailPreference struct {
	NotifyRoleChange bool `json:"notify_role_change,omitempty"`
	WelcomeEmail     bool `json:"welcome_email,omitempty"`
}

// Emails defines model for emails.
type Emails = []openapi_types.Email

// Empty Body for empty request
type Empty = map[string]interface{}

// EnvironmentId defines model for environment_id.
type EnvironmentId = uuid.UUID

// GeneralId defines model for general_id.
type GeneralId = uuid.UUID

// InputString A string starting with an alphanumeric character. Spaces and hyphens allowed.
type InputString = string

// KubernetesServerID defines model for kubernetes_server_uuid.
type KubernetesServerID = uuid.UUID

// MesheryInstanceID defines model for meshery_instance_uuid.
type MesheryInstanceID = uuid.UUID

// NullTime SQL null Timestamp to handle null values of time.
type NullTime = sql.NullTime

// Number defines model for number.
type Number = int

// OperationID defines model for operation_id.
type OperationID = uuid.UUID

// OrganizationId defines model for organization_id.
type OrganizationId = uuid.UUID

// Price defines model for price.
type Price = int32

// Provider One of (x-oapi-codegen-extra-tags-cloud, github, google)
type Provider = string

// RecordsPage defines model for recordsPage.
type RecordsPage struct {
	Page         int    `json:"page,omitempty"`
	PageSize     int    `json:"page_size,omitempty"`
	RecordType   string `json:"recordType,omitempty"`
	RecordsTotal int    `json:"records_total,omitempty"`
}

// RelationshipStyles defines model for relationshipStyles.
type RelationshipStyles struct {
	union json.RawMessage
}

// RelationshipStyles0 defines model for .
type RelationshipStyles0 struct {
	// Animation The animation to apply to the element. example ripple,bounce,etc
	Animation *map[string]interface{} `json:"animation,omitempty"`

	// ArrowScale Scaling for the arrow size.
	ArrowScale *float32 `json:"arrow-scale,omitempty"`

	// Color The color of the element's label. Colours may be specified by name (e.g. red), hex (e.g.
	Color *string `json:"color,omitempty"`

	// CurveStyle The curving method used to separate two or more edges between two nodes; may be haystack (very fast, bundled straight edges for which loops and compounds are unsupported), straight (straight edges with all arrows supported), bezier (bundled curved edges), unbundled-bezier (curved edges for use with manual control points), segments (a series of straight lines), taxi (right-angled lines, hierarchically bundled). Note that haystack edges work best with ellipse, rectangle, or similar nodes. Smaller node shapes, like triangle, will not be as aesthetically pleasing. Also note that edge endpoint arrows are unsupported for haystack edges.
	CurveStyle *RelationshipStyles0CurveStyle `json:"curve-style,omitempty"`

	// EdgeAnimation The animation to use for the edge. Can be like 'marching-ants' , 'blink' , 'moving-gradient',etc .
	EdgeAnimation *string `json:"edge-animation,omitempty"`

	// FontFamily A comma-separated list of font names to use on the label text.
	FontFamily *string `json:"font-family,omitempty"`

	// FontSize The size of the label text.
	FontSize *string `json:"font-size,omitempty"`

	// FontStyle A CSS font style to be applied to the label text.
	FontStyle *string `json:"font-style,omitempty"`

	// FontWeight A CSS font weight to be applied to the label text.
	FontWeight *string `json:"font-weight,omitempty"`

	// Label The text to display for an element's label. Can give a path, e.g. data(id) will label with the elements id
	Label *string `json:"label,omitempty"`

	// LineCap The cap style of the edge's line; may be butt (default), round, or square. The cap may or may not be visible, depending on the shape of the node and the relative size of the node and edge. Caps other than butt extend beyond the specified endpoint of the edge.
	LineCap *RelationshipStyles0LineCap `json:"line-cap,omitempty"`

	// LineColor The colour of the edge's line. Colours may be specified by name (e.g. red), hex (e.g.
	LineColor *string `json:"line-color,omitempty"`

	// LineOpacity The opacity of the edge's line and arrow. Useful if you wish to have a separate opacity for the edge label versus the edge line. Note that the opacity value of the edge element affects the effective opacity of its line and label subcomponents.
	LineOpacity *float32 `json:"line-opacity,omitempty"`

	// LineStyle The style of the edge's line.
	LineStyle *RelationshipStyles0LineStyle `json:"line-style,omitempty"`

	// MidTargetArrowColor The colour of the edge's source arrow. Colours may be specified by name (e.g. red), hex (e.g.
	MidTargetArrowColor *string `json:"mid-target-arrow-color,omitempty"`

	// MidTargetArrowFill The fill state of the edge's source arrow
	MidTargetArrowFill *RelationshipStyles0MidTargetArrowFill `json:"mid-target-arrow-fill,omitempty"`

	// MidTargetArrowShape The shape of the edge's source arrow
	MidTargetArrowShape *RelationshipStyles0MidTargetArrowShape `json:"mid-target-arrow-shape,omitempty"`

	// Opacity The opacity of the element, ranging from 0 to 1. Note that the opacity of a compound node parent affects the effective opacity of its children.
	Opacity *float32 `json:"opacity,omitempty"`

	// PrimaryColor Primary color of the component used for UI representation.
	PrimaryColor string `json:"primaryColor"`

	// SecondaryColor Secondary color of the entity used for UI representation.
	SecondaryColor *string `json:"secondaryColor,omitempty"`

	// SourceLabel The text to display for an edge's source label. Can give a path, e.g. data(id) will label with the elements id
	SourceLabel *string `json:"source-label,omitempty"`

	// SvgColor Colored SVG of the entity used for UI representation on light background.
	SvgColor string `json:"svgColor"`

	// SvgComplete Complete SVG of the entity used for UI representation, often inclusive of background.
	SvgComplete string `json:"svgComplete"`

	// SvgWhite White SVG of the entity used for UI representation on dark background.
	SvgWhite string `json:"svgWhite"`

	// TargetArrowColor The colour of the edge's source arrow. Colours may be specified by name (e.g. red), hex (e.g.
	TargetArrowColor *string `json:"target-arrow-color,omitempty"`

	// TargetArrowFill The fill state of the edge's source arrow
	TargetArrowFill *RelationshipStyles0TargetArrowFill `json:"target-arrow-fill,omitempty"`

	// TargetArrowShape The shape of the edge's source arrow
	TargetArrowShape *RelationshipStyles0TargetArrowShape `json:"target-arrow-shape,omitempty"`

	// TargetLabel The text to display for an edge's target label. Can give a path, e.g. data(id) will label with the elements id
	TargetLabel *string `json:"target-label,omitempty"`

	// TextOpacity The opacity of the label text, including its outline.
	TextOpacity *float32 `json:"text-opacity,omitempty"`

	// TextTransform A transformation to apply to the label text
	TextTransform *RelationshipStyles0TextTransform `json:"text-transform,omitempty"`

	// ZIndex An integer value that affects the relative draw order of elements. In general, an element with a higher z-index will be drawn on top of an element with a lower z-index. Note that edges are under nodes despite z-index.
	ZIndex               *int                   `json:"z-index,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// RelationshipStyles0CurveStyle The curving method used to separate two or more edges between two nodes; may be haystack (very fast, bundled straight edges for which loops and compounds are unsupported), straight (straight edges with all arrows supported), bezier (bundled curved edges), unbundled-bezier (curved edges for use with manual control points), segments (a series of straight lines), taxi (right-angled lines, hierarchically bundled). Note that haystack edges work best with ellipse, rectangle, or similar nodes. Smaller node shapes, like triangle, will not be as aesthetically pleasing. Also note that edge endpoint arrows are unsupported for haystack edges.
type RelationshipStyles0CurveStyle string

// RelationshipStyles0LineCap The cap style of the edge's line; may be butt (default), round, or square. The cap may or may not be visible, depending on the shape of the node and the relative size of the node and edge. Caps other than butt extend beyond the specified endpoint of the edge.
type RelationshipStyles0LineCap string

// RelationshipStyles0LineStyle The style of the edge's line.
type RelationshipStyles0LineStyle string

// RelationshipStyles0MidTargetArrowFill The fill state of the edge's source arrow
type RelationshipStyles0MidTargetArrowFill string

// RelationshipStyles0MidTargetArrowShape The shape of the edge's source arrow
type RelationshipStyles0MidTargetArrowShape string

// RelationshipStyles0TargetArrowFill The fill state of the edge's source arrow
type RelationshipStyles0TargetArrowFill string

// RelationshipStyles0TargetArrowShape The shape of the edge's source arrow
type RelationshipStyles0TargetArrowShape string

// RelationshipStyles0TextTransform A transformation to apply to the label text
type RelationshipStyles0TextTransform string

// RelationshipStyles1 defines model for .
type RelationshipStyles1 struct {
	// Animation The animation to apply to the element. example ripple,bounce,etc
	Animation *map[string]interface{} `json:"animation,omitempty"`

	// Color The color of the element's label. Colours may be specified by name (e.g. red), hex (e.g.
	Color *string `json:"color,omitempty"`

	// FontFamily A comma-separated list of font names to use on the label text.
	FontFamily *string `json:"font-family,omitempty"`

	// FontSize The size of the label text.
	FontSize *string `json:"font-size,omitempty"`

	// FontStyle A CSS font style to be applied to the label text.
	FontStyle *string `json:"font-style,omitempty"`

	// FontWeight A CSS font weight to be applied to the label text.
	FontWeight *string `json:"font-weight,omitempty"`

	// Label The text to display for an element's label. Can give a path, e.g. data(id) will label with the elements id
	Label *string `json:"label,omitempty"`

	// Opacity The opacity of the element, ranging from 0 to 1. Note that the opacity of a compound node parent affects the effective opacity of its children.
	Opacity *float32 `json:"opacity,omitempty"`

	// PrimaryColor Primary color of the component used for UI representation.
	PrimaryColor string `json:"primaryColor"`

	// SecondaryColor Secondary color of the entity used for UI representation.
	SecondaryColor *string `json:"secondaryColor,omitempty"`

	// SvgColor Colored SVG of the entity used for UI representation on light background.
	SvgColor string `json:"svgColor"`

	// SvgComplete Complete SVG of the entity used for UI representation, often inclusive of background.
	SvgComplete string `json:"svgComplete"`

	// SvgWhite White SVG of the entity used for UI representation on dark background.
	SvgWhite string `json:"svgWhite"`

	// TextOpacity The opacity of the label text, including its outline.
	TextOpacity *float32 `json:"text-opacity,omitempty"`

	// TextTransform A transformation to apply to the label text
	TextTransform *RelationshipStyles1TextTransform `json:"text-transform,omitempty"`

	// ZIndex An integer value that affects the relative draw order of elements. In general, an element with a higher z-index will be drawn on top of an element with a lower z-index. Note that edges are under nodes despite z-index.
	ZIndex               *int                   `json:"z-index,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// RelationshipStyles1TextTransform A transformation to apply to the label text
type RelationshipStyles1TextTransform string

// ResultsPage defines model for resultsPage.
type ResultsPage struct {
	Page       int    `json:"page,omitempty"`
	PageSize   int    `json:"page_size,omitempty"`
	ResultType string `json:"resultType,omitempty"`
	TotalCount int    `json:"total_count,omitempty"`
}

// RoleNames defines model for roleNames.
type RoleNames = []string

// SemverString A valid semantic version string between 5 and 256 characters. The pattern allows for a major.minor.patch version followed by an optional pre-release tag like '-alpha' or '-beta.2' and an optional build metadata tag like '+build.1.
type SemverString = string

// Shape The shape of the node's body. Note that each shape fits within the specified width and height, and so you may have to adjust width and height if you desire an equilateral shape (i.e. width !== height for several equilateral shapes)
type Shape string

// Status defines model for status.
type Status = string

// Styles Common styles for all entities
type Styles struct {
	// Animation The animation to apply to the element. example ripple,bounce,etc
	Animation *map[string]interface{} `json:"animation,omitempty"`

	// Color The color of the element's label. Colours may be specified by name (e.g. red), hex (e.g.
	Color *string `json:"color,omitempty"`

	// FontFamily A comma-separated list of font names to use on the label text.
	FontFamily *string `json:"font-family,omitempty"`

	// FontSize The size of the label text.
	FontSize *string `json:"font-size,omitempty"`

	// FontStyle A CSS font style to be applied to the label text.
	FontStyle *string `json:"font-style,omitempty"`

	// FontWeight A CSS font weight to be applied to the label text.
	FontWeight *string `json:"font-weight,omitempty"`

	// Label The text to display for an element's label. Can give a path, e.g. data(id) will label with the elements id
	Label *string `json:"label,omitempty"`

	// Opacity The opacity of the element, ranging from 0 to 1. Note that the opacity of a compound node parent affects the effective opacity of its children.
	Opacity *float32 `json:"opacity,omitempty"`

	// PrimaryColor Primary color of the component used for UI representation.
	PrimaryColor string `json:"primaryColor"`

	// SecondaryColor Secondary color of the entity used for UI representation.
	SecondaryColor *string `json:"secondaryColor,omitempty"`

	// SvgColor Colored SVG of the entity used for UI representation on light background.
	SvgColor string `json:"svgColor"`

	// SvgComplete Complete SVG of the entity used for UI representation, often inclusive of background.
	SvgComplete string `json:"svgComplete"`

	// SvgWhite White SVG of the entity used for UI representation on dark background.
	SvgWhite string `json:"svgWhite"`

	// TextOpacity The opacity of the label text, including its outline.
	TextOpacity *float32 `json:"text-opacity,omitempty"`

	// TextTransform A transformation to apply to the label text
	TextTransform *StylesTextTransform `json:"text-transform,omitempty"`

	// ZIndex An integer value that affects the relative draw order of elements. In general, an element with a higher z-index will be drawn on top of an element with a lower z-index. Note that edges are under nodes despite z-index.
	ZIndex               *int                   `json:"z-index,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// StylesTextTransform A transformation to apply to the label text
type StylesTextTransform string

// SystemID defines model for system_id.
type SystemID = uuid.UUID

// TeamId defines model for team_id.
type TeamId = uuid.UUID

// UpdatedAt Timestamp when the resource was updated.
type UpdatedAt = time.Time

// UserId user's email or username
type UserId = string

// UserIds defines model for user_ids.
type UserIds = []uuid.UUID

// UserID defines model for user_uuid.
type UserID = uuid.UUID

// Username defines model for username.
type Username = string

// Uuid A Universally Unique Identifier used to uniquely identify entities in Meshery. The UUID core definition is used across different schemas.
type Uuid = uuid.UUID

// VersionString API version of the object
type VersionString = string

// ViewId defines model for view_id.
type ViewId = uuid.UUID

// WorkspaceId defines model for workspace_id.
type WorkspaceId = uuid.UUID

// ActorType defines model for actorType.
type ActorType = string

// All defines model for all.
type All = bool

// Class defines model for class.
type Class = string

// ContentTechnology defines model for contentTechnology.
type ContentTechnology = string

// ContentType defines model for contentType.
type ContentType = string

// Cumulative defines model for cumulative.
type Cumulative = string

// Filter defines model for filter.
type Filter = string

// IsOAuth defines model for isOAuth.
type IsOAuth = string

// MesheryVersion defines model for mesheryVersion.
type MesheryVersion = string

// Metrics defines model for metrics.
type Metrics = string

// Name defines model for name.
type Name = string

// Namespace defines model for namespace.
type Namespace = string

// Order defines model for order.
type Order = string

// Os defines model for os.
type Os = string

// Page defines model for page.
type Page = string

// Pagesize defines model for pagesize.
type Pagesize = string

// PagesizeWithAll defines model for pagesizeWithAll.
type PagesizeWithAll = string

// Playground defines model for playground.
type Playground = string

// Populate defines model for populate.
type Populate = string

// Purpose defines model for purpose.
type Purpose = string

// ResourceType defines model for resourceType.
type ResourceType = string

// Search defines model for search.
type Search = string

// Type defines model for type.
type Type = string

// Userid defines model for userid.
type Userid = string

// Visibility defines model for visibility.
type Visibility = string

// Getter for additional properties for ComponentStyles. Returns the specified
// element and whether it was found
func (a ComponentStyles) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ComponentStyles
func (a *ComponentStyles) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ComponentStyles to handle AdditionalProperties
func (a *ComponentStyles) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["active-bg-color"]; found {
		err = json.Unmarshal(raw, &a.ActiveBgColor)
		if err != nil {
			return fmt.Errorf("error reading 'active-bg-color': %w", err)
		}
		delete(object, "active-bg-color")
	}

	if raw, found := object["active-bg-opacity"]; found {
		err = json.Unmarshal(raw, &a.ActiveBgOpacity)
		if err != nil {
			return fmt.Errorf("error reading 'active-bg-opacity': %w", err)
		}
		delete(object, "active-bg-opacity")
	}

	if raw, found := object["active-bg-size"]; found {
		err = json.Unmarshal(raw, &a.ActiveBgSize)
		if err != nil {
			return fmt.Errorf("error reading 'active-bg-size': %w", err)
		}
		delete(object, "active-bg-size")
	}

	if raw, found := object["animation"]; found {
		err = json.Unmarshal(raw, &a.Animation)
		if err != nil {
			return fmt.Errorf("error reading 'animation': %w", err)
		}
		delete(object, "animation")
	}

	if raw, found := object["background-blacken"]; found {
		err = json.Unmarshal(raw, &a.BackgroundBlacken)
		if err != nil {
			return fmt.Errorf("error reading 'background-blacken': %w", err)
		}
		delete(object, "background-blacken")
	}

	if raw, found := object["background-clip"]; found {
		err = json.Unmarshal(raw, &a.BackgroundClip)
		if err != nil {
			return fmt.Errorf("error reading 'background-clip': %w", err)
		}
		delete(object, "background-clip")
	}

	if raw, found := object["background-color"]; found {
		err = json.Unmarshal(raw, &a.BackgroundColor)
		if err != nil {
			return fmt.Errorf("error reading 'background-color': %w", err)
		}
		delete(object, "background-color")
	}

	if raw, found := object["background-fit"]; found {
		err = json.Unmarshal(raw, &a.BackgroundFit)
		if err != nil {
			return fmt.Errorf("error reading 'background-fit': %w", err)
		}
		delete(object, "background-fit")
	}

	if raw, found := object["background-height-relative-to"]; found {
		err = json.Unmarshal(raw, &a.BackgroundHeightRelativeTo)
		if err != nil {
			return fmt.Errorf("error reading 'background-height-relative-to': %w", err)
		}
		delete(object, "background-height-relative-to")
	}

	if raw, found := object["background-image"]; found {
		err = json.Unmarshal(raw, &a.BackgroundImage)
		if err != nil {
			return fmt.Errorf("error reading 'background-image': %w", err)
		}
		delete(object, "background-image")
	}

	if raw, found := object["background-offset-x"]; found {
		err = json.Unmarshal(raw, &a.BackgroundOffsetX)
		if err != nil {
			return fmt.Errorf("error reading 'background-offset-x': %w", err)
		}
		delete(object, "background-offset-x")
	}

	if raw, found := object["background-offset-y"]; found {
		err = json.Unmarshal(raw, &a.BackgroundOffsetY)
		if err != nil {
			return fmt.Errorf("error reading 'background-offset-y': %w", err)
		}
		delete(object, "background-offset-y")
	}

	if raw, found := object["background-opacity"]; found {
		err = json.Unmarshal(raw, &a.BackgroundOpacity)
		if err != nil {
			return fmt.Errorf("error reading 'background-opacity': %w", err)
		}
		delete(object, "background-opacity")
	}

	if raw, found := object["background-position-x"]; found {
		err = json.Unmarshal(raw, &a.BackgroundPositionX)
		if err != nil {
			return fmt.Errorf("error reading 'background-position-x': %w", err)
		}
		delete(object, "background-position-x")
	}

	if raw, found := object["background-position-y"]; found {
		err = json.Unmarshal(raw, &a.BackgroundPositionY)
		if err != nil {
			return fmt.Errorf("error reading 'background-position-y': %w", err)
		}
		delete(object, "background-position-y")
	}

	if raw, found := object["background-width-relative-to"]; found {
		err = json.Unmarshal(raw, &a.BackgroundWidthRelativeTo)
		if err != nil {
			return fmt.Errorf("error reading 'background-width-relative-to': %w", err)
		}
		delete(object, "background-width-relative-to")
	}

	if raw, found := object["body-text"]; found {
		err = json.Unmarshal(raw, &a.BodyText)
		if err != nil {
			return fmt.Errorf("error reading 'body-text': %w", err)
		}
		delete(object, "body-text")
	}

	if raw, found := object["body-text-background-color"]; found {
		err = json.Unmarshal(raw, &a.BodyTextBackgroundColor)
		if err != nil {
			return fmt.Errorf("error reading 'body-text-background-color': %w", err)
		}
		delete(object, "body-text-background-color")
	}

	if raw, found := object["body-text-color"]; found {
		err = json.Unmarshal(raw, &a.BodyTextColor)
		if err != nil {
			return fmt.Errorf("error reading 'body-text-color': %w", err)
		}
		delete(object, "body-text-color")
	}

	if raw, found := object["body-text-decoration"]; found {
		err = json.Unmarshal(raw, &a.BodyTextDecoration)
		if err != nil {
			return fmt.Errorf("error reading 'body-text-decoration': %w", err)
		}
		delete(object, "body-text-decoration")
	}

	if raw, found := object["body-text-font-size"]; found {
		err = json.Unmarshal(raw, &a.BodyTextFontSize)
		if err != nil {
			return fmt.Errorf("error reading 'body-text-font-size': %w", err)
		}
		delete(object, "body-text-font-size")
	}

	if raw, found := object["body-text-font-weight"]; found {
		err = json.Unmarshal(raw, &a.BodyTextFontWeight)
		if err != nil {
			return fmt.Errorf("error reading 'body-text-font-weight': %w", err)
		}
		delete(object, "body-text-font-weight")
	}

	if raw, found := object["body-text-horizontal-align"]; found {
		err = json.Unmarshal(raw, &a.BodyTextHorizontalAlign)
		if err != nil {
			return fmt.Errorf("error reading 'body-text-horizontal-align': %w", err)
		}
		delete(object, "body-text-horizontal-align")
	}

	if raw, found := object["body-text-max-width"]; found {
		err = json.Unmarshal(raw, &a.BodyTextMaxWidth)
		if err != nil {
			return fmt.Errorf("error reading 'body-text-max-width': %w", err)
		}
		delete(object, "body-text-max-width")
	}

	if raw, found := object["body-text-opacity"]; found {
		err = json.Unmarshal(raw, &a.BodyTextOpacity)
		if err != nil {
			return fmt.Errorf("error reading 'body-text-opacity': %w", err)
		}
		delete(object, "body-text-opacity")
	}

	if raw, found := object["body-text-vertical-align"]; found {
		err = json.Unmarshal(raw, &a.BodyTextVerticalAlign)
		if err != nil {
			return fmt.Errorf("error reading 'body-text-vertical-align': %w", err)
		}
		delete(object, "body-text-vertical-align")
	}

	if raw, found := object["body-text-wrap"]; found {
		err = json.Unmarshal(raw, &a.BodyTextWrap)
		if err != nil {
			return fmt.Errorf("error reading 'body-text-wrap': %w", err)
		}
		delete(object, "body-text-wrap")
	}

	if raw, found := object["border-color"]; found {
		err = json.Unmarshal(raw, &a.BorderColor)
		if err != nil {
			return fmt.Errorf("error reading 'border-color': %w", err)
		}
		delete(object, "border-color")
	}

	if raw, found := object["border-opacity"]; found {
		err = json.Unmarshal(raw, &a.BorderOpacity)
		if err != nil {
			return fmt.Errorf("error reading 'border-opacity': %w", err)
		}
		delete(object, "border-opacity")
	}

	if raw, found := object["border-style"]; found {
		err = json.Unmarshal(raw, &a.BorderStyle)
		if err != nil {
			return fmt.Errorf("error reading 'border-style': %w", err)
		}
		delete(object, "border-style")
	}

	if raw, found := object["border-width"]; found {
		err = json.Unmarshal(raw, &a.BorderWidth)
		if err != nil {
			return fmt.Errorf("error reading 'border-width': %w", err)
		}
		delete(object, "border-width")
	}

	if raw, found := object["color"]; found {
		err = json.Unmarshal(raw, &a.Color)
		if err != nil {
			return fmt.Errorf("error reading 'color': %w", err)
		}
		delete(object, "color")
	}

	if raw, found := object["font-family"]; found {
		err = json.Unmarshal(raw, &a.FontFamily)
		if err != nil {
			return fmt.Errorf("error reading 'font-family': %w", err)
		}
		delete(object, "font-family")
	}

	if raw, found := object["font-size"]; found {
		err = json.Unmarshal(raw, &a.FontSize)
		if err != nil {
			return fmt.Errorf("error reading 'font-size': %w", err)
		}
		delete(object, "font-size")
	}

	if raw, found := object["font-style"]; found {
		err = json.Unmarshal(raw, &a.FontStyle)
		if err != nil {
			return fmt.Errorf("error reading 'font-style': %w", err)
		}
		delete(object, "font-style")
	}

	if raw, found := object["font-weight"]; found {
		err = json.Unmarshal(raw, &a.FontWeight)
		if err != nil {
			return fmt.Errorf("error reading 'font-weight': %w", err)
		}
		delete(object, "font-weight")
	}

	if raw, found := object["ghost"]; found {
		err = json.Unmarshal(raw, &a.Ghost)
		if err != nil {
			return fmt.Errorf("error reading 'ghost': %w", err)
		}
		delete(object, "ghost")
	}

	if raw, found := object["height"]; found {
		err = json.Unmarshal(raw, &a.Height)
		if err != nil {
			return fmt.Errorf("error reading 'height': %w", err)
		}
		delete(object, "height")
	}

	if raw, found := object["label"]; found {
		err = json.Unmarshal(raw, &a.Label)
		if err != nil {
			return fmt.Errorf("error reading 'label': %w", err)
		}
		delete(object, "label")
	}

	if raw, found := object["menu-background-color"]; found {
		err = json.Unmarshal(raw, &a.MenuBackgroundColor)
		if err != nil {
			return fmt.Errorf("error reading 'menu-background-color': %w", err)
		}
		delete(object, "menu-background-color")
	}

	if raw, found := object["menu-background-opacity"]; found {
		err = json.Unmarshal(raw, &a.MenuBackgroundOpacity)
		if err != nil {
			return fmt.Errorf("error reading 'menu-background-opacity': %w", err)
		}
		delete(object, "menu-background-opacity")
	}

	if raw, found := object["menu-forground-color"]; found {
		err = json.Unmarshal(raw, &a.MenuForgroundColor)
		if err != nil {
			return fmt.Errorf("error reading 'menu-forground-color': %w", err)
		}
		delete(object, "menu-forground-color")
	}

	if raw, found := object["opacity"]; found {
		err = json.Unmarshal(raw, &a.Opacity)
		if err != nil {
			return fmt.Errorf("error reading 'opacity': %w", err)
		}
		delete(object, "opacity")
	}

	if raw, found := object["outside-texture-bg-color"]; found {
		err = json.Unmarshal(raw, &a.OutsideTextureBgColor)
		if err != nil {
			return fmt.Errorf("error reading 'outside-texture-bg-color': %w", err)
		}
		delete(object, "outside-texture-bg-color")
	}

	if raw, found := object["outside-texture-bg-opacity"]; found {
		err = json.Unmarshal(raw, &a.OutsideTextureBgOpacity)
		if err != nil {
			return fmt.Errorf("error reading 'outside-texture-bg-opacity': %w", err)
		}
		delete(object, "outside-texture-bg-opacity")
	}

	if raw, found := object["padding"]; found {
		err = json.Unmarshal(raw, &a.Padding)
		if err != nil {
			return fmt.Errorf("error reading 'padding': %w", err)
		}
		delete(object, "padding")
	}

	if raw, found := object["position"]; found {
		err = json.Unmarshal(raw, &a.Position)
		if err != nil {
			return fmt.Errorf("error reading 'position': %w", err)
		}
		delete(object, "position")
	}

	if raw, found := object["primaryColor"]; found {
		err = json.Unmarshal(raw, &a.PrimaryColor)
		if err != nil {
			return fmt.Errorf("error reading 'primaryColor': %w", err)
		}
		delete(object, "primaryColor")
	}

	if raw, found := object["secondaryColor"]; found {
		err = json.Unmarshal(raw, &a.SecondaryColor)
		if err != nil {
			return fmt.Errorf("error reading 'secondaryColor': %w", err)
		}
		delete(object, "secondaryColor")
	}

	if raw, found := object["selection-box-border-width"]; found {
		err = json.Unmarshal(raw, &a.SelectionBoxBorderWidth)
		if err != nil {
			return fmt.Errorf("error reading 'selection-box-border-width': %w", err)
		}
		delete(object, "selection-box-border-width")
	}

	if raw, found := object["selection-box-color"]; found {
		err = json.Unmarshal(raw, &a.SelectionBoxColor)
		if err != nil {
			return fmt.Errorf("error reading 'selection-box-color': %w", err)
		}
		delete(object, "selection-box-color")
	}

	if raw, found := object["selection-box-opacity"]; found {
		err = json.Unmarshal(raw, &a.SelectionBoxOpacity)
		if err != nil {
			return fmt.Errorf("error reading 'selection-box-opacity': %w", err)
		}
		delete(object, "selection-box-opacity")
	}

	if raw, found := object["shape"]; found {
		err = json.Unmarshal(raw, &a.Shape)
		if err != nil {
			return fmt.Errorf("error reading 'shape': %w", err)
		}
		delete(object, "shape")
	}

	if raw, found := object["shape-polygon-points"]; found {
		err = json.Unmarshal(raw, &a.ShapePolygonPoints)
		if err != nil {
			return fmt.Errorf("error reading 'shape-polygon-points': %w", err)
		}
		delete(object, "shape-polygon-points")
	}

	if raw, found := object["svgColor"]; found {
		err = json.Unmarshal(raw, &a.SvgColor)
		if err != nil {
			return fmt.Errorf("error reading 'svgColor': %w", err)
		}
		delete(object, "svgColor")
	}

	if raw, found := object["svgComplete"]; found {
		err = json.Unmarshal(raw, &a.SvgComplete)
		if err != nil {
			return fmt.Errorf("error reading 'svgComplete': %w", err)
		}
		delete(object, "svgComplete")
	}

	if raw, found := object["svgWhite"]; found {
		err = json.Unmarshal(raw, &a.SvgWhite)
		if err != nil {
			return fmt.Errorf("error reading 'svgWhite': %w", err)
		}
		delete(object, "svgWhite")
	}

	if raw, found := object["text-halign"]; found {
		err = json.Unmarshal(raw, &a.TextHalign)
		if err != nil {
			return fmt.Errorf("error reading 'text-halign': %w", err)
		}
		delete(object, "text-halign")
	}

	if raw, found := object["text-opacity"]; found {
		err = json.Unmarshal(raw, &a.TextOpacity)
		if err != nil {
			return fmt.Errorf("error reading 'text-opacity': %w", err)
		}
		delete(object, "text-opacity")
	}

	if raw, found := object["text-transform"]; found {
		err = json.Unmarshal(raw, &a.TextTransform)
		if err != nil {
			return fmt.Errorf("error reading 'text-transform': %w", err)
		}
		delete(object, "text-transform")
	}

	if raw, found := object["text-valign"]; found {
		err = json.Unmarshal(raw, &a.TextValign)
		if err != nil {
			return fmt.Errorf("error reading 'text-valign': %w", err)
		}
		delete(object, "text-valign")
	}

	if raw, found := object["width"]; found {
		err = json.Unmarshal(raw, &a.Width)
		if err != nil {
			return fmt.Errorf("error reading 'width': %w", err)
		}
		delete(object, "width")
	}

	if raw, found := object["z-index"]; found {
		err = json.Unmarshal(raw, &a.ZIndex)
		if err != nil {
			return fmt.Errorf("error reading 'z-index': %w", err)
		}
		delete(object, "z-index")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ComponentStyles to handle AdditionalProperties
func (a ComponentStyles) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.ActiveBgColor != nil {
		object["active-bg-color"], err = json.Marshal(a.ActiveBgColor)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'active-bg-color': %w", err)
		}
	}

	if a.ActiveBgOpacity != nil {
		object["active-bg-opacity"], err = json.Marshal(a.ActiveBgOpacity)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'active-bg-opacity': %w", err)
		}
	}

	if a.ActiveBgSize != nil {
		object["active-bg-size"], err = json.Marshal(a.ActiveBgSize)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'active-bg-size': %w", err)
		}
	}

	if a.Animation != nil {
		object["animation"], err = json.Marshal(a.Animation)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'animation': %w", err)
		}
	}

	if a.BackgroundBlacken != nil {
		object["background-blacken"], err = json.Marshal(a.BackgroundBlacken)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'background-blacken': %w", err)
		}
	}

	if a.BackgroundClip != nil {
		object["background-clip"], err = json.Marshal(a.BackgroundClip)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'background-clip': %w", err)
		}
	}

	if a.BackgroundColor != nil {
		object["background-color"], err = json.Marshal(a.BackgroundColor)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'background-color': %w", err)
		}
	}

	if a.BackgroundFit != nil {
		object["background-fit"], err = json.Marshal(a.BackgroundFit)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'background-fit': %w", err)
		}
	}

	if a.BackgroundHeightRelativeTo != nil {
		object["background-height-relative-to"], err = json.Marshal(a.BackgroundHeightRelativeTo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'background-height-relative-to': %w", err)
		}
	}

	if a.BackgroundImage != nil {
		object["background-image"], err = json.Marshal(a.BackgroundImage)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'background-image': %w", err)
		}
	}

	if a.BackgroundOffsetX != nil {
		object["background-offset-x"], err = json.Marshal(a.BackgroundOffsetX)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'background-offset-x': %w", err)
		}
	}

	if a.BackgroundOffsetY != nil {
		object["background-offset-y"], err = json.Marshal(a.BackgroundOffsetY)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'background-offset-y': %w", err)
		}
	}

	if a.BackgroundOpacity != nil {
		object["background-opacity"], err = json.Marshal(a.BackgroundOpacity)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'background-opacity': %w", err)
		}
	}

	if a.BackgroundPositionX != nil {
		object["background-position-x"], err = json.Marshal(a.BackgroundPositionX)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'background-position-x': %w", err)
		}
	}

	if a.BackgroundPositionY != nil {
		object["background-position-y"], err = json.Marshal(a.BackgroundPositionY)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'background-position-y': %w", err)
		}
	}

	if a.BackgroundWidthRelativeTo != nil {
		object["background-width-relative-to"], err = json.Marshal(a.BackgroundWidthRelativeTo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'background-width-relative-to': %w", err)
		}
	}

	if a.BodyText != nil {
		object["body-text"], err = json.Marshal(a.BodyText)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'body-text': %w", err)
		}
	}

	if a.BodyTextBackgroundColor != nil {
		object["body-text-background-color"], err = json.Marshal(a.BodyTextBackgroundColor)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'body-text-background-color': %w", err)
		}
	}

	if a.BodyTextColor != nil {
		object["body-text-color"], err = json.Marshal(a.BodyTextColor)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'body-text-color': %w", err)
		}
	}

	if a.BodyTextDecoration != nil {
		object["body-text-decoration"], err = json.Marshal(a.BodyTextDecoration)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'body-text-decoration': %w", err)
		}
	}

	if a.BodyTextFontSize != nil {
		object["body-text-font-size"], err = json.Marshal(a.BodyTextFontSize)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'body-text-font-size': %w", err)
		}
	}

	if a.BodyTextFontWeight != nil {
		object["body-text-font-weight"], err = json.Marshal(a.BodyTextFontWeight)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'body-text-font-weight': %w", err)
		}
	}

	if a.BodyTextHorizontalAlign != nil {
		object["body-text-horizontal-align"], err = json.Marshal(a.BodyTextHorizontalAlign)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'body-text-horizontal-align': %w", err)
		}
	}

	if a.BodyTextMaxWidth != nil {
		object["body-text-max-width"], err = json.Marshal(a.BodyTextMaxWidth)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'body-text-max-width': %w", err)
		}
	}

	if a.BodyTextOpacity != nil {
		object["body-text-opacity"], err = json.Marshal(a.BodyTextOpacity)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'body-text-opacity': %w", err)
		}
	}

	if a.BodyTextVerticalAlign != nil {
		object["body-text-vertical-align"], err = json.Marshal(a.BodyTextVerticalAlign)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'body-text-vertical-align': %w", err)
		}
	}

	if a.BodyTextWrap != nil {
		object["body-text-wrap"], err = json.Marshal(a.BodyTextWrap)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'body-text-wrap': %w", err)
		}
	}

	if a.BorderColor != nil {
		object["border-color"], err = json.Marshal(a.BorderColor)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'border-color': %w", err)
		}
	}

	if a.BorderOpacity != nil {
		object["border-opacity"], err = json.Marshal(a.BorderOpacity)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'border-opacity': %w", err)
		}
	}

	if a.BorderStyle != nil {
		object["border-style"], err = json.Marshal(a.BorderStyle)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'border-style': %w", err)
		}
	}

	if a.BorderWidth != nil {
		object["border-width"], err = json.Marshal(a.BorderWidth)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'border-width': %w", err)
		}
	}

	if a.Color != nil {
		object["color"], err = json.Marshal(a.Color)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'color': %w", err)
		}
	}

	if a.FontFamily != nil {
		object["font-family"], err = json.Marshal(a.FontFamily)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'font-family': %w", err)
		}
	}

	if a.FontSize != nil {
		object["font-size"], err = json.Marshal(a.FontSize)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'font-size': %w", err)
		}
	}

	if a.FontStyle != nil {
		object["font-style"], err = json.Marshal(a.FontStyle)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'font-style': %w", err)
		}
	}

	if a.FontWeight != nil {
		object["font-weight"], err = json.Marshal(a.FontWeight)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'font-weight': %w", err)
		}
	}

	if a.Ghost != nil {
		object["ghost"], err = json.Marshal(a.Ghost)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ghost': %w", err)
		}
	}

	if a.Height != nil {
		object["height"], err = json.Marshal(a.Height)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'height': %w", err)
		}
	}

	if a.Label != nil {
		object["label"], err = json.Marshal(a.Label)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'label': %w", err)
		}
	}

	if a.MenuBackgroundColor != nil {
		object["menu-background-color"], err = json.Marshal(a.MenuBackgroundColor)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'menu-background-color': %w", err)
		}
	}

	if a.MenuBackgroundOpacity != nil {
		object["menu-background-opacity"], err = json.Marshal(a.MenuBackgroundOpacity)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'menu-background-opacity': %w", err)
		}
	}

	if a.MenuForgroundColor != nil {
		object["menu-forground-color"], err = json.Marshal(a.MenuForgroundColor)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'menu-forground-color': %w", err)
		}
	}

	if a.Opacity != nil {
		object["opacity"], err = json.Marshal(a.Opacity)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'opacity': %w", err)
		}
	}

	if a.OutsideTextureBgColor != nil {
		object["outside-texture-bg-color"], err = json.Marshal(a.OutsideTextureBgColor)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'outside-texture-bg-color': %w", err)
		}
	}

	if a.OutsideTextureBgOpacity != nil {
		object["outside-texture-bg-opacity"], err = json.Marshal(a.OutsideTextureBgOpacity)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'outside-texture-bg-opacity': %w", err)
		}
	}

	if a.Padding != nil {
		object["padding"], err = json.Marshal(a.Padding)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'padding': %w", err)
		}
	}

	if a.Position != nil {
		object["position"], err = json.Marshal(a.Position)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'position': %w", err)
		}
	}

	object["primaryColor"], err = json.Marshal(a.PrimaryColor)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'primaryColor': %w", err)
	}

	if a.SecondaryColor != nil {
		object["secondaryColor"], err = json.Marshal(a.SecondaryColor)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'secondaryColor': %w", err)
		}
	}

	if a.SelectionBoxBorderWidth != nil {
		object["selection-box-border-width"], err = json.Marshal(a.SelectionBoxBorderWidth)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'selection-box-border-width': %w", err)
		}
	}

	if a.SelectionBoxColor != nil {
		object["selection-box-color"], err = json.Marshal(a.SelectionBoxColor)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'selection-box-color': %w", err)
		}
	}

	if a.SelectionBoxOpacity != nil {
		object["selection-box-opacity"], err = json.Marshal(a.SelectionBoxOpacity)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'selection-box-opacity': %w", err)
		}
	}

	if a.Shape != nil {
		object["shape"], err = json.Marshal(a.Shape)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'shape': %w", err)
		}
	}

	if a.ShapePolygonPoints != nil {
		object["shape-polygon-points"], err = json.Marshal(a.ShapePolygonPoints)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'shape-polygon-points': %w", err)
		}
	}

	object["svgColor"], err = json.Marshal(a.SvgColor)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'svgColor': %w", err)
	}

	object["svgComplete"], err = json.Marshal(a.SvgComplete)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'svgComplete': %w", err)
	}

	object["svgWhite"], err = json.Marshal(a.SvgWhite)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'svgWhite': %w", err)
	}

	if a.TextHalign != nil {
		object["text-halign"], err = json.Marshal(a.TextHalign)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'text-halign': %w", err)
		}
	}

	if a.TextOpacity != nil {
		object["text-opacity"], err = json.Marshal(a.TextOpacity)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'text-opacity': %w", err)
		}
	}

	if a.TextTransform != nil {
		object["text-transform"], err = json.Marshal(a.TextTransform)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'text-transform': %w", err)
		}
	}

	if a.TextValign != nil {
		object["text-valign"], err = json.Marshal(a.TextValign)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'text-valign': %w", err)
		}
	}

	if a.Width != nil {
		object["width"], err = json.Marshal(a.Width)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'width': %w", err)
		}
	}

	if a.ZIndex != nil {
		object["z-index"], err = json.Marshal(a.ZIndex)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'z-index': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for EdgeStyles. Returns the specified
// element and whether it was found
func (a EdgeStyles) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for EdgeStyles
func (a *EdgeStyles) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for EdgeStyles to handle AdditionalProperties
func (a *EdgeStyles) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["animation"]; found {
		err = json.Unmarshal(raw, &a.Animation)
		if err != nil {
			return fmt.Errorf("error reading 'animation': %w", err)
		}
		delete(object, "animation")
	}

	if raw, found := object["arrow-scale"]; found {
		err = json.Unmarshal(raw, &a.ArrowScale)
		if err != nil {
			return fmt.Errorf("error reading 'arrow-scale': %w", err)
		}
		delete(object, "arrow-scale")
	}

	if raw, found := object["color"]; found {
		err = json.Unmarshal(raw, &a.Color)
		if err != nil {
			return fmt.Errorf("error reading 'color': %w", err)
		}
		delete(object, "color")
	}

	if raw, found := object["curve-style"]; found {
		err = json.Unmarshal(raw, &a.CurveStyle)
		if err != nil {
			return fmt.Errorf("error reading 'curve-style': %w", err)
		}
		delete(object, "curve-style")
	}

	if raw, found := object["edge-animation"]; found {
		err = json.Unmarshal(raw, &a.EdgeAnimation)
		if err != nil {
			return fmt.Errorf("error reading 'edge-animation': %w", err)
		}
		delete(object, "edge-animation")
	}

	if raw, found := object["font-family"]; found {
		err = json.Unmarshal(raw, &a.FontFamily)
		if err != nil {
			return fmt.Errorf("error reading 'font-family': %w", err)
		}
		delete(object, "font-family")
	}

	if raw, found := object["font-size"]; found {
		err = json.Unmarshal(raw, &a.FontSize)
		if err != nil {
			return fmt.Errorf("error reading 'font-size': %w", err)
		}
		delete(object, "font-size")
	}

	if raw, found := object["font-style"]; found {
		err = json.Unmarshal(raw, &a.FontStyle)
		if err != nil {
			return fmt.Errorf("error reading 'font-style': %w", err)
		}
		delete(object, "font-style")
	}

	if raw, found := object["font-weight"]; found {
		err = json.Unmarshal(raw, &a.FontWeight)
		if err != nil {
			return fmt.Errorf("error reading 'font-weight': %w", err)
		}
		delete(object, "font-weight")
	}

	if raw, found := object["label"]; found {
		err = json.Unmarshal(raw, &a.Label)
		if err != nil {
			return fmt.Errorf("error reading 'label': %w", err)
		}
		delete(object, "label")
	}

	if raw, found := object["line-cap"]; found {
		err = json.Unmarshal(raw, &a.LineCap)
		if err != nil {
			return fmt.Errorf("error reading 'line-cap': %w", err)
		}
		delete(object, "line-cap")
	}

	if raw, found := object["line-color"]; found {
		err = json.Unmarshal(raw, &a.LineColor)
		if err != nil {
			return fmt.Errorf("error reading 'line-color': %w", err)
		}
		delete(object, "line-color")
	}

	if raw, found := object["line-opacity"]; found {
		err = json.Unmarshal(raw, &a.LineOpacity)
		if err != nil {
			return fmt.Errorf("error reading 'line-opacity': %w", err)
		}
		delete(object, "line-opacity")
	}

	if raw, found := object["line-style"]; found {
		err = json.Unmarshal(raw, &a.LineStyle)
		if err != nil {
			return fmt.Errorf("error reading 'line-style': %w", err)
		}
		delete(object, "line-style")
	}

	if raw, found := object["mid-target-arrow-color"]; found {
		err = json.Unmarshal(raw, &a.MidTargetArrowColor)
		if err != nil {
			return fmt.Errorf("error reading 'mid-target-arrow-color': %w", err)
		}
		delete(object, "mid-target-arrow-color")
	}

	if raw, found := object["mid-target-arrow-fill"]; found {
		err = json.Unmarshal(raw, &a.MidTargetArrowFill)
		if err != nil {
			return fmt.Errorf("error reading 'mid-target-arrow-fill': %w", err)
		}
		delete(object, "mid-target-arrow-fill")
	}

	if raw, found := object["mid-target-arrow-shape"]; found {
		err = json.Unmarshal(raw, &a.MidTargetArrowShape)
		if err != nil {
			return fmt.Errorf("error reading 'mid-target-arrow-shape': %w", err)
		}
		delete(object, "mid-target-arrow-shape")
	}

	if raw, found := object["opacity"]; found {
		err = json.Unmarshal(raw, &a.Opacity)
		if err != nil {
			return fmt.Errorf("error reading 'opacity': %w", err)
		}
		delete(object, "opacity")
	}

	if raw, found := object["primaryColor"]; found {
		err = json.Unmarshal(raw, &a.PrimaryColor)
		if err != nil {
			return fmt.Errorf("error reading 'primaryColor': %w", err)
		}
		delete(object, "primaryColor")
	}

	if raw, found := object["secondaryColor"]; found {
		err = json.Unmarshal(raw, &a.SecondaryColor)
		if err != nil {
			return fmt.Errorf("error reading 'secondaryColor': %w", err)
		}
		delete(object, "secondaryColor")
	}

	if raw, found := object["source-label"]; found {
		err = json.Unmarshal(raw, &a.SourceLabel)
		if err != nil {
			return fmt.Errorf("error reading 'source-label': %w", err)
		}
		delete(object, "source-label")
	}

	if raw, found := object["svgColor"]; found {
		err = json.Unmarshal(raw, &a.SvgColor)
		if err != nil {
			return fmt.Errorf("error reading 'svgColor': %w", err)
		}
		delete(object, "svgColor")
	}

	if raw, found := object["svgComplete"]; found {
		err = json.Unmarshal(raw, &a.SvgComplete)
		if err != nil {
			return fmt.Errorf("error reading 'svgComplete': %w", err)
		}
		delete(object, "svgComplete")
	}

	if raw, found := object["svgWhite"]; found {
		err = json.Unmarshal(raw, &a.SvgWhite)
		if err != nil {
			return fmt.Errorf("error reading 'svgWhite': %w", err)
		}
		delete(object, "svgWhite")
	}

	if raw, found := object["target-arrow-color"]; found {
		err = json.Unmarshal(raw, &a.TargetArrowColor)
		if err != nil {
			return fmt.Errorf("error reading 'target-arrow-color': %w", err)
		}
		delete(object, "target-arrow-color")
	}

	if raw, found := object["target-arrow-fill"]; found {
		err = json.Unmarshal(raw, &a.TargetArrowFill)
		if err != nil {
			return fmt.Errorf("error reading 'target-arrow-fill': %w", err)
		}
		delete(object, "target-arrow-fill")
	}

	if raw, found := object["target-arrow-shape"]; found {
		err = json.Unmarshal(raw, &a.TargetArrowShape)
		if err != nil {
			return fmt.Errorf("error reading 'target-arrow-shape': %w", err)
		}
		delete(object, "target-arrow-shape")
	}

	if raw, found := object["target-label"]; found {
		err = json.Unmarshal(raw, &a.TargetLabel)
		if err != nil {
			return fmt.Errorf("error reading 'target-label': %w", err)
		}
		delete(object, "target-label")
	}

	if raw, found := object["text-opacity"]; found {
		err = json.Unmarshal(raw, &a.TextOpacity)
		if err != nil {
			return fmt.Errorf("error reading 'text-opacity': %w", err)
		}
		delete(object, "text-opacity")
	}

	if raw, found := object["text-transform"]; found {
		err = json.Unmarshal(raw, &a.TextTransform)
		if err != nil {
			return fmt.Errorf("error reading 'text-transform': %w", err)
		}
		delete(object, "text-transform")
	}

	if raw, found := object["z-index"]; found {
		err = json.Unmarshal(raw, &a.ZIndex)
		if err != nil {
			return fmt.Errorf("error reading 'z-index': %w", err)
		}
		delete(object, "z-index")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for EdgeStyles to handle AdditionalProperties
func (a EdgeStyles) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Animation != nil {
		object["animation"], err = json.Marshal(a.Animation)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'animation': %w", err)
		}
	}

	if a.ArrowScale != nil {
		object["arrow-scale"], err = json.Marshal(a.ArrowScale)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'arrow-scale': %w", err)
		}
	}

	if a.Color != nil {
		object["color"], err = json.Marshal(a.Color)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'color': %w", err)
		}
	}

	if a.CurveStyle != nil {
		object["curve-style"], err = json.Marshal(a.CurveStyle)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'curve-style': %w", err)
		}
	}

	if a.EdgeAnimation != nil {
		object["edge-animation"], err = json.Marshal(a.EdgeAnimation)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'edge-animation': %w", err)
		}
	}

	if a.FontFamily != nil {
		object["font-family"], err = json.Marshal(a.FontFamily)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'font-family': %w", err)
		}
	}

	if a.FontSize != nil {
		object["font-size"], err = json.Marshal(a.FontSize)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'font-size': %w", err)
		}
	}

	if a.FontStyle != nil {
		object["font-style"], err = json.Marshal(a.FontStyle)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'font-style': %w", err)
		}
	}

	if a.FontWeight != nil {
		object["font-weight"], err = json.Marshal(a.FontWeight)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'font-weight': %w", err)
		}
	}

	if a.Label != nil {
		object["label"], err = json.Marshal(a.Label)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'label': %w", err)
		}
	}

	if a.LineCap != nil {
		object["line-cap"], err = json.Marshal(a.LineCap)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'line-cap': %w", err)
		}
	}

	if a.LineColor != nil {
		object["line-color"], err = json.Marshal(a.LineColor)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'line-color': %w", err)
		}
	}

	if a.LineOpacity != nil {
		object["line-opacity"], err = json.Marshal(a.LineOpacity)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'line-opacity': %w", err)
		}
	}

	if a.LineStyle != nil {
		object["line-style"], err = json.Marshal(a.LineStyle)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'line-style': %w", err)
		}
	}

	if a.MidTargetArrowColor != nil {
		object["mid-target-arrow-color"], err = json.Marshal(a.MidTargetArrowColor)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'mid-target-arrow-color': %w", err)
		}
	}

	if a.MidTargetArrowFill != nil {
		object["mid-target-arrow-fill"], err = json.Marshal(a.MidTargetArrowFill)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'mid-target-arrow-fill': %w", err)
		}
	}

	if a.MidTargetArrowShape != nil {
		object["mid-target-arrow-shape"], err = json.Marshal(a.MidTargetArrowShape)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'mid-target-arrow-shape': %w", err)
		}
	}

	if a.Opacity != nil {
		object["opacity"], err = json.Marshal(a.Opacity)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'opacity': %w", err)
		}
	}

	object["primaryColor"], err = json.Marshal(a.PrimaryColor)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'primaryColor': %w", err)
	}

	if a.SecondaryColor != nil {
		object["secondaryColor"], err = json.Marshal(a.SecondaryColor)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'secondaryColor': %w", err)
		}
	}

	if a.SourceLabel != nil {
		object["source-label"], err = json.Marshal(a.SourceLabel)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'source-label': %w", err)
		}
	}

	object["svgColor"], err = json.Marshal(a.SvgColor)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'svgColor': %w", err)
	}

	object["svgComplete"], err = json.Marshal(a.SvgComplete)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'svgComplete': %w", err)
	}

	object["svgWhite"], err = json.Marshal(a.SvgWhite)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'svgWhite': %w", err)
	}

	if a.TargetArrowColor != nil {
		object["target-arrow-color"], err = json.Marshal(a.TargetArrowColor)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'target-arrow-color': %w", err)
		}
	}

	if a.TargetArrowFill != nil {
		object["target-arrow-fill"], err = json.Marshal(a.TargetArrowFill)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'target-arrow-fill': %w", err)
		}
	}

	if a.TargetArrowShape != nil {
		object["target-arrow-shape"], err = json.Marshal(a.TargetArrowShape)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'target-arrow-shape': %w", err)
		}
	}

	if a.TargetLabel != nil {
		object["target-label"], err = json.Marshal(a.TargetLabel)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'target-label': %w", err)
		}
	}

	if a.TextOpacity != nil {
		object["text-opacity"], err = json.Marshal(a.TextOpacity)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'text-opacity': %w", err)
		}
	}

	if a.TextTransform != nil {
		object["text-transform"], err = json.Marshal(a.TextTransform)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'text-transform': %w", err)
		}
	}

	if a.ZIndex != nil {
		object["z-index"], err = json.Marshal(a.ZIndex)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'z-index': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for RelationshipStyles0. Returns the specified
// element and whether it was found
func (a RelationshipStyles0) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for RelationshipStyles0
func (a *RelationshipStyles0) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for RelationshipStyles0 to handle AdditionalProperties
func (a *RelationshipStyles0) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["animation"]; found {
		err = json.Unmarshal(raw, &a.Animation)
		if err != nil {
			return fmt.Errorf("error reading 'animation': %w", err)
		}
		delete(object, "animation")
	}

	if raw, found := object["arrow-scale"]; found {
		err = json.Unmarshal(raw, &a.ArrowScale)
		if err != nil {
			return fmt.Errorf("error reading 'arrow-scale': %w", err)
		}
		delete(object, "arrow-scale")
	}

	if raw, found := object["color"]; found {
		err = json.Unmarshal(raw, &a.Color)
		if err != nil {
			return fmt.Errorf("error reading 'color': %w", err)
		}
		delete(object, "color")
	}

	if raw, found := object["curve-style"]; found {
		err = json.Unmarshal(raw, &a.CurveStyle)
		if err != nil {
			return fmt.Errorf("error reading 'curve-style': %w", err)
		}
		delete(object, "curve-style")
	}

	if raw, found := object["edge-animation"]; found {
		err = json.Unmarshal(raw, &a.EdgeAnimation)
		if err != nil {
			return fmt.Errorf("error reading 'edge-animation': %w", err)
		}
		delete(object, "edge-animation")
	}

	if raw, found := object["font-family"]; found {
		err = json.Unmarshal(raw, &a.FontFamily)
		if err != nil {
			return fmt.Errorf("error reading 'font-family': %w", err)
		}
		delete(object, "font-family")
	}

	if raw, found := object["font-size"]; found {
		err = json.Unmarshal(raw, &a.FontSize)
		if err != nil {
			return fmt.Errorf("error reading 'font-size': %w", err)
		}
		delete(object, "font-size")
	}

	if raw, found := object["font-style"]; found {
		err = json.Unmarshal(raw, &a.FontStyle)
		if err != nil {
			return fmt.Errorf("error reading 'font-style': %w", err)
		}
		delete(object, "font-style")
	}

	if raw, found := object["font-weight"]; found {
		err = json.Unmarshal(raw, &a.FontWeight)
		if err != nil {
			return fmt.Errorf("error reading 'font-weight': %w", err)
		}
		delete(object, "font-weight")
	}

	if raw, found := object["label"]; found {
		err = json.Unmarshal(raw, &a.Label)
		if err != nil {
			return fmt.Errorf("error reading 'label': %w", err)
		}
		delete(object, "label")
	}

	if raw, found := object["line-cap"]; found {
		err = json.Unmarshal(raw, &a.LineCap)
		if err != nil {
			return fmt.Errorf("error reading 'line-cap': %w", err)
		}
		delete(object, "line-cap")
	}

	if raw, found := object["line-color"]; found {
		err = json.Unmarshal(raw, &a.LineColor)
		if err != nil {
			return fmt.Errorf("error reading 'line-color': %w", err)
		}
		delete(object, "line-color")
	}

	if raw, found := object["line-opacity"]; found {
		err = json.Unmarshal(raw, &a.LineOpacity)
		if err != nil {
			return fmt.Errorf("error reading 'line-opacity': %w", err)
		}
		delete(object, "line-opacity")
	}

	if raw, found := object["line-style"]; found {
		err = json.Unmarshal(raw, &a.LineStyle)
		if err != nil {
			return fmt.Errorf("error reading 'line-style': %w", err)
		}
		delete(object, "line-style")
	}

	if raw, found := object["mid-target-arrow-color"]; found {
		err = json.Unmarshal(raw, &a.MidTargetArrowColor)
		if err != nil {
			return fmt.Errorf("error reading 'mid-target-arrow-color': %w", err)
		}
		delete(object, "mid-target-arrow-color")
	}

	if raw, found := object["mid-target-arrow-fill"]; found {
		err = json.Unmarshal(raw, &a.MidTargetArrowFill)
		if err != nil {
			return fmt.Errorf("error reading 'mid-target-arrow-fill': %w", err)
		}
		delete(object, "mid-target-arrow-fill")
	}

	if raw, found := object["mid-target-arrow-shape"]; found {
		err = json.Unmarshal(raw, &a.MidTargetArrowShape)
		if err != nil {
			return fmt.Errorf("error reading 'mid-target-arrow-shape': %w", err)
		}
		delete(object, "mid-target-arrow-shape")
	}

	if raw, found := object["opacity"]; found {
		err = json.Unmarshal(raw, &a.Opacity)
		if err != nil {
			return fmt.Errorf("error reading 'opacity': %w", err)
		}
		delete(object, "opacity")
	}

	if raw, found := object["primaryColor"]; found {
		err = json.Unmarshal(raw, &a.PrimaryColor)
		if err != nil {
			return fmt.Errorf("error reading 'primaryColor': %w", err)
		}
		delete(object, "primaryColor")
	}

	if raw, found := object["secondaryColor"]; found {
		err = json.Unmarshal(raw, &a.SecondaryColor)
		if err != nil {
			return fmt.Errorf("error reading 'secondaryColor': %w", err)
		}
		delete(object, "secondaryColor")
	}

	if raw, found := object["source-label"]; found {
		err = json.Unmarshal(raw, &a.SourceLabel)
		if err != nil {
			return fmt.Errorf("error reading 'source-label': %w", err)
		}
		delete(object, "source-label")
	}

	if raw, found := object["svgColor"]; found {
		err = json.Unmarshal(raw, &a.SvgColor)
		if err != nil {
			return fmt.Errorf("error reading 'svgColor': %w", err)
		}
		delete(object, "svgColor")
	}

	if raw, found := object["svgComplete"]; found {
		err = json.Unmarshal(raw, &a.SvgComplete)
		if err != nil {
			return fmt.Errorf("error reading 'svgComplete': %w", err)
		}
		delete(object, "svgComplete")
	}

	if raw, found := object["svgWhite"]; found {
		err = json.Unmarshal(raw, &a.SvgWhite)
		if err != nil {
			return fmt.Errorf("error reading 'svgWhite': %w", err)
		}
		delete(object, "svgWhite")
	}

	if raw, found := object["target-arrow-color"]; found {
		err = json.Unmarshal(raw, &a.TargetArrowColor)
		if err != nil {
			return fmt.Errorf("error reading 'target-arrow-color': %w", err)
		}
		delete(object, "target-arrow-color")
	}

	if raw, found := object["target-arrow-fill"]; found {
		err = json.Unmarshal(raw, &a.TargetArrowFill)
		if err != nil {
			return fmt.Errorf("error reading 'target-arrow-fill': %w", err)
		}
		delete(object, "target-arrow-fill")
	}

	if raw, found := object["target-arrow-shape"]; found {
		err = json.Unmarshal(raw, &a.TargetArrowShape)
		if err != nil {
			return fmt.Errorf("error reading 'target-arrow-shape': %w", err)
		}
		delete(object, "target-arrow-shape")
	}

	if raw, found := object["target-label"]; found {
		err = json.Unmarshal(raw, &a.TargetLabel)
		if err != nil {
			return fmt.Errorf("error reading 'target-label': %w", err)
		}
		delete(object, "target-label")
	}

	if raw, found := object["text-opacity"]; found {
		err = json.Unmarshal(raw, &a.TextOpacity)
		if err != nil {
			return fmt.Errorf("error reading 'text-opacity': %w", err)
		}
		delete(object, "text-opacity")
	}

	if raw, found := object["text-transform"]; found {
		err = json.Unmarshal(raw, &a.TextTransform)
		if err != nil {
			return fmt.Errorf("error reading 'text-transform': %w", err)
		}
		delete(object, "text-transform")
	}

	if raw, found := object["z-index"]; found {
		err = json.Unmarshal(raw, &a.ZIndex)
		if err != nil {
			return fmt.Errorf("error reading 'z-index': %w", err)
		}
		delete(object, "z-index")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for RelationshipStyles0 to handle AdditionalProperties
func (a RelationshipStyles0) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Animation != nil {
		object["animation"], err = json.Marshal(a.Animation)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'animation': %w", err)
		}
	}

	if a.ArrowScale != nil {
		object["arrow-scale"], err = json.Marshal(a.ArrowScale)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'arrow-scale': %w", err)
		}
	}

	if a.Color != nil {
		object["color"], err = json.Marshal(a.Color)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'color': %w", err)
		}
	}

	if a.CurveStyle != nil {
		object["curve-style"], err = json.Marshal(a.CurveStyle)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'curve-style': %w", err)
		}
	}

	if a.EdgeAnimation != nil {
		object["edge-animation"], err = json.Marshal(a.EdgeAnimation)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'edge-animation': %w", err)
		}
	}

	if a.FontFamily != nil {
		object["font-family"], err = json.Marshal(a.FontFamily)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'font-family': %w", err)
		}
	}

	if a.FontSize != nil {
		object["font-size"], err = json.Marshal(a.FontSize)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'font-size': %w", err)
		}
	}

	if a.FontStyle != nil {
		object["font-style"], err = json.Marshal(a.FontStyle)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'font-style': %w", err)
		}
	}

	if a.FontWeight != nil {
		object["font-weight"], err = json.Marshal(a.FontWeight)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'font-weight': %w", err)
		}
	}

	if a.Label != nil {
		object["label"], err = json.Marshal(a.Label)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'label': %w", err)
		}
	}

	if a.LineCap != nil {
		object["line-cap"], err = json.Marshal(a.LineCap)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'line-cap': %w", err)
		}
	}

	if a.LineColor != nil {
		object["line-color"], err = json.Marshal(a.LineColor)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'line-color': %w", err)
		}
	}

	if a.LineOpacity != nil {
		object["line-opacity"], err = json.Marshal(a.LineOpacity)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'line-opacity': %w", err)
		}
	}

	if a.LineStyle != nil {
		object["line-style"], err = json.Marshal(a.LineStyle)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'line-style': %w", err)
		}
	}

	if a.MidTargetArrowColor != nil {
		object["mid-target-arrow-color"], err = json.Marshal(a.MidTargetArrowColor)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'mid-target-arrow-color': %w", err)
		}
	}

	if a.MidTargetArrowFill != nil {
		object["mid-target-arrow-fill"], err = json.Marshal(a.MidTargetArrowFill)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'mid-target-arrow-fill': %w", err)
		}
	}

	if a.MidTargetArrowShape != nil {
		object["mid-target-arrow-shape"], err = json.Marshal(a.MidTargetArrowShape)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'mid-target-arrow-shape': %w", err)
		}
	}

	if a.Opacity != nil {
		object["opacity"], err = json.Marshal(a.Opacity)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'opacity': %w", err)
		}
	}

	object["primaryColor"], err = json.Marshal(a.PrimaryColor)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'primaryColor': %w", err)
	}

	if a.SecondaryColor != nil {
		object["secondaryColor"], err = json.Marshal(a.SecondaryColor)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'secondaryColor': %w", err)
		}
	}

	if a.SourceLabel != nil {
		object["source-label"], err = json.Marshal(a.SourceLabel)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'source-label': %w", err)
		}
	}

	object["svgColor"], err = json.Marshal(a.SvgColor)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'svgColor': %w", err)
	}

	object["svgComplete"], err = json.Marshal(a.SvgComplete)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'svgComplete': %w", err)
	}

	object["svgWhite"], err = json.Marshal(a.SvgWhite)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'svgWhite': %w", err)
	}

	if a.TargetArrowColor != nil {
		object["target-arrow-color"], err = json.Marshal(a.TargetArrowColor)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'target-arrow-color': %w", err)
		}
	}

	if a.TargetArrowFill != nil {
		object["target-arrow-fill"], err = json.Marshal(a.TargetArrowFill)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'target-arrow-fill': %w", err)
		}
	}

	if a.TargetArrowShape != nil {
		object["target-arrow-shape"], err = json.Marshal(a.TargetArrowShape)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'target-arrow-shape': %w", err)
		}
	}

	if a.TargetLabel != nil {
		object["target-label"], err = json.Marshal(a.TargetLabel)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'target-label': %w", err)
		}
	}

	if a.TextOpacity != nil {
		object["text-opacity"], err = json.Marshal(a.TextOpacity)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'text-opacity': %w", err)
		}
	}

	if a.TextTransform != nil {
		object["text-transform"], err = json.Marshal(a.TextTransform)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'text-transform': %w", err)
		}
	}

	if a.ZIndex != nil {
		object["z-index"], err = json.Marshal(a.ZIndex)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'z-index': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for RelationshipStyles1. Returns the specified
// element and whether it was found
func (a RelationshipStyles1) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for RelationshipStyles1
func (a *RelationshipStyles1) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for RelationshipStyles1 to handle AdditionalProperties
func (a *RelationshipStyles1) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["animation"]; found {
		err = json.Unmarshal(raw, &a.Animation)
		if err != nil {
			return fmt.Errorf("error reading 'animation': %w", err)
		}
		delete(object, "animation")
	}

	if raw, found := object["color"]; found {
		err = json.Unmarshal(raw, &a.Color)
		if err != nil {
			return fmt.Errorf("error reading 'color': %w", err)
		}
		delete(object, "color")
	}

	if raw, found := object["font-family"]; found {
		err = json.Unmarshal(raw, &a.FontFamily)
		if err != nil {
			return fmt.Errorf("error reading 'font-family': %w", err)
		}
		delete(object, "font-family")
	}

	if raw, found := object["font-size"]; found {
		err = json.Unmarshal(raw, &a.FontSize)
		if err != nil {
			return fmt.Errorf("error reading 'font-size': %w", err)
		}
		delete(object, "font-size")
	}

	if raw, found := object["font-style"]; found {
		err = json.Unmarshal(raw, &a.FontStyle)
		if err != nil {
			return fmt.Errorf("error reading 'font-style': %w", err)
		}
		delete(object, "font-style")
	}

	if raw, found := object["font-weight"]; found {
		err = json.Unmarshal(raw, &a.FontWeight)
		if err != nil {
			return fmt.Errorf("error reading 'font-weight': %w", err)
		}
		delete(object, "font-weight")
	}

	if raw, found := object["label"]; found {
		err = json.Unmarshal(raw, &a.Label)
		if err != nil {
			return fmt.Errorf("error reading 'label': %w", err)
		}
		delete(object, "label")
	}

	if raw, found := object["opacity"]; found {
		err = json.Unmarshal(raw, &a.Opacity)
		if err != nil {
			return fmt.Errorf("error reading 'opacity': %w", err)
		}
		delete(object, "opacity")
	}

	if raw, found := object["primaryColor"]; found {
		err = json.Unmarshal(raw, &a.PrimaryColor)
		if err != nil {
			return fmt.Errorf("error reading 'primaryColor': %w", err)
		}
		delete(object, "primaryColor")
	}

	if raw, found := object["secondaryColor"]; found {
		err = json.Unmarshal(raw, &a.SecondaryColor)
		if err != nil {
			return fmt.Errorf("error reading 'secondaryColor': %w", err)
		}
		delete(object, "secondaryColor")
	}

	if raw, found := object["svgColor"]; found {
		err = json.Unmarshal(raw, &a.SvgColor)
		if err != nil {
			return fmt.Errorf("error reading 'svgColor': %w", err)
		}
		delete(object, "svgColor")
	}

	if raw, found := object["svgComplete"]; found {
		err = json.Unmarshal(raw, &a.SvgComplete)
		if err != nil {
			return fmt.Errorf("error reading 'svgComplete': %w", err)
		}
		delete(object, "svgComplete")
	}

	if raw, found := object["svgWhite"]; found {
		err = json.Unmarshal(raw, &a.SvgWhite)
		if err != nil {
			return fmt.Errorf("error reading 'svgWhite': %w", err)
		}
		delete(object, "svgWhite")
	}

	if raw, found := object["text-opacity"]; found {
		err = json.Unmarshal(raw, &a.TextOpacity)
		if err != nil {
			return fmt.Errorf("error reading 'text-opacity': %w", err)
		}
		delete(object, "text-opacity")
	}

	if raw, found := object["text-transform"]; found {
		err = json.Unmarshal(raw, &a.TextTransform)
		if err != nil {
			return fmt.Errorf("error reading 'text-transform': %w", err)
		}
		delete(object, "text-transform")
	}

	if raw, found := object["z-index"]; found {
		err = json.Unmarshal(raw, &a.ZIndex)
		if err != nil {
			return fmt.Errorf("error reading 'z-index': %w", err)
		}
		delete(object, "z-index")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for RelationshipStyles1 to handle AdditionalProperties
func (a RelationshipStyles1) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Animation != nil {
		object["animation"], err = json.Marshal(a.Animation)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'animation': %w", err)
		}
	}

	if a.Color != nil {
		object["color"], err = json.Marshal(a.Color)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'color': %w", err)
		}
	}

	if a.FontFamily != nil {
		object["font-family"], err = json.Marshal(a.FontFamily)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'font-family': %w", err)
		}
	}

	if a.FontSize != nil {
		object["font-size"], err = json.Marshal(a.FontSize)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'font-size': %w", err)
		}
	}

	if a.FontStyle != nil {
		object["font-style"], err = json.Marshal(a.FontStyle)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'font-style': %w", err)
		}
	}

	if a.FontWeight != nil {
		object["font-weight"], err = json.Marshal(a.FontWeight)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'font-weight': %w", err)
		}
	}

	if a.Label != nil {
		object["label"], err = json.Marshal(a.Label)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'label': %w", err)
		}
	}

	if a.Opacity != nil {
		object["opacity"], err = json.Marshal(a.Opacity)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'opacity': %w", err)
		}
	}

	object["primaryColor"], err = json.Marshal(a.PrimaryColor)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'primaryColor': %w", err)
	}

	if a.SecondaryColor != nil {
		object["secondaryColor"], err = json.Marshal(a.SecondaryColor)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'secondaryColor': %w", err)
		}
	}

	object["svgColor"], err = json.Marshal(a.SvgColor)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'svgColor': %w", err)
	}

	object["svgComplete"], err = json.Marshal(a.SvgComplete)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'svgComplete': %w", err)
	}

	object["svgWhite"], err = json.Marshal(a.SvgWhite)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'svgWhite': %w", err)
	}

	if a.TextOpacity != nil {
		object["text-opacity"], err = json.Marshal(a.TextOpacity)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'text-opacity': %w", err)
		}
	}

	if a.TextTransform != nil {
		object["text-transform"], err = json.Marshal(a.TextTransform)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'text-transform': %w", err)
		}
	}

	if a.ZIndex != nil {
		object["z-index"], err = json.Marshal(a.ZIndex)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'z-index': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Styles. Returns the specified
// element and whether it was found
func (a Styles) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Styles
func (a *Styles) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Styles to handle AdditionalProperties
func (a *Styles) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["animation"]; found {
		err = json.Unmarshal(raw, &a.Animation)
		if err != nil {
			return fmt.Errorf("error reading 'animation': %w", err)
		}
		delete(object, "animation")
	}

	if raw, found := object["color"]; found {
		err = json.Unmarshal(raw, &a.Color)
		if err != nil {
			return fmt.Errorf("error reading 'color': %w", err)
		}
		delete(object, "color")
	}

	if raw, found := object["font-family"]; found {
		err = json.Unmarshal(raw, &a.FontFamily)
		if err != nil {
			return fmt.Errorf("error reading 'font-family': %w", err)
		}
		delete(object, "font-family")
	}

	if raw, found := object["font-size"]; found {
		err = json.Unmarshal(raw, &a.FontSize)
		if err != nil {
			return fmt.Errorf("error reading 'font-size': %w", err)
		}
		delete(object, "font-size")
	}

	if raw, found := object["font-style"]; found {
		err = json.Unmarshal(raw, &a.FontStyle)
		if err != nil {
			return fmt.Errorf("error reading 'font-style': %w", err)
		}
		delete(object, "font-style")
	}

	if raw, found := object["font-weight"]; found {
		err = json.Unmarshal(raw, &a.FontWeight)
		if err != nil {
			return fmt.Errorf("error reading 'font-weight': %w", err)
		}
		delete(object, "font-weight")
	}

	if raw, found := object["label"]; found {
		err = json.Unmarshal(raw, &a.Label)
		if err != nil {
			return fmt.Errorf("error reading 'label': %w", err)
		}
		delete(object, "label")
	}

	if raw, found := object["opacity"]; found {
		err = json.Unmarshal(raw, &a.Opacity)
		if err != nil {
			return fmt.Errorf("error reading 'opacity': %w", err)
		}
		delete(object, "opacity")
	}

	if raw, found := object["primaryColor"]; found {
		err = json.Unmarshal(raw, &a.PrimaryColor)
		if err != nil {
			return fmt.Errorf("error reading 'primaryColor': %w", err)
		}
		delete(object, "primaryColor")
	}

	if raw, found := object["secondaryColor"]; found {
		err = json.Unmarshal(raw, &a.SecondaryColor)
		if err != nil {
			return fmt.Errorf("error reading 'secondaryColor': %w", err)
		}
		delete(object, "secondaryColor")
	}

	if raw, found := object["svgColor"]; found {
		err = json.Unmarshal(raw, &a.SvgColor)
		if err != nil {
			return fmt.Errorf("error reading 'svgColor': %w", err)
		}
		delete(object, "svgColor")
	}

	if raw, found := object["svgComplete"]; found {
		err = json.Unmarshal(raw, &a.SvgComplete)
		if err != nil {
			return fmt.Errorf("error reading 'svgComplete': %w", err)
		}
		delete(object, "svgComplete")
	}

	if raw, found := object["svgWhite"]; found {
		err = json.Unmarshal(raw, &a.SvgWhite)
		if err != nil {
			return fmt.Errorf("error reading 'svgWhite': %w", err)
		}
		delete(object, "svgWhite")
	}

	if raw, found := object["text-opacity"]; found {
		err = json.Unmarshal(raw, &a.TextOpacity)
		if err != nil {
			return fmt.Errorf("error reading 'text-opacity': %w", err)
		}
		delete(object, "text-opacity")
	}

	if raw, found := object["text-transform"]; found {
		err = json.Unmarshal(raw, &a.TextTransform)
		if err != nil {
			return fmt.Errorf("error reading 'text-transform': %w", err)
		}
		delete(object, "text-transform")
	}

	if raw, found := object["z-index"]; found {
		err = json.Unmarshal(raw, &a.ZIndex)
		if err != nil {
			return fmt.Errorf("error reading 'z-index': %w", err)
		}
		delete(object, "z-index")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Styles to handle AdditionalProperties
func (a Styles) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Animation != nil {
		object["animation"], err = json.Marshal(a.Animation)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'animation': %w", err)
		}
	}

	if a.Color != nil {
		object["color"], err = json.Marshal(a.Color)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'color': %w", err)
		}
	}

	if a.FontFamily != nil {
		object["font-family"], err = json.Marshal(a.FontFamily)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'font-family': %w", err)
		}
	}

	if a.FontSize != nil {
		object["font-size"], err = json.Marshal(a.FontSize)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'font-size': %w", err)
		}
	}

	if a.FontStyle != nil {
		object["font-style"], err = json.Marshal(a.FontStyle)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'font-style': %w", err)
		}
	}

	if a.FontWeight != nil {
		object["font-weight"], err = json.Marshal(a.FontWeight)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'font-weight': %w", err)
		}
	}

	if a.Label != nil {
		object["label"], err = json.Marshal(a.Label)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'label': %w", err)
		}
	}

	if a.Opacity != nil {
		object["opacity"], err = json.Marshal(a.Opacity)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'opacity': %w", err)
		}
	}

	object["primaryColor"], err = json.Marshal(a.PrimaryColor)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'primaryColor': %w", err)
	}

	if a.SecondaryColor != nil {
		object["secondaryColor"], err = json.Marshal(a.SecondaryColor)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'secondaryColor': %w", err)
		}
	}

	object["svgColor"], err = json.Marshal(a.SvgColor)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'svgColor': %w", err)
	}

	object["svgComplete"], err = json.Marshal(a.SvgComplete)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'svgComplete': %w", err)
	}

	object["svgWhite"], err = json.Marshal(a.SvgWhite)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'svgWhite': %w", err)
	}

	if a.TextOpacity != nil {
		object["text-opacity"], err = json.Marshal(a.TextOpacity)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'text-opacity': %w", err)
		}
	}

	if a.TextTransform != nil {
		object["text-transform"], err = json.Marshal(a.TextTransform)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'text-transform': %w", err)
		}
	}

	if a.ZIndex != nil {
		object["z-index"], err = json.Marshal(a.ZIndex)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'z-index': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// AsRelationshipStyles0 returns the union data inside the RelationshipStyles as a RelationshipStyles0
func (t RelationshipStyles) AsRelationshipStyles0() (RelationshipStyles0, error) {
	var body RelationshipStyles0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRelationshipStyles0 overwrites any union data inside the RelationshipStyles as the provided RelationshipStyles0
func (t *RelationshipStyles) FromRelationshipStyles0(v RelationshipStyles0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRelationshipStyles0 performs a merge with any union data inside the RelationshipStyles, using the provided RelationshipStyles0
func (t *RelationshipStyles) MergeRelationshipStyles0(v RelationshipStyles0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRelationshipStyles1 returns the union data inside the RelationshipStyles as a RelationshipStyles1
func (t RelationshipStyles) AsRelationshipStyles1() (RelationshipStyles1, error) {
	var body RelationshipStyles1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRelationshipStyles1 overwrites any union data inside the RelationshipStyles as the provided RelationshipStyles1
func (t *RelationshipStyles) FromRelationshipStyles1(v RelationshipStyles1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRelationshipStyles1 performs a merge with any union data inside the RelationshipStyles, using the provided RelationshipStyles1
func (t *RelationshipStyles) MergeRelationshipStyles1(v RelationshipStyles1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t RelationshipStyles) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *RelationshipStyles) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}
