/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

/**
 * This interface was referenced by `HttpsSchemasMesheryIoSelectorJson`'s JSON-Schema
 * via the `definition` "matchSelector".
 */
export type MatchSelector = ({
  kind?: string;
  /**
   * A Universally Unique Identifier used to uniquely identify entites in Meshery. The UUID core defintion is used across different schemas.
   */
  id?: string;
  [k: string]: unknown;
} & (
  | {
      /**
       * JSON ref to value from where patch should be applied.
       */
      mutatorRef?: string[][];
      [k: string]: unknown;
    }
  | {
      mutatedRef?: string[][];
      [k: string]: unknown;
    }
))[];
/**
 * Sub category of the model determines the secondary grouping.
 */
export type SubCategory =
  | "API Gateway"
  | "API Integration"
  | "Application Definition & Image Build"
  | "Automation & Configuration"
  | "Certified Kubernetes - Distribution"
  | "Chaos Engineering"
  | "Cloud Native Storage"
  | "Cloud Provider"
  | "CNI"
  | "Compute"
  | "Container Registry"
  | "Container Runtime"
  | "Container Security"
  | "Container"
  | "Content Delivery Network"
  | "Continuous Integration & Delivery"
  | "Coordination & Service Discovery"
  | "Database"
  | "Flowchart"
  | "Framework"
  | "Installable Platform"
  | "Key Management"
  | "Key Management Service"
  | "Kubernetes"
  | "Logging"
  | "Machine Learning"
  | "Management Governance"
  | "Metrics"
  | "Monitoring"
  | "Networking Content Delivery"
  | "Operating System"
  | "Query"
  | "Remote Procedure Call"
  | "Scheduling & Orchestration"
  | "Secrets Management"
  | "Security Identity & Compliance"
  | "Service Mesh"
  | "Service Proxy"
  | "Source Version Control"
  | "Storage"
  | "Specifications"
  | "Streaming & Messaging"
  | "Tools"
  | "Tracing"
  | "Uncategorized"
  | "Video Conferencing";
export type MatchSelector1 = ({
  kind?: string;
  /**
   * A Universally Unique Identifier used to uniquely identify entites in Meshery. The UUID core defintion is used across different schemas.
   */
  id?: string;
  [k: string]: unknown;
} & (
  | {
      /**
       * JSON ref to value from where patch should be applied.
       */
      mutatorRef?: string[][];
      [k: string]: unknown;
    }
  | {
      mutatedRef?: string[][];
      [k: string]: unknown;
    }
))[];
export type MatchSelector2 = ({
  kind?: string;
  /**
   * A Universally Unique Identifier used to uniquely identify entites in Meshery. The UUID core defintion is used across different schemas.
   */
  id?: string;
  [k: string]: unknown;
} & (
  | {
      /**
       * JSON ref to value from where patch should be applied.
       */
      mutatorRef?: string[][];
      [k: string]: unknown;
    }
  | {
      mutatedRef?: string[][];
      [k: string]: unknown;
    }
))[];
/**
 * Describes the component(s) which are involved in the relationship along with a set of actions to perform upon selection match.
 *
 * This interface was referenced by `HttpsSchemasMesheryIoSelectorJson`'s JSON-Schema
 * via the `definition` "selector".
 */
export type Selector = {
  kind?: string;
  model?: HttpsSchemasMesheryIoModelJson;
  /**
   * A Universally Unique Identifier used to uniquely identify entites in Meshery. The UUID core defintion is used across different schemas.
   */
  id?: string;
  match?:
    | {
        refs?: string[][];
        [k: string]: unknown;
      }
    | {
        from?: MatchSelector1;
        to?: MatchSelector2;
        [k: string]: unknown;
      };
  patch?: {
    /**
     * patchStrategy allows you to make specific changes to a resource using a standard JSON Patch format (RFC 6902).
     *
     * add: Inserts a value into an array or adds a member to an object.
     * replace: Replaces a value.
     * merge: Combines the values of the target location with the values from the patch. If the target location doesn't exist, it is created.
     * strategic:specific to Kubernetes and understands the structure of Kubernetes objects. It can handle complex changes like updating lists and maps, as well as preserving default values. However, it's not supported for custom resources. For custom resources, only JSON Patch and Merge Patch are typically supported.
     * remove: Removes a value.
     * copy: Copies a value from one location to another.
     * move: Moves a value from one location to another.
     * test: Tests that a value at the target location is equal to a specified value.
     */
    patchStrategy?: "merge" | "strategic" | "add" | "remove" | "copy" | "move" | "test";
    [k: string]: unknown;
  } & (
    | {
        /**
         * JSON ref to value from where patch should be applied.
         */
        mutatorRef?: string[][];
        [k: string]: unknown;
      }
    | {
        mutatedRef?: string[][];
        [k: string]: unknown;
      }
  );
}[];
/**
 * Describes the component(s) which are involved in the relationship along with a set of actions to perform upon selection match.
 */
export type Selector1 = {
  kind?: string;
  model?: HttpsSchemasMesheryIoModelJson;
  /**
   * A Universally Unique Identifier used to uniquely identify entites in Meshery. The UUID core defintion is used across different schemas.
   */
  id?: string;
  match?:
    | {
        refs?: string[][];
        [k: string]: unknown;
      }
    | {
        from?: MatchSelector1;
        to?: MatchSelector2;
        [k: string]: unknown;
      };
  patch?: {
    /**
     * patchStrategy allows you to make specific changes to a resource using a standard JSON Patch format (RFC 6902).
     *
     * add: Inserts a value into an array or adds a member to an object.
     * replace: Replaces a value.
     * merge: Combines the values of the target location with the values from the patch. If the target location doesn't exist, it is created.
     * strategic:specific to Kubernetes and understands the structure of Kubernetes objects. It can handle complex changes like updating lists and maps, as well as preserving default values. However, it's not supported for custom resources. For custom resources, only JSON Patch and Merge Patch are typically supported.
     * remove: Removes a value.
     * copy: Copies a value from one location to another.
     * move: Moves a value from one location to another.
     * test: Tests that a value at the target location is equal to a specified value.
     */
    patchStrategy?: "merge" | "strategic" | "add" | "remove" | "copy" | "move" | "test";
    [k: string]: unknown;
  } & (
    | {
        /**
         * JSON ref to value from where patch should be applied.
         */
        mutatorRef?: string[][];
        [k: string]: unknown;
      }
    | {
        mutatedRef?: string[][];
        [k: string]: unknown;
      }
  );
}[];
/**
 * Describes the component(s) which are involved in the relationship along with a set of actions to perform upon selection match.
 */
export type Selector2 = {
  kind?: string;
  model?: HttpsSchemasMesheryIoModelJson;
  /**
   * A Universally Unique Identifier used to uniquely identify entites in Meshery. The UUID core defintion is used across different schemas.
   */
  id?: string;
  match?:
    | {
        refs?: string[][];
        [k: string]: unknown;
      }
    | {
        from?: MatchSelector1;
        to?: MatchSelector2;
        [k: string]: unknown;
      };
  patch?: {
    /**
     * patchStrategy allows you to make specific changes to a resource using a standard JSON Patch format (RFC 6902).
     *
     * add: Inserts a value into an array or adds a member to an object.
     * replace: Replaces a value.
     * merge: Combines the values of the target location with the values from the patch. If the target location doesn't exist, it is created.
     * strategic:specific to Kubernetes and understands the structure of Kubernetes objects. It can handle complex changes like updating lists and maps, as well as preserving default values. However, it's not supported for custom resources. For custom resources, only JSON Patch and Merge Patch are typically supported.
     * remove: Removes a value.
     * copy: Copies a value from one location to another.
     * move: Moves a value from one location to another.
     * test: Tests that a value at the target location is equal to a specified value.
     */
    patchStrategy?: "merge" | "strategic" | "add" | "remove" | "copy" | "move" | "test";
    [k: string]: unknown;
  } & (
    | {
        /**
         * JSON ref to value from where patch should be applied.
         */
        mutatorRef?: string[][];
        [k: string]: unknown;
      }
    | {
        mutatedRef?: string[][];
        [k: string]: unknown;
      }
  );
}[];
/**
 * Describes the component(s) which are involved in the relationship along with a set of actions to perform upon selection match.
 */
export type Selector3 = {
  kind?: string;
  model?: HttpsSchemasMesheryIoModelJson;
  /**
   * A Universally Unique Identifier used to uniquely identify entites in Meshery. The UUID core defintion is used across different schemas.
   */
  id?: string;
  match?:
    | {
        refs?: string[][];
        [k: string]: unknown;
      }
    | {
        from?: MatchSelector1;
        to?: MatchSelector2;
        [k: string]: unknown;
      };
  patch?: {
    /**
     * patchStrategy allows you to make specific changes to a resource using a standard JSON Patch format (RFC 6902).
     *
     * add: Inserts a value into an array or adds a member to an object.
     * replace: Replaces a value.
     * merge: Combines the values of the target location with the values from the patch. If the target location doesn't exist, it is created.
     * strategic:specific to Kubernetes and understands the structure of Kubernetes objects. It can handle complex changes like updating lists and maps, as well as preserving default values. However, it's not supported for custom resources. For custom resources, only JSON Patch and Merge Patch are typically supported.
     * remove: Removes a value.
     * copy: Copies a value from one location to another.
     * move: Moves a value from one location to another.
     * test: Tests that a value at the target location is equal to a specified value.
     */
    patchStrategy?: "merge" | "strategic" | "add" | "remove" | "copy" | "move" | "test";
    [k: string]: unknown;
  } & (
    | {
        /**
         * JSON ref to value from where patch should be applied.
         */
        mutatorRef?: string[][];
        [k: string]: unknown;
      }
    | {
        mutatedRef?: string[][];
        [k: string]: unknown;
      }
  );
}[];
/**
 * Describes the component(s) which are involved in the relationship along with a set of actions to perform upon selection match.
 */
export type Selector4 = {
  kind?: string;
  model?: HttpsSchemasMesheryIoModelJson;
  /**
   * A Universally Unique Identifier used to uniquely identify entites in Meshery. The UUID core defintion is used across different schemas.
   */
  id?: string;
  match?:
    | {
        refs?: string[][];
        [k: string]: unknown;
      }
    | {
        from?: MatchSelector1;
        to?: MatchSelector2;
        [k: string]: unknown;
      };
  patch?: {
    /**
     * patchStrategy allows you to make specific changes to a resource using a standard JSON Patch format (RFC 6902).
     *
     * add: Inserts a value into an array or adds a member to an object.
     * replace: Replaces a value.
     * merge: Combines the values of the target location with the values from the patch. If the target location doesn't exist, it is created.
     * strategic:specific to Kubernetes and understands the structure of Kubernetes objects. It can handle complex changes like updating lists and maps, as well as preserving default values. However, it's not supported for custom resources. For custom resources, only JSON Patch and Merge Patch are typically supported.
     * remove: Removes a value.
     * copy: Copies a value from one location to another.
     * move: Moves a value from one location to another.
     * test: Tests that a value at the target location is equal to a specified value.
     */
    patchStrategy?: "merge" | "strategic" | "add" | "remove" | "copy" | "move" | "test";
    [k: string]: unknown;
  } & (
    | {
        /**
         * JSON ref to value from where patch should be applied.
         */
        mutatorRef?: string[][];
        [k: string]: unknown;
      }
    | {
        mutatedRef?: string[][];
        [k: string]: unknown;
      }
  );
}[];
/**
 * Selectors are organized as an array, with each item containing a distinct set of selectors that share a common functionality. This structure allows for flexibility in defining relationships, even when different components are involved.
 *
 * This interface was referenced by `HttpsSchemasMesheryIoSelectorJson`'s JSON-Schema
 * via the `definition` "selectors".
 */
export type Selectors = {
  /**
   * Optional selectors used to define relationships which should not be created / is restricted.
   */
  deny?: {
    from: Selector1;
    to: Selector2;
    [k: string]: unknown;
  };
  /**
   * Selectors used to define relationships which are allowed.
   */
  allow: {
    from: Selector3;
    to: Selector4;
    [k: string]: unknown;
  };
}[];

/**
 * Reusable relationships selectors schema elements
 */
export interface HttpsSchemasMesheryIoSelectorJson {
  [k: string]: unknown;
}
/**
 * Name of the model implicated by this selector. Learn more at https://docs.meshery.io/concepts/models
 */
export interface HttpsSchemasMesheryIoModelJson {
  /**
   * A Universally Unique Identifier used to uniquely identify entites in Meshery. The UUID core defintion is used across different schemas.
   */
  id: string;
  /**
   * Specifies the version of the schema used for the definition.
   */
  schemaVersion: string;
  /**
   * Version of the model definition.
   */
  version: string;
  /**
   * The unique name for the model within the scope of a registrant.
   */
  name: string;
  /**
   * Human-readable name for the model.
   */
  displayName: string;
  /**
   * Description of the model.
   */
  description: string;
  /**
   * Status of model, including:
   * - duplicate: this component is a duplicate of another. The component that is to be the canonical reference and that is duplicated by other components should not be assigned the 'duplicate' status.
   * - maintenance: model is unavailable for a period of time.
   * - enabled: model is available for use for all users of this Meshery Server.
   * - ignored: model is unavailable for use for all users of this Meshery Server.
   */
  status: "ignored" | "enabled" | "duplicate";
  registrant: HttpsSchemasMesheryIoComponentJson;
  /**
   * A Universally Unique Identifier used to uniquely identify entites in Meshery. The UUID core defintion is used across different schemas.
   */
  registrantId: string;
  /**
   * A Universally Unique Identifier used to uniquely identify entites in Meshery. The UUID core defintion is used across different schemas.
   */
  categoryId: string;
  category: HttpsSchemasMesheryIoCategoryJson;
  subCategory: SubCategory;
  /**
   * Metadata containing additional information associated with the model.
   */
  metadata?: {
    /**
     * Capabilities associated with the model
     */
    capabilities?: HttpsSchemasMesheryIoCapabilityJson[];
    /**
     * Indicates whether the model and its entities should be treated as deployable entities or as logical representations.
     */
    isAnnotation?: boolean;
    /**
     * Primary color associated with the model.
     */
    primaryColor?: string;
    /**
     * Secondary color associated with the model.
     */
    secondaryColor?: string;
    /**
     * SVG representation of the model in white color.
     */
    svgWhite: string;
    /**
     * SVG representation of the model in colored format.
     */
    svgColor: string;
    /**
     * SVG representation of the complete model.
     */
    svgComplete?: string;
    /**
     * The shape of the node’s body. Note that each shape fits within the specified width and height, and so you may have to adjust width and height if you desire an equilateral shape (i.e. width !== height for several equilateral shapes)
     */
    shape?:
      | "circle"
      | "ellipse"
      | "triangle"
      | "round-triangle"
      | "rectangle"
      | "round-rectangle"
      | "bottom-round-rectangle"
      | "cut-rectangle"
      | "barrel"
      | "rhomboid"
      | "diamond"
      | "round-diamond"
      | "pentagon"
      | "round-pentagon"
      | "hexagon"
      | "round-hexagon"
      | "concave-hexagon"
      | "heptagon"
      | "round-heptagon"
      | "octagon"
      | "round-octagon"
      | "star"
      | "tag"
      | "round-tag"
      | "vee"
      | "polygon";
    [k: string]: unknown;
  };
  model: Model;
  relationships: unknown[];
  components: unknown[];
  /**
   * Number of components associated with the model.
   */
  componentsCount: number;
  /**
   * Number of relationships associated with the model.
   */
  relationshipsCount: number;
}
/**
 * Meshery Connections are managed and unmanaged resources that either through discovery or manual entry are tracked by Meshery. Learn more at https://docs.meshery.io/concepts/logical/connections
 */
export interface HttpsSchemasMesheryIoComponentJson {
  /**
   * A Universally Unique Identifier used to uniquely identify entites in Meshery. The UUID core defintion is used across different schemas.
   */
  id?: string;
  /**
   * Connection Name
   */
  name?: string;
  /**
   * A Universally Unique Identifier used to uniquely identify entites in Meshery. The UUID core defintion is used across different schemas.
   */
  credential_id?: string;
  /**
   * Connection Type
   */
  type: string;
  /**
   * Connection Subtype
   */
  sub_type?: string;
  /**
   * Connection Kind
   */
  kind: string;
  metadata?: {
    [k: string]: unknown;
  };
  /**
   * Connection Status
   */
  status:
    | "discovered"
    | "registered"
    | "connected"
    | "ignored"
    | "maintenance"
    | "disconnected"
    | "deleted"
    | "not found";
  /**
   * A Universally Unique Identifier used to uniquely identify entites in Meshery. The UUID core defintion is used across different schemas.
   */
  user_id?: string;
  created_at?: string;
  updated_at?: string;
  deleted_at?: string;
}
/**
 * Category of the model.
 */
export interface HttpsSchemasMesheryIoCategoryJson {
  /**
   * A Universally Unique Identifier used to uniquely identify entites in Meshery. The UUID core defintion is used across different schemas.
   */
  id: string;
  /**
   * The category of the model that determines the main grouping.
   */
  name:
    | "Analytics"
    | "App Definition and Development"
    | "Cloud Native Network"
    | "Cloud Native Storage"
    | "Database"
    | "Machine Learning"
    | "Observability and Analysis"
    | "Orchestration & Management"
    | "Platform"
    | "Provisioning"
    | "Runtime"
    | "Security & Compliance"
    | "Serverless"
    | "Tools"
    | "Uncategorized";
  metadata: {
    [k: string]: unknown;
  };
  [k: string]: unknown;
}
/**
 * Meshery manages entities in accordance with their specific capabilities. This field explicitly identifies those capabilities largely by what actions a given component supports; e.g. metric-scrape, sub-interface, and so on. This field is extensible. Entities may define a broad array of capabilities, which are in-turn dynamically interpretted by Meshery for full lifecycle management.
 */
export interface HttpsSchemasMesheryIoCapabilityJson {
  /**
   * Specifies the version of the schema to which the capability definition conforms.
   */
  schemaVersion: string;
  /**
   * Version of the capability definition.
   */
  version: string;
  /**
   * Name of the capability in human-readible format.
   */
  displayName: string;
  /**
   * A written representation of the purpose and characteristics of the capability.
   */
  description: string;
  /**
   * Top-level categorization of the capability
   */
  kind: ("action" | "mutate" | "view" | "interaction") & string;
  /**
   * Classification of capabilities. Used to group capabilities similar in nature.
   */
  type: string;
  /**
   * Most granular unit of capability classification. The combination of Kind, Type and SubType together uniquely identify a Capability.
   */
  subType: string;
  /**
   * Key that backs the capability.
   */
  key: string;
  /**
   * State of the entity in which the capability is applicable.
   */
  entityState: ("declaration" | "instance")[];
  /**
   * Status of the capability
   */
  status: "enabled" | "disabled";
  /**
   * Metadata contains additional information associated with the capability. Extension point.
   */
  metadata?: {
    [k: string]: unknown;
  };
}
/**
 * Registrant-defined data associated with the model. Properties pertain to the software being managed (e.g. Kubernetes v1.31).
 */
export interface Model {
  /**
   * Version of the model as defined by the registrant.
   */
  version: string;
  [k: string]: unknown;
}
